[https://medium.com/@stasonmars/%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-javascript-d25c261a7aff](https://medium.com/%40stasonmars/%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-javascript-d25c261a7aff) - **статья про клонирование**

[https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) - **Object.assign()**

[https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Spread_syntax](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Spread_syntax)  -  **Spread operator**

  

Новички очень часто делают ошибку по **передаче данных по ссылке и по значению**.

Создадим **переменную** let a = 5  и еще одну **переменную** b, во внутрь которой помещаем **переменную** a :

b = a. После возьмем **переменную** b и во внутрь поместим какое-то модифицированное значение b + 5, выводим в консоль обе **переменных**. Запускаем код и видим значение 10 и 5, все сработало, как мы задумали.

```JavaScript
let a = 5;
    b = a;

b = b + 5;

console.log(b);
console.log(a)
```

Теперь усложним задачу. Создадим **переменную** const obj, в которой будет находится довольно таки простой **объект** с 2 **свойствами**. Также создадим еще одну **переменную** const copy и во внутрь мы помещаем obj, то есть значение **объекта**, который мы создали. Дальше возьмем copy и обратимся к **свойству** a, и туда помещаем уже 10: copy.a = 10.

Выводим в консоль copy и obj, запускаем код и видим такую вот картину: в консоль выводится 2 абсолютно одинаковых **объекта**, хотя мы с вами модифицировали только copy, а не изначальный obj. На практике мы видим, что изменяя что-то внутри copy, мы с вами модифицируем наш и изначальный **объект** obj.

А теперь обратим особое внимание:

Когда мы работаем с примитивными **типами данных** - **строк**, **чисел**, **логических значений**, то они передаются по значению. Проще говоря, когда мы прописываем вот такую вот структуру b = a, здесь **переменная** a заменятся на 5. Когда же мы работаем с какими-то **объектами**, то у нас идет передача не по значению, а по ссылке, здесь const copy = obj мы не скопировали новый **объект**, здесь в **переменную** copy не кладется какой-то новый **объект**, который идентичен **объекту** obj. Здесь мы передаем значение по ссылке, это значит, что вот эта запись const copy = obj передает не саму структуру **объекта**, а она передает именно ссылку, в **переменную** copy кладется ссылка уже на существующий **объект**. И так получается, что модифицируя copy, мы модифицируем наш изначальный **объект** obj.

```JavaScript
const obj = {
    a: 5, 
    b: 1
};

const copy = obj;

copy.a = 10;

console.log(copy);
console.log(obj);
```

А как же создавать копии **объектов**, копии **массивов** и копии всего другого? Существует несколько способов.

Начнем с самого банального это использование **цикла**.

Напишем специальную **функцию** с **аргументом**, который мы будем передавать function copy(mainObj). Эта **функция** будет заниматься тем, что при помощи **цикла** она создаст новый **объект** уже перебирая старые **свойства**.  Сначала создадим копию: зададим внутри **функции переменную** let objCopy  и чтобы создать **объект** просто воспользуемся фигурными скобками {}, let objCopy = {}. Дальше запускаем перебирающую конструкцию, которая называется **for in.**

Здесь мы записали немного другим синтаксисом: **переменную** key можно создавать и вне такой перебирающей конструкции. (key in mainObj)- это кусок кода говорит нам о том, что у нас есть **ключи** внутри **объекта** mainObj, который передается **функцией**. Раскрываем фигурные скобки и внутри помещаем копирование наших **свойств**: берем пустой objCopy, создаем новое **свойство** [key] и дальше мы делаем копию из нашего главного **объекта** mainObj[key] (то есть проще говоря мы пройдемся по старому нашему **объекту** mainObj, скопируем все его **свойства** и поместим их в нашу копию objCopy, которая изначально была пустой. Ну и чтобы как то работать с нашим новым **объектом**, который образовался в течении действий нашей **функции**, мы при помощи return  возвращаем objCopy наружу, то есть как то потом сможем с ним взаимодействовать.

Дальше создадим новую переменную const numbers  и это у нас будет **объект** со **свойствами** и его **значениями**.

Создадим **переменную** const newNumbers  и воспользуемся **функцией** copy (она примет в себя **объект** numbers  и вернет нам новый **объект**, который уже будет копией.) const newNumbers = copy(numbers)  - то есть мы совершили клонирование **объекта**, создали копию. Берем нашу **переменную**, обращаемся к **свойству** и помещаем туда 10 newNumbers.a = 10. Запускаем код и в консоле видим абсолютно 2 разных **объекта**, в первом случае скопированный **объект**, где мы поменяли a = 10, а во втором случае **свойство** a, как равна была 2, так и осталась.

```JavaScript
function copy(mainObj) {
    let objCopy = {};

    let key;
    for (key in mainObj) {
        objCopy[key] = mainObj[key];
    }

    return objCopy;
}

const numbers = {
    a: 2,
    b: 5, 
    c: {
        x: 7, 
        y: 4
    }
};

const newNumbers = copy(numbers);

newNumbers.a = 10;

console.log(newNumbers);
console.log(numbers);
```

Если мы обратимся к **свойству** c и через точку обратимся к **свойству** x, который есть внутри этого **объекта** и поменяем его на 10 newNumbers.c.x = 10, запускам код и видим, что **свойство** c опять поменялось в двух местах.

И тут важно знать о двух понятиях: есть **глубокие** и **поверхностные** копии **объектов**. Мы создали **поверхностную** копию, потому что она берет все обычные **свойства**, которые были в родители и создает независимые структуры, но как только появляется вложенная структура, то это свойство опять будет иметь **ссылочный тип данных**.

```JavaScript
function copy(mainObj) {
    let objCopy = {};

    let key;
    for (key in mainObj) {
        objCopy[key] = mainObj[key];
    }

    return objCopy;
}

const numbers = {
    a: 2,
    b: 5, 
    c: {
        x: 7, 
        y: 4
    }
};

const newNumbers = copy(numbers);

newNumbers.a = 10;
newNumbers.c.x = 10;

console.log(newNumbers);
console.log(numbers);
```

2 способ называется Object.assign, у нашего **глобального типа данных** Object есть такой **метод**, который позволяет вам соединить сразу несколько **объектов**, то есть допустим у нас есть один какой-то большой **объект** к примеру const numbers и мы хотим поместить во внутрь еще один **объект** поменьше const add. Синтаксис у этого **метода** довольно таки простой, первым **аргументом** мы передаем тот **объект**, в который мы хотим все это поместить и вторым **аргументом** у нас идет тот **объект**, который мы помещаем const clone = Object.assign({}, add). Запускам код и видим, что 2 **объекта** у нас соединились. Но самое главное мы создали независимую **поверхностную копию** **объекта**, то есть она никак не зависит от **объектов** numbers и add. Только если считать вложенную структуру в виде **свойства** c.

```JavaScript
const numbers = {
    a: 2,
    b: 5, 
    c: {
        x: 7, 
        y: 4
    }
};

const add = {
    d: 17,
    e: 20
};

console.log(Object.assign(numbers, add));
```

То же самое мы можем сделать и с пустым **объектом**, чтобы создать просто копию **объекта**. Мы numbers заменяем на пустой **объект**, таким образом у нас создается новый **объект** и в него помещается какой-то старый **объект** add, и мы с вами получаем какую-то отдельную копию.

Давайте протестируем. Результат команды запишем в новый **объект** const clone = Object.assign({}, add). Берем наш новый **объект**, обращаемся к **свойству** и заменяем его на 20 clone.d = 20. Выводим в консоль **объекты** clone и add, запускаем код и видим, что в **объекте** add **свойство** d не поменялась, а в clone изменилась.

```JavaScript
const add = {
    d: 17,
    e: 20
};

const clone = Object.assign({}, add);

clone.d = 20;

console.log(add);
console.log(clone);
```

3 способ: Для того чтобы создать копию **частного объекта** - **массива**, создадим **переменную** oldArray и во внутрь **массива** поместим значения ['a', 'b', 'c'], const oldArray = ['a', 'b', 'c']. В **массивах**, чтобы создать **поверхностную копию** особо напрягаться не нужно, мы просто создаем новую **переменную** const newArray, обращаемся к oldArray, ставим точку и прописываем **метод** slice(), этот **метод** позволяет просто скопировать старый **массив** const newArray = oldArray.slice(). И в newArray поменяем значение второго элемента, поместим туда какую-то большую фразу newArray[1] = 'asadadaad'. Запускаем код и получаем 2 разных **массива**.

```JavaScript
const oldArray = ['a', 'b', 'c'];
const newArray = oldArray.slice();

newArray[1] = 'asadasda';
console.log(newArray);
console.log(oldArray);
```

Теперь пора познакомиться с новыми стандартами ES6-ES9. 4 способом создания **поверхностной копии** будет использование **оператора разворота** (**Spread operator)**. Этот **оператор** имеет такое название, потому что он разворачивает структуру и превращает ее в набор каких-то данных.

Создадим **массив** с 3 **переменными.**

Здесь мы создаем **переменную** internet и мы делаем так, чтобы в этой **переменной** складировались все значения из **переменных** video и blogs, и еще добавились какие-то свои. Делаем это с помощью **Spread operator**, он разворачивает **переменные** video и blogs и их структуру на отдельные значения. Синтаксис **Spread operator** это ..., такой синтаксис позволит просто вытащить эти элементы, которые будут через запятую ['youtube', 'vimeo', 'rutube'], ['wordpress', 'livejournal', 'blogger'], и они все будут помещаться уже в **переменную** internet. Выводим в консоль, запускаем код и видим такую структуру: **массив**, в котором лежат все элементы (то есть **Spread operator** развернул эти структуры на отдельные элементы).

```JavaScript
const video = ['youtube', 'vimeo', 'rutube'],
      blogs = ['wordpress', 'livejournal', 'blogger'],
      internet = [...video, ...blogs, 'vk', 'facebook'];

console.log(internet);
```

Создадим **функцию** с 3 **аргументами** function log(a, b, c) и **функция** будет заниматься тем, что будет выводить в консоль **аргументы.**

Также создадим **переменную** const num и это будет **массив** const num = [2, 5, 7], (допустим этот **массив** пришел с сервера, где-то сформировался на стороннем ресурсе и пришел в таком виде). Запускаем **функцию** со **Spread operator** log(...num)  и теперь этот **массив** const num = [2, 5, 7] просто разложится на 3 отдельных элемента, запускаем код и получаем результат.

```JavaScript
function log(a, b, c) {
    console.log(a);
    console.log(b);
    console.log(c);
}

const num = [2, 5, 7];

log(...num);
```

И как же создавать **поверхностную копию** с помощью **Spread operator** ?

Создадим **переменную** и это будет **массив** const array = ["a", "b"]. И чтобы создать **поверхностную копию** прописываем  const newAarray = [...array], теперь в этой **переменной** newAarray  лежит новая копия вот этого **массива** array.

```JavaScript
const array = ["a", "b"];

const newArray = [...array];
```

И Spread оператор также работает с объектами.

```JavaScript
const q = {
    one: 1,
    two: 2
}

const newObj = {...q};
```