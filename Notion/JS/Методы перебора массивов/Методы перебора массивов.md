[https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map) - **map**

[https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) - **filter**

[https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) - **reduce**

[https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) - **Object.entries()**

  

Эта тема максимально полезна, когда мы уже умеем работать с **сервером**, мы можем например получить какие-то данные и вот теперь нам необходимо их как-то обработать. Например: **отфильтровать**, либо полностью поменять каждый элемент, **массив** и многое другое.

Очень важное, что мы должны помнить про **метод перебора массива forEach()**, то что он нам никогда не возвращает новый **массив**, он просто берет какой-то **массив** и просто его перебирает, берет каждый отдельный **элемент** и например: выводит в консоль, или выводит на страницу и многое другое.

  

**Метод filter()**

Начнем с **метода filter()** - он будет **фильтровать** элементы внутри **массива**. Ну и конечно, чтобы **фильтровать**, нам необходимо задать какое-то правило, как это делать нашему коду. И в данном коде будет правило: что мы должны получить все имена, у которых меньше 5 символов. Данное правило, задача может быть абсолютно любой.

Но тут есть очень важная особенность **метод filter()**, **map()** и те которые мы будем далее разбирать, они нам возвращают новый **массив**, то есть когда мы **фильтруем** с помощью **метода filter()** мы оставляем старый **массив** и получаем новый, который уже **отфильтрован**.

Для того, чтобы сделать такой **фильтр**, нам необходимо из **callback - функции** возвращать те элементы, которые подходят под наше правило, задачу,

именно возвращать:  **return name.length < 5**

```JavaScript
const names= ['Ivan', 'Ann', 'Ksenia', 'Voldemort'];

const shortNames = names.filter(function(name) {
    return name.length < 5;
});

console.log(shortNames);
```

```JavaScript
[Running] node "/Users/nikitaelin/Desktop/work/JS_React/react/my-app/src/tempCodeRunnerFile.js"
[ 'Ivan', 'Ann' ]

[Done] exited with code=0 in 0.123 seconds
```

**Метод map()**

**Метод map()** позволяет взять исходный **массив** и изменить каждый элемент внутри него, соответсвенно на выходе получается опять какой-то новый **массив** уже с измененными **данными**. Код на картинке слева - это тот же самый код, как и справа, только укороченный (когда у нас одна строка в **стрелочной функции**, мы можем записать код, как на картинке слева). То есть в данном коде, используя **метод map()**, мы берем каждый элемент и приводим его в нижний регистр.

Это у нас такой трансформирующий **метод**, мы его частенько будем использовать в библиотеке **react**.

```JavaScript
const answers = ['Ivan', 'Anna', 'Hello'];

const result = answers.map(item => item.toLocaleLowerCase());

console.log(result);
```

```JavaScript
const result = answers.map(item => {
    return item.toLocaleLowerCase();
});
```

```JavaScript
[Running] node "/Users/nikitaelin/Desktop/work/JS_React/react/my-app/src/tempCodeRunnerFile.js"
[ 'ivan', 'anna', 'hello' ]

[Done] exited with code=0 in 0.113 seconds
```

**Метод some() и every()**

Эти 2 **метода** возвращают нам **булиновое значение**.

**Метод some()** берет **массив**, перебирает его, и если у нас хотя бы один элемент подходит по какому-то **условию**, который мы зададим в **callback-функцию**, то в таком случае он нам вернет **true**, и если нет, то **false**. И внутри **метода** мы прописываем **условие**: **typeof(item) === 'number'** , то есть мы спрашиваем, есть ли среди этих элементов хотя бы одно число (картинка слева)

**Метод every()** работает так, что если все элементы внутри нашего массива подходят под условие: **typeof(item) === 'number'** , то только в таком случае наш **метод** вернет **true** (код на картинке справа, здесь **false**, потому что только один элемент подходит под **условие**)

В этих двух примерах помним, что если код в одну строчку, фигурные скобки в **стрелочной функции** не раскрываются, а **return** подставляется автоматически.

```JavaScript
const some = [4, 'qwq', 'asdadad'];

console.log(some.some(item => typeof(item) === 'number'));
```

**Метод reduce()**

**Метод reduce()** служит для того, чтобы собирать **массив** в одно единое целое, особенно это касается **числовых типов данных**.

Допустим наша задача - взять и быстро получить сумму всех этих элементов. Решаем мы эту задачу с помощью **метода reduce()** и внутри него нам понадобится уже **callback - функция**, которая принимает 2 **аргумента** **(sum, current)** и все то, что будет делать данная **функция** - это складывать 2 этих **аргумента**.

**1 аргумент sum** - это сумма всех наших элементов, и когда первый раз запускается **метод перебора reduce()**, **аргумент sum** равен 0.

При этом **2 аргумент current** - это каждый элемент, который приходит к нему от **массива**, в данном коде эта числа: **4, 5, 1, 3, 2, 6**

И этот **метод** работает так:

**sum**  **current**

![[Untitled 133.png|Untitled 133.png]]

И в итоге получаем результат в консоле 21 (код на картинке слева)

Также **метод reduce()** использовать со **строками**. В коде (на картинке посередине) мы используем **интерполяцию**, для того чтобы свернуть **массив**.

И еще есть такая синтаксическая плюшка то, что **метод** **reduce()** принимает в себя еще один **аргумент**. После c**allback - функции**, как 2 **аргумент** передать какое-то начальное значение, допустим **3**, и в таком случае вместо нулевого значения у **sum** подставится **3**.

![[Untitled 1 65.png|Untitled 1 65.png]]

И в результате в консоле будет 24 (код на картинке справа)

```JavaScript
const arr = [4, 5, 1, 3, 2, 6];

const res = arr.reduce((sum, current) => sum + current);

console.log(res);
```

```JavaScript
const arr = ['apple', 'pear', 'plum'];

const res = arr.reduce((sum, current) => `${sum}, ${current}`);

console.log(res);
```

```JavaScript
const arr = [4, 5, 1, 3, 2, 6];

const res = arr.reduce((sum, current) => sum + current, 3);

console.log(res);
```

```JavaScript
[Running] node "/Users/nikitaelin/Desktop/work/JS_React/react/my-app/src/tempCodeRunnerFile.js"
21

[Done] exited with code=0 in 0.11 seconds
```

```JavaScript
[Running] node "/Users/nikitaelin/Desktop/work/JS_React/react/my-app/src/tempCodeRunnerFile.js"
apple, pear, plum

[Done] exited with code=0 in 0.12 seconds
```

```JavaScript
[Running] node "/Users/nikitaelin/Desktop/work/JS_React/react/my-app/src/tempCodeRunnerFile.js"
24

[Done] exited with code=0 in 0.114 seconds
```

В данном коде мы используем **метод** , который относится уже к **объектам** - это **метод Object.entries()**, он позволяет нам взять **объект** и превратить его в **матрицу**, то есть это будет **массив** **массивов** (код на картинке слева)

Далее чтобы получить в консоль только имена нашего **объекта**, мы уже к **массиву** применяем по цепочке **методы filter()** и **map()**.

В **методе** **filter()** мы прописываем, что мы будем отфильтровывать и возвращать из **массива**, который мы перебираем, только те **массивы**, у которых второй элемент будет строгом равен **persone**: **item[1] === 'persone'**

А с помощью **метода map()** мы трансформируем **массив**, мы говорим, что внутри нового **массива** мы хотим получить только имена, то есть только первые элементы: **item => item[0]**

```JavaScript
const obj = {
    ivan: 'persone',
    ann: 'persone',
    dog: 'animal',
    cat: 'animal'
}

const newArr = Object.entries(obj);

console.log(newArr);
```

```JavaScript
const obj = {
    ivan: 'persone',
    ann: 'persone',
    dog: 'animal',
    cat: 'animal'
}

const newArr = Object.entries(obj)
.filter(item => item[1] === 'persone')
.map(item => item[0]);

console.log(newArr);
```

```JavaScript
[Running] node "/Users/nikitaelin/Desktop/work/JS_React/react/my-app/src/tempCodeRunnerFile.js"
[
  [ 'ivan', 'persone' ],
  [ 'ann', 'persone' ],
  [ 'dog', 'animal' ],
  [ 'cat', 'animal' ]
]

[Done] exited with code=0 in 0.127 seconds
```

```JavaScript
[Running] node "/Users/nikitaelin/Desktop/work/JS_React/react/my-app/src/tempCodeRunnerFile.js"
[ 'ivan', 'ann' ]

[Done] exited with code=0 in 0.112 seconds
```

Все эти **методы**, как итог позволяют получить новый **массив**, отсюда мы соблюдаем такое понятие, как **иммутабельность** и вторая большая плюшка - это то что мы можем запускать эти **методы** по цепочке.