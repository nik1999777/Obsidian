[http://algolist.ru/sort/quick_sort.php](http://algolist.ru/sort/quick_sort.php) - **алгоритм быстрой сортировки**

[http://coldfox.ru/article/5c7ffe64bbf20e61c12c7348/%D0%9E%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-for-of-%D0%BE%D1%82-for-in-%D0%B2-javascript](http://coldfox.ru/article/5c7ffe64bbf20e61c12c7348/%D0%9E%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-for-of-%D0%BE%D1%82-for-in-%D0%B2-javascript) - **отличие for...of от for...in**

![[Untitled 106.png|Untitled 106.png]]

Часто при работе с **массивами** мы хотим его просто редактировать, хотим добавить, либо удалить какой-то элемент из **массива**. И для этого у нас есть **методы** для работы как с концом **массива**, так и с его началом. И первый **метод** называется pop(), он удаляет последний элемент из **массива**, прописываем console.log(arr), запускаем код и получаем структуру, которая уже состоит из 4 элементов (картинка слева). Также есть обратный **метод**, который будет добавлять какой-то элемент в конец **массива** push(10) (картинка справа).

```JavaScript
const arr = [1, 2, 3, 6, 8];

arr.pop();

console.log(arr);
```

```JavaScript
const arr = [1, 2, 3, 6, 8];

arr.push(10);

console.log(arr);
```

Частенько необходимо перебрать элементы внутри **массива**. Для того чтобы перебрать **массив** мы можем использовать обычный **цикл**, и чтобы **цикл** перебрал все элементы **массива** и знал точно, сколько раз этот **цикл** будет запускаться, мы используем свойство arr.length  (то есть кол-во элементов внутри массива) for (let i = 0; i < arr.length; i++). Если говорить простым языком, то этот **цикл** будет отрабатывать до тех пор, пока не закончатся элементы внутри **массива**. Прописываем console.log(arr[i])  (помним, чтобы обратиться к определенному элементу **массива**, необходимо поставить квадратные скобки и внутри указать индекс [i]). Запускаем код и видим то, что мы перебрали все элементы и вывели в консоль (картинка слева).

Помимо обычного **цикла** мы можем использовать такую конструкцию перебора как **for of**.  for (let value of arr), внутри этого **массива** мы задаем переменную  value, которая будет отображать каждый отдельный элемент внутри **массива** (название **переменной** может-быть абсолютно любым). Запускаем код и видим точно такой же результат (картинка справа). Конструкцию перебора **for of** работает только с **массиво-подобными** сущностями (например: **массив**, **строку**, **псевдомассив**, и такие сущности как **map** и **set**).

```JavaScript
const arr = [1, 2, 3, 6, 8];

for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}
```

```JavaScript
const arr = [1, 2, 3, 6, 8];

for (let value of arr) {
    console.log(value);
}
```

Прописываем console.log(arr.length), запускаем код и получаем 5, что соответствует действительному кол-ву элементов в **массиве** (картинка слева). На собеседовании могут спросить вопрос: Как соотносится между собой **свойство** length  и элементы внутри **массива**? И ответ таков, что **свойство** состоит из последнего индекса, который есть у нас в **массиве**  и +1 (то есть нумерация в программировании начинается с нуля и получается 0 1 2 3 4 и 4+1 = 5).

Мы помним, что **массивы** предназначены, чтобы все элементы хранить строго по порядку. Но иногда эти правила случайно могут нарушиться. Обращаемся к **массиву** и указываем индекс номер 99  arr[99]=0 (то есть мы на 99 позицию записываем какой-то элемент), поместим просто 0  arr[99]=0. Запускаем код и получаем, что у нас 100 элементов в нашем **массиве**, хотя это совершенно не так, и вот это показывает, как раз, что свойство length  состоит из последнего индекса и + 1.

```JavaScript
const arr = [1, 2, 3, 6, 8];

console.log(arr.length);
```

```JavaScript
const arr = [1, 2, 3, 6, 8];

arr[99] = 0;

console.log(arr.length);
console.log(arr);
```

Теперь перейдем к **методу массивов**, который используется наверное больше всех в коде. Этот **метод** называется forEach(). Этот **метод** позволяет гибко перебрать все элементы, которые находятся внутри **массива**. Да, он служит точно также, как и предыдущие 2 способа перебора **массива**, но с некоторыми отличиями, мы его можем подробнее настроить. Здесь понадобятся знания про **callback - функции**, потому что этот **метод** (а **метод** - это **функция**) принимает в себя еще одну **функцию**: **callback - функцию**. Мы задаем во внутрь **функцию** arr.forEach(function(),  то есть получается, что **метод**  forEach() проходится по каждому элементу **массива** и применяет эту **функцию** на каждом из этих элементов. Эту **callback - функцию** (помним, что **callback - функция** служит для того, чтобы выполниться строго после определенных действий, в данном случае сначала  forEach(), а потом **callback**) мы можем гибко настроить, она в себя принимает **3 аргумента**:

**1 аргумент** - это тот элемент, который мы перебираем [2, 3, 6, 8, 10]  и мы задаем этот **аргумент**, как угодно, например item.

**2 аргумент** - это номер по порядку 0 1 2 3 4, **переменная** i.

**3 аргумент** - это ссылка на тот **массив**, который мы перебираем arr.

Прописываем вот такое действие console.log(`${i}: ${item} внутри массива ${arr}`), запускаем код и видим сообщение.

Если нам нужно будет остановить **цикл** полностью, либо пропустить одно повторение (это ключевые слова **break** и **continue**), то используют способ **for of**, в остальных случаях метод forEach().

```JavaScript
const arr = [1, 2, 3, 6, 8];

arr.forEach(function(item, i, arr) {
    console.log(`${i}: ${item} внутри массива ${arr}`);
})
```

Эти **методы** перебора **массивов**, также являются и **методами трансформации массивов**, они берут исходный материал и его модифицируют, **метод** же forEach(), просто его перебирает.

![[Untitled 1 45.png|Untitled 1 45.png]]

Данный **метод массива** превращает строку в **массив**. В данном случаем мы видим в консоле, что мы получили **массив**, раскрываем его и видим, что 5 элементов сформировались из той **строки**, которые мы ввели в prompt().

Именно так мы можем сформировать **массив** на основании **строк**.

```JavaScript
const str = prompt("", "");
const products = str.split(", ");
console.log(products);
```

![[Untitled 2 32.png|Untitled 2 32.png]]

![[Untitled 3 20.png|Untitled 3 20.png]]

Также есть и обратная операция, когда на основании **массива** формируем большую **строку**, то есть если из практического примера, мы можем взять список имен, которые нас интересуют и вывести на экран пользователю в качестве **строчки**, чтобы он увидел список приглашенных гостей. Используем **метод** join().

```JavaScript
const str = prompt("", "");
const products = str.split(", ");
console.log(products.join('; '));
```

![[Untitled 4 13.png|Untitled 4 13.png]]

![[Untitled 5 10.png|Untitled 5 10.png]]

Также есть метод сортировки sort(), он сортирует в алфавитном порядке. Но у него сеть одна особенность, он всегда сортирует элементы, которые находятся внутри **массива**, как строки.

```JavaScript
const str = prompt("", "");
const products = str.split(", ");
products.sort();
console.log(products.join('; '));
```

![[Untitled 6 9.png|Untitled 6 9.png]]

![[Untitled 7 8.png|Untitled 7 8.png]]

Если метод sort(), попробовать на числах, то мы видим, что числа отсортировались как строки.

```JavaScript
const arr = [2, 13, 26, 8, 10];
arr.sort();
console.log(arr);
```

![[Untitled 8 8.png|Untitled 8 8.png]]

Но это можно исправить, **метод** sort() во внутрь тоже может принимать **callback - функцию**. Напишем специальную функцию с 2 аргументами, где она будет возвращать a - b 

И если мы такую **callback - функцию** передадим сюда arr.sort(compareNum), то числа отсортируются правильно.

Может возникнуть вопрос почему эта **функция** так работает, почему мы одно число отняли от другого и все правильно отсортировалось? Дело в том, что **метод** sort(), внутри себя использует один из алгоритмов, который называется **алгоритм быстрой сортировки**.

```JavaScript
const arr = [2, 13, 26, 8, 10];
arr.sort(compareNum);
console.log(arr);

function compareNum(a, b) {
    return a - b;
}
```

![[Untitled 9 7.png|Untitled 9 7.png]]

**Понятие псевдомассивы**

Когда мы работаем с элементами на странице, то мы как раз и будем получать **псевдомассивы**. Это такой **объект**, структура которого совпадает со структурой **массива**, он будет выглядеть точно также, но при одном очень важном условии: **у псевдомассивов не будет никаких вообще методов**!