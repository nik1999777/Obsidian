**Событие** - это сигнал от браузера о том, что что-то произошло.

  

[https://oddler.ru/blog/i63](https://oddler.ru/blog/i63) - простой список **событий**

[https://developer.mozilla.org/ru/docs/Web/Events](https://developer.mozilla.org/ru/docs/Web/Events). -   большой справочник по **событиям**

[https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener](https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener) -  про **метод addEventListener()**

[https://developer.mozilla.org/ru/docs/Web/API/Event](https://developer.mozilla.org/ru/docs/Web/API/Event) - про **объект** **события Event**

[https://developer.mozilla.org/ru/docs/Web/API/EventTarget/removeEventListener](https://developer.mozilla.org/ru/docs/Web/API/EventTarget/removeEventListener) - про **метод removeEventListener()**

  

Чтобы использовать любое **событие** мы должны назначить **обработчик события**.

**Обработчик** - эта **функция**, которая срабатывает, как только **событие** произошло.

Приведем пример:  если пользователь совершает щелчок мышкой на гамбургер меню, то у нас срабатывает функция, которая открывает это меню.

То есть заметим, что каждый раз у нас один и тот же шаблон: сначала происходит событие клика или отправки, и строго после этого события выполняется уже наша собственная **функция**.

  

В JS у нас 3 способа назначить **обработчики событий**:

1) Использовать HTML **атрибут**, который записывается прямо в верстке и в этот **атрибут** мы можем передать сразу **функцию** из JS.

Само **событие** называется **onclick**, а дальше справа идет **обработчик событий** - эта **функция** **alert()**.

```HTML
<button onclick="alert('Click')" id="btn">Нажми меня</button>
```

![[Untitled 113.png|Untitled 113.png]]

2) Использовать **свойства DOM - дерева** для **событий**.

Здесь мы берем элемент **btn**, на который мы хотим повесить наше **событие** и дальше используем **свойство** **DOM - дерева**, которое называется **onclick**. И дальше идет **функция**, а **функция** будет содержать код, который выполнится только после клика.

```JavaScript
const btn = document.querySelector('.button');

btn.onclick = function() {
    alert('Click');
};
```

![[Untitled 1 51.png|Untitled 1 51.png]]

3) Предыдущие способы совсем не используются. Используется на данный момент в JS 3 способ. Он имеет преимущество над другими тем, что при таком синтаксисе мы можем назначать сразу несколько действий на одно **событие**.

Мы берем элемент **btn**, на который назначаем **обработчик события,** и добавляем конструкцию **addEventListener()**, которая будет следить за элементом и если у нас произойдет **событие**, которые мы назначим, то он запустит **обработчик событий**.

Первым **аргументом** мы передаем название нашего **события click** и вторым **аргументом** передаем нашу **callback функцию**, которая и будет нашим **обработчиком**. И в нашей **функции** должно быть какое-то действие, в данном случае **alert()**.

Помним, что **callback функции** выполняются строго друг за другом: сначала у нас выполняется **click**, а после этого наша кастомная **callback функция**.

```JavaScript
const btn = document.querySelector('.button');

btn.addEventListener('click', () => {
    alert('Click');
});

btn.addEventListener('click', () => {
    alert('Second Click');
}
```

![[Untitled 2 38.png|Untitled 2 38.png]]

![[Untitled 3 26.png|Untitled 3 26.png]]

Мы можем записать в первый **аргумент** абсолютно любое **событие,** например **mousecenter, функция** каждый раз будет выполняться, когда пользователь наводит мышкой на элемент.

```JavaScript
btn.addEventListener('mousecenter', () => {
    console.log('Hover');
});
```

![[Untitled 4 18.png|Untitled 4 18.png]]

Иногда нам нужно получить какие-то данные об **объекте**, с которым мы взаимодействуем. Для этого у нас есть специальный **объект**, который называется **event** и этот **объект события** передается, как **аргумент** в **callback функцию (e) =>**, причем называть мы можем его абсолютно, как угодно.

Выведем этот **объект** в консоль **console.log(e)**, наведем мышкой на элемент, и видим **MouseEvent** - **объект**, который описывает, что произошло с элементом, видим куча всяких координат, кнопок, сочетания кнопок и много чего. При этом одни из самых важных свойств, которые мы с вами можем найти это: **type** - тип **события**, который произошел. **target** - тот элемент, на котором произошло **событие**.

```HTML
type: "mouseenter"

target: button\#btn
```

```JavaScript
btn.addEventListener('mouseenter', (e) => { 
    console.log(e);
});
```

![[Untitled 5 15.png|Untitled 5 15.png]]

Прописываем **console.log(e.target)** и уже получаем доступ к этому элементу, ведь теперь мы с этим элементом можем что-то сделать.

```JavaScript
btn.addEventListener('mouseenter', (e) => { 
    console.log(e.target);
});
```

Например, мы можем сделать так, чтобы элемент просто пропадал со страницы при наведении, прописав **e.target.remove()**.

```JavaScript
btn.addEventListener('mouseenter', (e) => { 
    console.log(e.target);
    e.target.remove();
});
```

![[Untitled 6 14.png|Untitled 6 14.png]]

![[Untitled 7 13.png|Untitled 7 13.png]]

Иногда нам нужно удалять **обработчики событий** и для этого есть **метод** **removeEventListener()**. Но тут есть одна загвоздка, нам нужно использовать точной такую же **функцию**, которые мы назначали при помощи этого метода **addEventListener()**, то есть если мы 2 раза напишем **функцию** - это не одна и та же **функция**. Поэтому, чтобы иметь возможность удалить эту **функцию**, нам нужно вынести ее в какую-то отдельную **переменную**.

А здесь **('click', deleteElement)**  **функция** **deleteElement** прописывается без круглых скобок, то есть мы ее не вызываем, мы лишь ссылаемся на эту **функцию**, которая будет выполняться после клика. И напишем некоторе **условие** для более наглядного представления использования данного **метода**.

```JavaScript
const btn = document.querySelector('button');

let i = 0;
const deleteElement = (e) => {
    console.log(e.target);
    i++;
    if (i === 1) {
        btn.removeEventListener('click', deleteElement);
    }
};

btn.addEventListener('click', deleteElement);
```

**Всплытие событий** - это когда **обработчик событий** сначала срабатывает на самом вложенном элементе, затем на родителе и так выше и выше по иерархии.

```HTML
<div class="overlay">
            <button id="btn">Нажми меня</button>
        </div>
```

```JavaScript
const btn = document.querySelector('button'),
      overlay = document.querySelector('.overlay');

const deleteElement = (e) => {
    console.log(e.target);
    console.log(e.type);
};

btn.addEventListener('click', deleteElement);
overlay.addEventListener('click', deleteElement);
```

Мы видим, что **событие** сначала происходит на вложенном элементе **btn**, а затем поднимается наверх по иерархии нашего DOM - дерева и срабатывает на его **родителе** **overlay**.

![[Untitled 8 11.png|Untitled 8 11.png]]

Также в JS Мы можем отменять стандартное поведение браузера: выделение текста, ссылки, копка submit и т д.

В данном коде мы используем **метод preventDefault()** - этот **метод** отменяет **дефолтные методы**, а далее выполняются те действия, которые задал программист, в данном случае **console.log(event.target)**.

```JavaScript
const link = document.querySelector('a');

link.addEventListener('click', function(event) {
    event.preventDefault();
    console.log(event.target);
});
```

Нужно запомнить и не допускать ошибку! Если нам функцию нужно навесить на 3 или более множество элементов, то нужно использовать перебор, **метод** **forEach()**. Также у **addEventListener()** существуют 3 **аргумент** - это **объект**, которому мы можем передать различные **опции**. Например:

**{once: true}** - мы говорим, чтобы **событие** происходило только один раз.

```JavaScript
const btns = document.querySelectorAll('button'),
      overlay = document.querySelector('.overlay');

const deleteElement = (e) => {
    console.log(e.target);
    console.log(e.type);
};
      
btns.forEach(btn => {
    btn.addEventListener('click', deleteElement, {once: true});
});
```

![[Untitled 9 9.png|Untitled 9 9.png]]