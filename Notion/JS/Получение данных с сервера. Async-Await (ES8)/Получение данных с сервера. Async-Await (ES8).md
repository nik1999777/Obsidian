[https://www.youtube.com/watch?v=wPG7RgPzxmM](https://www.youtube.com/watch?v=wPG7RgPzxmM)

Главная задача этого урока получить данные о карточках товара от **сервера** и использовать их на **клиенте**, вместо тех, которые мы в предыдущих уроках просто вручную ввели. Это крайне удобно в реальных продуктах, ведь цены, ассортименты и описания могут меняться администраторами через какую-нибудь **административную панель**, а **клиент** просто отображает актуальные данные, которые в нем присутствуют.

То есть **backend** будет контролироваться какими- то **администраторами**, они будут выставлять ценники, редактировать текста, а наш **клиент**, то есть веб сайт у нас будет отображать только актуальную информацию.

**Административные панели** на сайтах - это уже отдельные технологии, которые используют различные **серверные технологии** **PHP**, **Node.js** и другие.

И позволяют удобно управлять сайтами, они могут быть, как готовые, по типу самой популярной в мире **системой управления сайтами Wordpress**, так и самописные, там где люди просто создают нужный для них функционал.

Не забываем, для того чтобы правильно работать с нашим **сервером**, с нашей **базой данных db.json**, нам необходимо будет помимо **локального** **сервера MAMP**, на котором запущен сайт, использовать еще **json-server**, чтобы мы могли нормально работать с **db.json**

Мы создаем **функцию postData**, которая занимается тем, что настраивает наш **запрос**. Она **фетчит** **fetch()**, то есть посылает этот **запрос** на **сервер**, получает какой-то ответ от **сервера**, что например все успешно **запостилось**, и после этого трансформирует этот ответ в **json**: **res.json()**

И далее мы вызываем эту **функцию** **postData** и передаем 2 **аргумента**:

Первый **аргумент** это [http://localhost:3000/requests](http://localhost:3000/requests) - **url** к файлу **json.db**, который был создан с помощью **json-server**

Второй **аргумент** это **JSON.stringify(object)** - данные, которые приходят от **сервера** и которые будут **поститься**

И нужно не допускать ошибку, помнить об очень важном моменте. О том, что внутри у нас **асинхронный** код, он **асинхронен** и абсолютно не ждет друг друга. **Функция** **postData** создается, **запрос** с помощью **fetch()** пошел, **функция** продолжает свою работу, она создает **переменную res** и в нее может поместится ничего, потому что с **фетча fetch(**) нам еще ничего не вернулось(мы не знаем через какое время это случится), там есть лишь **обещание**, которое обещает что-то нам вернуть. И дальше у нас будет ошибка, потому что это **обещание** мы попытаемся обработать через **res.json()**, а такого **метода** у **Promise** не будет.

Для того чтобы это исправить есть такие **операторы** **async** и **await**. Первый **оператор** ставится перед **функцией**: **const postData = async (url, data)** - таким образом мы говорим, что внутри **функции** у нас будет какой-то **асинхронный код**. А дальше мы используем его парный **оператор await**, причем мы его ставим перед теми операциями, которые нам необходимо дождаться. Эти **операторы** всегда используются в паре.

И теперь, когда мы запускам **функцию postData** у нас начинает идти **запрос**, но за счет того, что стоит **оператор** **await**, **js** видит его и дожидается результата этого **запроса,** и только когда вернется результат, **await** пропустит наш код, и наш **асинхронный** код превратится в **синхронный**.

И также ставим **await** здесь: **return await res.json()** , так как здесь возвращается **Promise**, а эта операция выполняется не сразу, мы не знаем насколько там большой **объект** в формате **json**, и сколько времени понадобится, чтобы перевести его в обычный **объект**.

```JavaScript
const postData = async (url, data) => {
    const res = await fetch(url, {
        method: "Posts",
        headers: {
            'Content-type': 'application/json',
        },
        body: data
    });

    return await res.json();
};
```

```JavaScript
postData('http://localhost:3000/requests', JSON.stringify(object))
.then(data => {
    console.log(data);
});
```

  

  

  

  

Проверяем наш код. Вводим **форму** на сайте. Видим **объект**, который вывелся в консоле. Но самое главное это то что в **db.json** мы увидим, что в **массиве** **requests** у нас появился новый **объект**, это как раз те данные, которые только мы отправили с **клиента**.

Это наш первый **постинг** данных в формате **json** на **json сервер**. Теперь все **запросы**, которые будут делать пользователи, будут оставаться в этой маленькой **базе данных**, и мы их потом в будущем сможем как-то использовать.

```JSON
"requests": [
    {
        "name": 'Nik',
        "phone": "+7 910 984 52 63",
        "id": 1
    }
]
```

![[Untitled 135.png|Untitled 135.png]]

Также существует другой способ перевести из **формата** **formData** в **JSON**. Для этого используются **методы**: **entries** и **fromEntries**

Посмотрим на пример кода (картинка слева), этот **метод** берет каждое **свойство** и формирует из него **массив**, таким образом мы любой **объект** можем превратить в **матрицу** (**массив** **массивов**)

Получается если мы используем **метод** **entries()**, то мы получим данные с **формы** в формате **матрицы**, а потом нам нужно сделать обратную операцию, превратить его в **объект** и делается это с помощью **метода** **fromEntries()**.

```JavaScript
const obj = {a: 20, b: 50};
console.log(Object.entries(obj));
```

```JavaScript
[Running] node "/Users/nikitaelin/Desktop/work/JS_React/react/my-app/src/tempCodeRunnerFile.js"
[ [ 'a', 20 ], [ 'b', 50 ] ]

[Done] exited with code=0 in 0.14 seconds
```

```JavaScript
const json = JSON.stringify(Object.fromEntries(formData.entries()));

postData('http://localhost:3000/requests', json)
```

Теперь нам необходимо получить данные о карточках непосредственно из **menu** из **сервера db.json**

Нам понадобится такая же **функция**, как и **postData**, только для **GET** **запросов**.  Мы создаем **функцию getResource**, **аргумента** **data** уже не будет, потому что мы ничего не будем отправлять на **сервер**, мы будем только получать. И соответсвенно **объекта** с настройками тоже не будет.

Мы просто делаем **запрос**, дожидаемся его окончания и трансформируем данные в **формате json** в обычный обычный **объект**.

И тут есть одна проблема, если **fetch()** столкнется с ошибкой в **http запросе**, то он нам не выдаст **catch()**, это для него не будет ошибкой. И чтобы эту проблему исправить внутри **функции** мы пропишем **условие**:

```JavaScript
if (!res.ok) {
    throw new Error(`Could not fetch ${url}, status: ${res.status}`);
}
```

Дословно - это условие читается: если **!res.ok** - наш **запрос** не окей, с ним что-то не так, то мы выкидываем ошибку.

И здесь мы знакомимся с **объектом ошибки**: **new Error()** - и с помощью него мы конструируем нашу ошибку

**throw** - это **оператор** выкидает нашу ошибку

Такой механизм позволит нам избежать этих ошибок, при этом даже, если мы их получим, то мы еще и в консоль получим **url**  и **status**.

Далее мы вызываем **функцию** **getResource()**, говорим, что мы будем обращаться по определенному url [http://localhost:3000/menu](http://localhost:3000/menu).

Используем **then()** т. к. у нас **Promise**, вызываем **callback функцию** и перебираем **data** (данные с **сервера** в трансформируемом виде) с помощью **метода forEach()**, т. к. у нас данные в **массиве** и внутри вызываем **конструктор** **new Menucard** и **метод** **render()**.

И чтобы передать **аргументы**:

```JavaScript
img, altimg, title, descr, price
```

Мы используем синтаксис **деструктуризации объекта** - это когда мы с **объекта** вытаскиваем отдельные **свойства** в качестве отдельной **переменной**.

Делается это с помощью фигурных скобок, то есть мы вытаскиваем **свойства**:

```JavaScript
{img, altimg, title, descr, price}
```

Теперь у нас получился максимально локаничный код. При помощи **сервера**, **запроса** мы получаем **массив**, который содержит меню - это **массив** с **объектами**. Так как это **массив**, то мы можем перебрать его через **forEach()** и не париться о кол-ва раз, сколько нам нужно создать наш **конструктор**.

И тот **объект**, который находится внутри, мы его **деструктиризируем** по отдельным частям, и эти же части мы передаем во внутрь **конструктора**, который создает новую карточку на странице и сразу ее **рендерит**.

```JavaScript
async function getResource(url) {
    let res = await fetch(url);

    if (!res.ok) {
        throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.json();
}


getResource('http://localhost:3000/menu')
.then(data => {
    data.forEach(({img, altimg, title, descr, price}) => {
        new MenuCard(img, altimg, title, descr, price, ".menu .container").render();
    });
});
```

  

Данный код - это другой способ создания карточки на странице. Здесь мы лишаемся шаблонизации, но если вдруг нам необходимо только один раз что то построить, то можно спокойно применять этот способ.

```JavaScript
getResource('http://localhost:3000/menu')
    .then(data => createCard(data));

function createCard(data) {
    data.forEach(({img, altimg, title, descr, price}) => {
        const element = document.createElement('div');

        element.classList.add("menu__item");

        element.innerHTML = `
            <img src=${img} alt=${altimg}>
            <h3 class="menu__item-subtitle">${title}</h3>
            <div class="menu__item-descr">${descr}</div>
            <div class="menu__item-divider"></div>
            <div class="menu__item-price">
                <div class="menu__item-cost">Цена:</div>
                <div class="menu__item-total"><span>${price}</span> грн/день</div>
            </div>
        `;
        document.querySelector(".menu .container").append(element);
    });
}
```