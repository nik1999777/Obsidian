Что дает нам **defer**? Этот **атрибут** сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать **скрипт** в фоновом режиме, а затем запустить **скрипт**, когда он загрузится.

Важно, что **скрипты с defer** никогда не блокируют страницу, то есть страница начинает загружаться, доходит до **скрипта**, видит атрибут **defer** и говорит браузеру, загружай пожалуйста скрипт в фоновом режиме и дальше начинает строить **DOM структуру**.

И вторая особенность **скриптов** с **defer** это то, что **скрипты** с таким атрибутом всегда выполняются, когда DOM дерево уже готово, то есть такие **скрипты** всегда будут дожидаться полной готовности нашей верстки.

Но при этом они срабатывают до события **DOMContentLoaded**.

```HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script defer src="js/script.js"></script>
    <p>Hello world</p>
    <p>Second message</p>
</body>
</html>
```

```JavaScript
const p = document.querySelectorAll('p');
console.log(p);
```

![[Untitled 117.png|Untitled 117.png]]

Содержимое **скрипта** **test.js** меньше чем **script.js**, по логике **test.js** должен загрузиться быстрее, но за счет того, что стоят **атрибуты** **defer**, они будут загружаться последовательно.

Для чего же нам это нужно и как мы можем это использовать? Мы можем сначала подключить **библиотеку с полезными утилитами**, например **jQuery**, а следующим наш **скрипт**, который использует возможности этой **библиотеке** и зависит от нее, при этом вся наша страница не блокируется, все **скрипты** загружаются параллельно с ней в фоновом режиме. И все это будет загружаться последовательно.

```JavaScript
<script defer src="js/script.js"></script>
<script defer src="js/test.js"></script>
```

![[Untitled 1 54.png|Untitled 1 54.png]]

Второй **атрибут** это **async**. Особенности, которые он дает:

1)  Страница не ждет **асинхронна скриптов**, содержимое просто обрабатывается и отображается. (Понятие **асинхронный скрипт** относится к **методу**, которым этот **скрипт** будет выполняться, что оказывает влияние на скорость загрузки страницы.)

2)  **Событие** **DOMContentLoaded** и **асинхронные скрипты** не ждут друг друга

3)  И получается так, что когда страница загружается и доходит до **скрипта**, то **скрипт** тоже начинает загружаться в фоновом режиме, но при этом запускается, как только он был загружен, он вообще никого не ждет. То есть **скрипты** становятся абсолютно независимыми.

А зачем вообще такое поведение **скриптов** нам необходимо? Дело в том ,что иногда мы будем подключать различные сторонние **скрипты**, которые не особо подвязаны как под **DOM - структуру**, так и под другую какую-то функциональность.  Например: **метрики** и **счетчики**, им главное просто уловить, что пользователь зашел на этот сайт, на эту страницу, а дальше пусть что угодно происходит.

Таким образом, если мы используем **скрипты** с **атрибутом** **async**, мы должны быть точно уверены, что этот **скрипт** абсолютно не зависит от **DOM - структуры**, ему все равно сформировалось она или нет, и кроме этого он должен не зависеть от каких-то других **скриптов**. Он загрузился и сразу выполнился.

  

Также есть еще один способ поместить **скрипт** на страницу - **динамически загружаемые скрипты**. Мы умеем создавать новые элементы на странице с помощью **JS**, так почему бы нам просто не создать тэг **скрипт** и не поместить его туда. И этот **скрипт** будет загружаться только после того, как он будет добавлен в документ, то есть после выполнения этой строчки: **document.body.append(script)**.

```JavaScript
const script = document.createElement('script');
script.src = "js/test.js";
document.body.append(script);
```

![[Untitled 2 41.png|Untitled 2 41.png]]

И у динамически загружаемых скриптов есть одна особенность, по умолчанию они ведут себя, как **async**, то есть они никого ждать не будут, и если мы пропишем **script.async = false**, то наш скрипт будет вести точно также, как и обычный скрипт, помещенный на страницу.

И в данном случае **скрипты**: **test.js** и **some.js** будут выполняться строго друг за другом, потому что мы установили **script.async = false**.

```JavaScript
function loadScript(src) {
    const script = document.createElement('script');
    script.src = src;
    script.async = false;
    document.body.append(script);
}
loadScript("js/test.js");
loadScript("js/some.js");
```

![[Untitled 3 29.png|Untitled 3 29.png]]