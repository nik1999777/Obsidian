[https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes) - документация по **классам**

[http://jsraccoon.ru/es6-classes](http://jsraccoon.ru/es6-classes) - статья по **классам**

  

По простому **классы** это красивая обертка **функции - конструкторов**. А еще есть такое понятие как **синтаксический сахар**. Поэтому **классы** - это все те же **функции**.

Вспомним предназначение такого приема:

У нас чаще всего на сайтах, веб приложениях будет какая - то шаблонизация. И вместо того чтобы каждый раз создавать какой-то слайдер или какую-то статью, полностью описывать все **свойства**, **методы** и тому подобное, мы с вами создаем один шаблон, который говорит вообщем что будет делать этот **компонент**, а потом от этого шаблона уже создаем отдельных экземпляров, отдельных потомков, которые будут помещаться на наш сайт.

Чтобы сконструировать наш **класс** у нас есть такое **свойство**, как **constructor** и в него записываем те **аргументы**, которые будут приходить:

**(height, width)**

Когда мы передали эти **аргументы**, мы должны их записать в **свойства** нового **объекта**, мы же помним, что **классы** точно также, как и **функции**-**конструкторы** служат нам для создания новых **объектов**.  И если внутри мы будем обращаться к **this**, мы будем обращаться к экземпляру нового созданного **объекта**:

**this.height = height;**

**this.width = width;**

И еще мы создаем **метод**:

**calcArea() {**

**return this.height * this.width;**

**}**

И создаем 2 **переменные** и помещаем в них **объекты**, которые создаются с помощью **класса**:

**const square = new Rectangle(10, 10);**

**const long = new Rectangle(20, 100);**

Давайте быстренько вспомним **принципы объектно-ориентированного программирования**:

1)  Первый называется - **абстракция** - когда мы отделяем **концепцию** от ее **экземпляра**. То есть в данном примере у нас есть **концепция** **class** **Rectangle** (небольшой шаблон, по которому мы что-то создаем) и у нас есть **экземпляры** (**переменные** **const square** и **const long)**, которые были созданы на основе нашей **концепции**.

2) Второй важный принцип - это **наследование**,  то есть способность нашего **объекта** или **класса** базироваться на другом **объекте** или **классе** (на самом деле это главный механизм для повторного использования какого-то кода и при этом наследственное отношение классов четко будет определять их иерархию)

```JavaScript
class Rectangle {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }

    calcArea() {
        return this.height * this.width;
    }
}

const square = new Rectangle(10, 10);
const long = new Rectangle(20, 100);

console.log(long.calcArea());
console.log(square.calcArea());
```

![[Untitled 126.png|Untitled 126.png]]

Давайте помимо базового **класса** создадим еще один **class ColoredRectangleWithText**

Допустим мы хотим создать еще какой-то цветной прямоугольник и в нем будет написан какой-то текст.

И мы понимаем, что у нашего нового **класса** **ColoredRectangleWithText** будут точно такие же **свойства** и **метод**, как и у **класса** **Rectangle**. И зачем нам прописывать все заново, если мы можем сделать, чтобы **класс ColoredRectangleWithText** наследовался от **класса Rectangle**. Для этого есть ключевое слово **extends**.

И также у нас есть **метод** **super()** - этот **метод** укорачивает наш код, он вызывает то же самое, что было у родителя, то есть в данном случае эти строчки:

**this.height = height;**

**this.width = width;**

И здесь есть одно правило:  **метод super()** всегда должен быть на первом месте в **constructor()**

И мы внутри метода записываем **свойства**, которые нам нужно использовать, нам не всегда нужны все **свойства**: **super(height, width)**

```JavaScript
class Rectangle {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }

    calcArea() {
        return this.height * this.width;
    }
}

class ColoredRectangleWithText extends Rectangle {
    constructor(height, width, text, bgColor) {
        super(height, width);
        this.text = text;
        this.bgColor = bgColor;
    }

    showMyProps() {
        console.log(`Текст: ${this.text}, цвет: ${this.bgColor}`);
    }
}

const div = new ColoredRectangleWithText(25, 10, 'Hello world', 'red');

div.showMyProps();
console.log(div.calcArea());
```

![[Untitled 1 60.png|Untitled 1 60.png]]