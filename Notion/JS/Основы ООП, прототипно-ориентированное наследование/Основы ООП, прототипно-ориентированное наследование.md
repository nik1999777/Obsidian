[https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/proto](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)  -  **про __proto__**

[https://javascript.info/prototype-methods](https://javascript.info/prototype-methods)  -  **наследование без __proto__**

  

JS как раньше мы упоминали является **объектно-ориентированным** языком и главную роль в нем играет **объект**. Он может в себе содержать **методы**, **свойства**, любой **тип данных** и представлять собой целостную сущность.

Смысл **объектно-ориентированного** программирования заключается в том, что мы представляем любую вещь, как **объект** с набором **свойств** и **методов**.

  

Создадим **переменную** let str = "some", и также создадим еще одну **переменную** let strObj и помещаем туда такой синтаксис, как new String(str) (таким образом мы можем создать новую **строку**, но таким синтаксисом уже никто не пользуется), во внутрь помещается (str), то есть на основании вот этой **строки** "some", мы создаем еще какую-то новую **строку**. Выводим в консоль конструкцию с typeof, запускам код и видим, что мы сначала получаем **строку**, а после этого **объект**. Примерно так происходит, когда мы пытаемся использовать какой-то **метод** на **строке**, то есть он оборачивает **строку** в какой-то **объект**, потом использует какой-то **метод**, который есть у этого **объекта**, а потом возвращает все обратно. Здесь у нас был **примитивный тип данных** "some", а потом в работе он превратился в **объект**  new String(str), и после этого опять вернулся в **примитив**.

```JavaScript
let str = "some";
let strObj = new String(str);

console.log(typeof(str));
console.log(typeof(strObj));
```

Как же работает **объектно-ориентированное** программирование?

Когда мы создаем **строки** или **массивы**, все они могут содержать абсолютно разные наполнения, но каждый из них обладает одними и теми же **методами**, нам ведь совершенно не важно, что находится в **строке**, мы все равно можем использовать **метод toUppercase**. То есть когда мы создаем например **массив**, мы создаем новый экземпляр **прототипов массивов**.

Давайте посмотрим как это выглядит в реальности. Заберемся в сам объект, запишем console.dir([1,2,3]) и в внутри создадим какой-то массив, который будет содержать 1,2,3.

Console.dir это способ посмотреть в консоли свойства заданного javascript объекта.

```JavaScript
console.dir([1, 2, 3]);
```

Запускаем код, заходим в консоль в браузере и видим **Array**, в котором 3 элемента. Раскрываем его и мы с вами понимаем, что создали какой-то экземпляр **массива**, но **прототип Array**, который дает нам возможность создавать такие структуры, он находится в **свойстве __proto__: Array(0)**. И мы можем также его раскрыть и, раскрыв его мы можем увидеть все **методы**, которые могут применяться к **массивам**. Нужно заметить, что в конце мы опять обнаружим **свойство __proto__: Object**, которое ссылается на **объект**.

![[Untitled 107.png|Untitled 107.png]]

![[Untitled 1 46.png|Untitled 1 46.png]]

![[Untitled 2 33.png|Untitled 2 33.png]]

![[Untitled 3 21.png|Untitled 3 21.png]]

Посмотрим на левую ветку, только что мы с вами создали к примеру **массив**

![[Untitled 4 14.png|Untitled 4 14.png]]

дальше мы видим **свойство**

![[Untitled 5 11.png|Untitled 5 11.png]]

и видим, что у нас есть большой прототип:

![[Untitled 6 10.png|Untitled 6 10.png]]

который называется **массивом**. Этот большой прототип содержит **методы**, которые мы можем использовать на каждом из экземпляров. Дальше мы опять идем по цепочки

![[Untitled 5 11.png|Untitled 5 11.png]]

и с вами переходим к **объекту**

![[Untitled 7 9.png|Untitled 7 9.png]]

и опять же убеждаемся, что **объект** это самая главная структура.

И вот те **методы**, которых нет например в **массиве**, но они все равно где-то берутся у экземпляров **массивов**, они на самом деле приходят из **объекта**. **Так что любые конструкции прототипно наследуются от объекта!**

Такую же цепочку мы с вами видим и в браузере.

В реальных проектах, программах мы также будем создавать **объекты**, которые будут **прототипно наследоваться друг от друга**, то есть такая структура будет формироваться лично нами. И это мы будем очень часто делать особенно в **библиотеке React**.

  

Давайте создадим **переменную** const soldier, которая будет являться **объектом** и запишем некоторые **свойства.**

Этот солдат у нас будет как бы большой **прототип**, который описывает всех солдат, что у них есть определенное количество здоровья и брони.

Теперь создадим конкретного рядового, например его будут звать const john  и у нас john будет слаб здоровьем и у нас такое **свойство** как health будет равно 100  health: 100.

И необходимо установить связь, чтобы у john **свойства** были такие же, что и soldier, но некоторые в зависимости от его специфики были модифицированы, например health. Сделать это можно несколькими способами.

Начнем с устаревшего формата. Это как раз то **свойство __proto__**, запишем вот так john.__proto__ = soldier  - дословно это значит, что мы с вами установили **прототипом** джона - солдата. И если мы с вами в консоль выведем джона

console.log(john), то мы с вами видим, что пока что у джона есть только health (картинка слева), но если мы сейчас укажем вот такую структуру  console.log(john.armor), запускаем и мы с вами видим 100. (То есть несмотря на то что у объекта john только одно **свойство**, благодаря **прототипом**, которые мы указали, он также получил и вот это **свойство** armor: 100, которое было у его **прототипа**.

Вот такая взаимосвязь нам очень сильно помогает в реальных проектах, когда мы можем создать один большой **прототип**, например модального окна, который изначально по умолчанию содержит определенные **свойства** и от этого **прототипа** в будущем можем создавать много разных модальных окон, которые будут немного отличаться, например по ширине, по высоте.

```JavaScript
const soldier = {
    health: 400,
    armor: 100
};

const john = {
    health: 100
};

john.__proto__ = soldier;

console.log(john);
```

```JavaScript
const soldier = {
    health: 400,
    armor: 100
};

const john = {
    health: 100
};

john.__proto__ = soldier;

console.log(john.armor);
```

Если внутри const soldier пропишем вот этот **метод**:

```JavaScript
sayHello: function() {
        console.log("Hello");
}
```

То оно также появится и у john. Прописываем john.sayHello(), запускаем код и получаем фразу Hello, потому что john умеет это делать. Он взял из своего **прототипа** данный **метод** и использует его по своему назначению.

Но сейчас **__proto__**  -  deprecated(устарел)  не нужно его использовать.

```JavaScript
const soldier = {
    health: 400,
    armor: 100,
    sayHello: function() {
        console.log("Hello");
    }
};

const john = {
    health: 100
};

john.__proto__ = soldier;

john.sayHello();
```

Если мы пропишем **Object.setPrototyoeOf(john, soldier)** и внутри скобок первым **аргументом** напишем тот **объект**, которому мы хотим назначить **прототип**, а вторым **аргументом** пишем тот **объект**, **прототипом** которого мы устанавливаем. И эта запись будет идентична предыдущей. Теперь мы сделали по правильному, по современному, мы установили прототип для **john** от **soldier**

```JavaScript
const soldier = {
    health: 400,
    armor: 100,
    sayHello: function() {
        console.log("Hello");
    }
};

const john = {
    health: 100
};

Object.setPrototypeOf(john, soldier);

john.sayHello();
```

Здесь мы прописываем **const john = Object.create(soldier)** и это команда читается так: мы создаем новый объект **john**, который будет прототипно наследоваться от **soldier**.

```JavaScript
const soldier = {
    health: 400,
    armor: 100,
    sayHello: function() {
        console.log("Hello");
    }
};

const john = Object.create(soldier);

john.sayHello();
```

Итоги: ООП - это наука о том, как делать правильную архитектуру. JS можно назвать прототипно-ориентированным языком - это частный случай ООП. И мы впринцепи увидели, что в JS все строится на прототипах.