[https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/try...catch](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/try...catch) - **try/catch**

  

**Ошибки** могут положить весь **скрипт**. Поэтому для того, чтобы обрабатывать **ошибки** и делать так, чтобы наш скрипт не падал существует конструкция **try catch**

Запускам данный код и у нас выводится сообщение **Normal**. Как же работает данная конструкция? Наш **скрипт** берет код, который находится внутри **try**, он пытается его выполнить и если все проходит без ошибок, то участок кода **catch** игнорируется, наш код продолжает работать и дальше выполнять определенные команды.

Но если вдруг внутри **try** произошла какая-то ошибка, ты мы переместимся в блок кода **catch** и он будет выполнятся. Но самое главное, что после данной конструкции наш код продолжит дальше работать, наш скрипт не поломается. (картинка справа)

```JavaScript
try {
    console.log('Normal');
} catch(e) {
    console.log('error');
}
```

```JavaScript
[Running] node "/Users/nikitaelin/Desktop/work/JS_React/react/my-app/src/tempCodeRunnerFile.js"
Normal

[Done] exited with code=0 in 0.124 seconds
```

```JavaScript
try {
    console.log('Normal');
    console.log(a);
    console.log('result');
} catch(e) {
    console.log('error');
}

console.log('Still noraml');
```

```JavaScript
[Running] node "/Users/nikitaelin/Desktop/work/JS_React/react/my-app/src/tempCodeRunnerFile.js"
Normal
error
Still noraml

[Done] exited with code=0 in 0.128 seconds
```

В наш блок **catch** приходит также **объект ошибки** **error**. И давайте посмотрим, что находится внутри этого **объекта**. В консоль мы получаем **ReferenceError: a is not defined** - это как раз та **ошибка**, которую мы получили.

Если вдруг нам понадобятся отдельные части **ошибки**, то мы можем обратиться к **name**, **message** и **stack** нашей **ошибки**. И в **консоль** мы с вами получаем отедльно: название, сообщение и стэк нашей ошибки(картинка справа)

```JavaScript
try {
    console.log('Normal');
    console.log(a);
    console.log('result');
} catch(error) {
    console.log('error');
}

console.log('Still noraml');
```

![[Untitled 148.png|Untitled 148.png]]

```JavaScript
try {
    console.log('Normal');
    console.log(a);
    console.log('result');
} catch(error) {
    console.log(error.name);
    console.log(error.message);
    console.log(error.stack);
}

console.log('Still noraml');
```

![[Untitled 1 74.png|Untitled 1 74.png]]

Еще мы можем использовать **finally**, и она работает точно также как и у **promise**. И этот блок выполнится абсолютно всегда, при любом раскладе события.

```JavaScript
try {
    console.log('Normal');
    console.log(a);
    console.log('result');
} catch(error) {
    console.log(error.name);
    console.log(error.message);
    console.log(error.stack);
} finally {
    
}

console.log('Still noraml');
```

Приведем пример, как мы это можем использовать допустим у нас есть 2 **html** файла: **index.html** и **contacts.html**

В одном будет кнопка, а в другом нет, но путь к **скрипту** у обоих страничек будет один и тот же.

И по **консоле** мы видим, что в **index.html** все нормально, но так как этот же скрипт применяется на странице contacts.html, то мы в консоль получаем ошибку, потому что на странице **contacts.html** такого элемента просто не существует.

![[Untitled 2 53.png|Untitled 2 53.png]]

![[Untitled 3 39.png|Untitled 3 39.png]]

![[Untitled 4 29.png|Untitled 4 29.png]]

Но а если мы добавим конструкцию **try catch**, мы видим, что в консоле на странице **contacts.html contacts.html** мы получили **ошибку**, она произошла, но весь **скрипт** у нас не упал, код который идет дальше - сработал.

![[Untitled 5 23.png|Untitled 5 23.png]]

![[Untitled 6 22.png|Untitled 6 22.png]]