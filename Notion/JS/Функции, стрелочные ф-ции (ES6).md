[https://medium.com/nuances-of-programming/%D1%8F-%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F-3c3f02041970](https://medium.com/nuances-of-programming/%D1%8F-%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F-3c3f02041970) - очень подробно про **замыкания**

[https://learn.javascript.ru/closures](https://learn.javascript.ru/closures) - **замыкания** изнутри

[https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions) - **стрелочные функции**

  

**Функции** это наши действия в JS, они используют различные **типы данных** и изменяют информацию так, как мы ей укажем. Также **функции** значительно сокращают наш код, прям как **циклы**.

Рассмотрим синтаксис, сначала прописываем ключевое слово **function**, после этого у нас идет имя нашей будущей **функции**, например showFirstMessage, дальше обязательно ставим круглые скобки и раскрываем фигурные скобки, в круглые скобки мы будем передавать **аргументы функций**. Внутри фигурных скобках, как обычно, у нас выполняются какие-то действия console.log("Hello World"). И самое главное, когда мы эту функцию создали, потом ее использовать, для того чтобы она заработала нам необходимо ее вызвать showFirstMessage();

Одно из главных вещей **функции** это ее имя showFirstMessage, существует негласное правило, что оно должно быть глаголом с припиской того над чем выполняются действие. Иногда можно встретить **функции анонимные** (без имени), они используются прямо здесь и сейчас только один раз.

```JavaScript
function showFirstMessage() {
    console.log("Hello World");
}

showFirstMessage();
```

В данном случае, когда **функция** запустится, она возьмет строку, которую мы ей передали showFirstMessage("Hello World");, подставит ее вместо вот этого **аргумента** showFirstMessage(text) и потом засунет в команду console.log(text); , результат будет точно таким же, как и выше на картинки.

```JavaScript
function showFirstMessage(text) {
    console.log(text);
}

showFirstMessage("Hello World");
```

Как ведут себя **переменные** внутри **функции**? Создадим **переменную** внутри **функции** let num = 20; и после того как **функция** вызвана, пробуем достать эту **переменную** с помощью команды console.log(num);, запускаем код и видим ошибку. Дело в том, что если мы объявляем **переменную** внутри **функции**, то снаружи она уже недоступна. **Переменные** созданные при помощи let и const существуют только внутри блока **функции**, и на картинке ниже это так и работает. Когда **переменная** создана внутри **функции**, она называется **локальной переменной**, потому что она существует только **локально** внутри **функции**, понятно что внутри мы можем как-то с ней взаимодействовать, но только внутри, потому что она существует только внутри **функции**.

```JavaScript
function showFirstMessage(text) {
    console.log(text);
    let num = 20;
}

showFirstMessage("Hello World");
console.log(num);
```

Теперь попробуем создать **глобальную переменную** let num = 20; и внутри **функции** мы используем ее num = 20, мы ее не объявляем, мы просто перезаписываем ее значение, например на 10. Это значит, что любая **функция** может спокойно брать и использовать **глобальную переменную** внутри себя. Запускаем код и получаем уже 10, потому что внутри **функции**, когда она выполнилась у нас было изменено значение num на 10 let num = 10

```JavaScript
let num = 20;

function showFirstMessage(text) {
    console.log(text);
    num = 20;
}

showFirstMessage("Hello World");
console.log(num);
```

Если внутри **функции** напишем let, то мы получаем 2 копии **переменных**, которые находятся в разных местах и никакой ошибки у нас нет, потому что наша команда **console.log(num);** обращается к **глобальной переменной**, она совершенно ничего не знает о **локальной переменной** let num  = 10, которая объявлена и существует только внутри **функции**.

Поэтому всегда нужно обращать внимание как заданы **переменные**, где они используются и где они вообще объявлены.

```JavaScript
let num = 20;

function showFirstMessage(text) {
    console.log(text);
    let num = 10;
}

showFirstMessage("Hello World");
console.log(num);
```

Очень часто на собеседованиях могут спросить что такое **замыкание функций**? Например, если внутри какой-то **функции** есть обращение к **переменной** console.log(num) и мы уже понимаем, что в коде на картинки слева выведется 2 числа 20 и 10, и **функция** showFirstMessage("Hello World"), когда она запускается, она идет шаг за шагом:  showFirstMessage(text)  сначала создает **аргумент** со значением text  , дальше выводит в консоль этот **аргумент** console.log(text), дальше она создает внутри себя **переменную** let num  = 10, а дальше идет обращение к названию этой **переменной** и данная функция сначала эту **переменную** ищет внутри себя, то есть она сканирует полностью код, натыкается на **переменную** let num  = 10 и уже использует свою **локальную переменную**.

Если же просто удалить строку let num  = 10, то поведение немного поменяется (код на рисунке справа), когда дойдет очередь до это команды console.log(num), она начнет сканировать **функцию** и внутри себя не найдет **переменную**  let num  = 10 , в таком случае эта **функция** начнет искать на уровень выше, начиная с первой строки, наткнется на **переменную** let num  = 20 и тогда уже использует **глобальную переменную**. По простому **замыкание функций** это сама **функция** вместе со всеми внешними **переменными**, которые ей доступны.

```JavaScript
let num = 20;

function showFirstMessage(text) {
    console.log(text);
    let num = 10;
    console.log(num);
}

showFirstMessage("Hello World");
console.log(num);
```

```JavaScript
let num = 20;

function showFirstMessage(text) {
    console.log(text);
    console.log(num);
}

showFirstMessage("Hello World");
console.log(num);
```

  

  

Кроме всех действий **функция** также нам может вернуть какое-либо значение при помощи ключевого слова return, как только **функция** увидит return, она прекратит свое действие. Создаем **функцию** с названием calc  и 2 **аргументами** function calc(a, b) и внутри **функции** пропишем return (a + b) , по простому это значит, что когда запустится **функция**, она нам вернет сумму 1 и 2 **аргумента**. И вот эта маленькая **функция** решает за нас очень многие проблемы, потому что мы ее теперь можем переиспользовать очень много раз.

Напишем **функцию** calc, помещаем внутри console.log ,чтобы сразу увидеть результат и записываем числа. Запускаем код и получаем значения 7 11 16, то есть каждый раз нам возвращается сумма от 2-х **аргументов**. Возвращаясь к ключевому слову return, оно позволяет вам вот это (a + b) (значение, сумму) вернуть во внешний мир.

После return мы ничего не задаем, потому что код будет мертвым, он никогда не выполнится.

```JavaScript
function calc(a, b) {
    return (a + b);
}

console.log(calc(4, 3));
console.log(calc(5, 6));
console.log(calc(10, 6));
```

У return есть еще одно применение, не только окончание **функции**, но и возвращение значения наружу. То есть во внешний мир наша **функция** возвращает значение своей **локальной переменной.** Запустив код, мы с вами получаем 50, потому что 50 вышла наружу и теперь она хранится в этой переменной const anotherNum = ret(); и мы просто выводим ее наружу console.log(anotherNum);

```JavaScript
function ret() {
    let num = 50;
    return num;
}

const anotherNum = ret();
console.log(anotherNum);
```

  

**Классификация функций:**

**1.Function declaration** - это **функция**, которую мы уже использовали. И у нее есть одна важная особенность: она существует еще до того, как наш код запустится. Работает это так: наша **html** страничка загружается, у нее все идет по порядку, потом доходит до скрипта и скрипт начинает загружаться. Первым делом браузер пробегается по скрипту и находит все **переменные var** (если они вдруг там есть), и все **Function declaration** (то есть такие записи **функций**). Браузер их создает, объявляет, и после этого наш код начинает выполняться, опять идет все по порядку.

Преимущества этого способа, что **функция** работает до того, как она еще была вызвана, и поэтому иногда разработчики применяют такой прием, что все **функции** помещает вниз страницы, а сверху просто используют.

**2.Function expression** - здесь синтаксис другой: мы сначала должны создать **переменную** и во внутрь поместить какую то **функцию**. И особенность такова, что **функция** создается только тогда, когда до нее доходит код. Эту **функцию** вниз кода поместить не получится.

```JavaScript
const logger = function() {
    console.log("Hello");
}

logger();
```

**3.Стрелочная функция - современный стандарт (ES6)**

```JavaScript
const calc = a => a + b;

const calc = (a, b) => a + b;

const calc = (a, b) => {return a + b};

const calc = (a, b) => {
    console.log('1');
    return a + b;
};
```