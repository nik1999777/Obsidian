[https://regex101.com/](https://regex101.com/) - **конструктор регулярных выражений**

[https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp) - Документация **RegExp**

[https://learn.javascript.ru/regular-expressions](https://learn.javascript.ru/regular-expressions) - **регулярные выражения**

  

Данная технология позволяет очень удобно работать со **строками**:  удалять, заменять части слов, искать какие-то кусочки **строк**, ограничивать ввод определенных знаков и многое другое.

Если говорить в целом **регулярные выражения** используется и в других языках программирования, в других технологиях и тому подобное. Но знать хотя бы основы данной технологии нам необходимо.

Любое регулярное выражение состоит из двух частей:  **паттерн** и **флаги**

**Паттерн** - это по другому шаблон, то есть шаблон того, что мы ищем в этой строке или то, что мы пытаемся удалить и тому подобное, то есть как то мы ограничиваем определенный список символов, либо их порядок.

  

В JS, чтобы создать **регулярное выражение**, мы можем пользоваться двумя синтаксисами. Первый вариант(при помощи конструктора) почти не используется, используется второй вариант.

```JavaScript
new RegExp('pattern', 'flags');
 /pattern/f
```

В регулярных выражениях мы прописываем флаги:

(также **флаги** можно комбинировать)

```JavaScript
i - этот значит, что мы хотим что-то найти вне зависимоти от регистра 
g - этот флаг мы ставим, когда пытаемся найти несколько вхождений
m - и также этот флаг, который включает многострочный режим, ведь строки у нас могут быть и с переносами
```

Рассмотрим, как работает **метод** **seacrh()** с **регулярным выражением**. В данном коде мы хотим найти все буквы **n** в **prompt()**. Для этого мы создаем **регулярное выражени**е и в центре ставим **паттерн** - шаблон того, что мы ищем - это маленькая буква **n**. И чтобы увидеть результат, выведем его в **консоль**. Далее на странице вводим имя **Ann** и получаем **1**, то есть первая буква **n** находится на первой позиции(нумерация начинается с 0). Если мы введем какую то **строку**, где не будет **n**, то мы с вами получим **-1**.

У **метода** **seacrh() флаг** **g**  работать не будет, этот **метод** довольно таки простой и он всегда ищет только первые совпадения, поэтому **флаг** **g** здесь смысла абсолютно нет ставить.

```JavaScript
const ans = prompt('Введите ваше имя');

const reg = /n/;

console.log(ans.search(reg));
```

![[Untitled 141.png|Untitled 141.png]]

![[Untitled 1 69.png|Untitled 1 69.png]]

![[Untitled 2 51.png|Untitled 2 51.png]]

![[Untitled 3 37.png|Untitled 3 37.png]]

Теперь рассмотрим **метод match()**. Заметьте, все **методы**, которые мы будем рассматривать относятся к **строкам**.

Вводим опять имя и в консоле видим немного другой результат. Мы получаем **массив**, в котором есть тот кусочек **строки**, который мы искали, потом **индекс**, на котором он был найден и непосредственно та **строка**, в которой производился поиск.

```JavaScript
const ans = prompt('Введите ваше имя');

const reg = /n/i;

console.log(ans.match(reg));
```

![[Untitled 4 27.png|Untitled 4 27.png]]

Если мы введем в **prompt()** капсом **'ANNN'** и в коде добавим **флаг** **g**, то у нас срабатывает **флаг** **глобальности**, и в консоле выводятся в виде **массива** все буквы **'N'**

```JavaScript
const ans = prompt('Введите ваше имя');

const reg = /n/ig;

console.log(ans.match(reg));
```

![[Untitled 5 21.png|Untitled 5 21.png]]

![[Untitled 6 20.png|Untitled 6 20.png]]

**Метод** **replace()** позволяет взять какой-то кусочек **строки** и заменить его на другое выражение. В данном **методе** мы можем поместить 2 **аргумента**, первый - это что мы заменяем, второе - это то на что мы заменяем. Соответсвенно в первую часть мы можем поместить **регулярное выражение**, это не обязательно делать в отдельную **переменную**. Мы ставим точку в **паттерн** **регулярного выражения** - это значит, что мы берем все элементы, которые попадут в **строку**. И еще ставим **флаг глобальности**, чтобы взять точно все символы. Мы вводим какой-то текст и он в консоле превратился в звездочки.

```JavaScript
const pass = prompt('Password');

console.log(pass.replace(/./g, "*"));
```

![[Untitled 7 18.png|Untitled 7 18.png]]

![[Untitled 8 15.png|Untitled 8 15.png]]

Чтобы взять отдельную точку, которая тоже может попасть в **строку**. Для этого нужно **экранировать** этот символ, поставить обратный слэш \

Вводим какой-то текст с точками и видим в консоле, что в звездочки превратились только символы - точки.

```JavaScript
const pass = prompt('Password');

console.log(pass.replace(/\./g, "*"));
```

```JavaScript
const pass = prompt('Password');

console.log(pass.replace(/\./g, "*"));
```

![[Untitled 9 13.png|Untitled 9 13.png]]

Здесь мы с помощью **метода replace()** и **регулярного выражения** заменяем дефисы на двоеточия.

```JavaScript
console.log('12-34-56'.replace(/-/g, ':'));
```

![[Untitled 10 9.png|Untitled 10 9.png]]

Также у **регулярного выражения** есть и свои **методы**, например **test()**. Этот **метод** проверяет, а есть ли в строке, непосредственно что-то похожее на **паттерн**, который внутри **регулярного выражения**. Данный **метод** возвращает нам, либо **true**, либо **false**.

```JavaScript
const ans = prompt('Введите ваше имя');

const reg = /n/ig;

console.log(reg.test(ans));
```

![[Untitled 11 7.png|Untitled 11 7.png]]

![[Untitled 12 6.png|Untitled 12 6.png]]

В **регулярных выражения** есть такие понятия, как **классы**.

```JavaScript
\d - этот класс означает, что мы ищем цифры
\w - это значит, что мы ищем все слова, буквы
\s - мы ищем все пробелы
```

Здесь мы используем **класс \d**. Мы вводим какой-то текст с цифрами. И в консоле были найдены только цифры при помощи **метода** **match()**.

```JavaScript
const ans = prompt('Введите ваше имя');

const reg = /\d/;

console.log(ans.match(reg));
```

![[Untitled 13 6.png|Untitled 13 6.png]]

![[Untitled 14 5.png|Untitled 14 5.png]]

В данном коде мы добавляем **флаг глобальности**. Вводим **200px** и получаем все цифры в консоле в виде **массива**.

```JavaScript
const ans = prompt('Введите ваше имя');

const reg = /\d/g;

console.log(ans.match(reg));
```

![[Untitled 15 4.png|Untitled 15 4.png]]

![[Untitled 16 4.png|Untitled 16 4.png]]

Также мы можем использовать такую конструкцию из **классов**: что сначала нам нужна буква, потом цифра, опять буква и цифра. И в итоге в консоле вывелась эта **строчка** **R2D2**.

```JavaScript
const str = 'My name is R2D2'

console.log(str.match(/\w\d\w\d/i));
```

![[Untitled 17 3.png|Untitled 17 3.png]]

У **регулярных выражений** существуют также **обратные классы**. Иногда нам нужно найти наоборот, не числа, не буквы и не пробелы.

```JavaScript
\D - это значит мы ищем не цифры 
\W - это значит мы ищем не буквы
```

В данном коде мы используем **обратный класс \W** и получаем все пробелы. А если **используем \D**, то получаем все символы без цифр.

```JavaScript
const str = 'My name is R2D2'

console.log(str.match(/\W/ig));
```

```JavaScript
const str = 'My name is R2D2'

console.log(str.match(/\D/ig));
```

![[Untitled 18 3.png|Untitled 18 3.png]]

![[Untitled 19 3.png|Untitled 19 3.png]]

В нашем коде **Food_dist** мы заменяем этот код, который говорил, что мы вырезаем у **строчки** 2 последних символа, начиная с нулевого индекса.

```JavaScript
+width.slice(0, width.length - 2)
```

На этот. Мы создали **функцию**. Внутри которого будет **регулярное выражения**, в котором говорится, что мы будем брать все не числа и заменять на пустую строку, то есть они удалятся.

```JavaScript
function deleteNotDigits(str) {
        return +str.replace(/\D/g, '');
}
```

```JavaScript
next.addEventListener('click', () => {
    if (offset == (deleteNotDigits(width) * (slides.length - 1))) {
        offset = 0;
    } else {
        offset += deleteNotDigits(width); 
    }
```