- Какое будет выведено значение: let x = 5; alert( x++ ); ?
- Чему равно такое выражение: + false - null + true ?
- Что выведет этот код: let y = 1; let x = y = 2; alert(x); ?
- Чему равна сумма + 1 + 2?
- Что выведет этот код: alert( "1"[0] )?
- Чему равно 2 && 1 && null && 0 && undefined ?
- Есть ли разница между выражениями? !!( a && b ) и (a && b)?
- Что выведет этот код: alert( null || 2 && 3 || 4 ); ?
- a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b ?
- Что выведет этот код: alert( +"Infinity" ); ?
- Верно ли сравнение: "Ёжик" > "яблоко"?
- Чему равно 0 || "" || 2 || undefined || true || falsе ?

  

**1)**

В **операторах** **инкремента** и **декремента** нужно уделить внимание форме записи.

Вот такая **постфиксная** форма **x++** увеличивает нашу **переменную** на единичку, но перед тем как это сделать она нам возвращает сначала исходное значение. (То есть в данном случае сначала возвращает 5, а после увеличивает ее на единичку).

**Префиксная** форма сразу возвращает нам результат.

```JavaScript
let x = 5; alert( x++ );
let x = 5; alert( ++x );
```

![[Untitled 109.png|Untitled 109.png]]

![[Untitled 1 48.png|Untitled 1 48.png]]

**2)**

Если мы пустой **массив** сложим с **булиновым** значением **false**, то в консоле увидим, что получится **строка** **(string)**. И нужно запомнить, что когда мы работаем с пустым **массивом** в такой операции **console.log(typeof([] + false))** , **массив** будет приведен к **строковому типу данных** (а мы помним, что  при **конкатенации** **строки** с другим **типом данных** все равно получается **строка**.

И дальше если мы из **строки** вычтем тип **данных** **null** и прибавим **true**, то получаем  **NaN**. (**NaN** - это специальное значение, которое получается при выполнении не математических операций.)

```JavaScript
// [] + false - null + true
console.log(typeof([] + false));
console.log([] + false - null + true);
```

![[Untitled 2 35.png|Untitled 2 35.png]]

![[Untitled 3 23.png|Untitled 3 23.png]]

**3)**

Здесь все просто, **число** у нас является **примитивным типом данных** и оно просто передается по значению. Цепочка идет справа на лево **let x = y = 2** , сначала мы присваиваем **переменной y** значение 2 , а после этого мы данное значение, которое лежит в **переменной y** уже присваиваем **переменной** **x**. И таким образом, запустив код, мы получаем 2.

```JavaScript
let y = 1; 
let x = y = 2; 
alert(x);
```

![[Untitled 4 16.png|Untitled 4 16.png]]

**4)**

Здесь также сложив любой **тип данных** (в данном случаем число) с пустым **массивом** получаем **строчный элемент**.

```JavaScript
console.log([] + 1 + 2); // "12"
```

**5)**

Мы вспоминаем, что к каждому элементу **строки** можно обратиться по его **индексу** (то есть к каждому символу **строки**). В нашем коде **строка** - очень простая, она состоит лишь из одного символа "1" и соответсвенно ее символ под номером 0 будет 1, ну и запустив код мы увидим 1.

```JavaScript
alert( "1"[0]);
```

![[Untitled 5 13.png|Untitled 5 13.png]]

**6)**

Запустив такой код, мы получим в консоле значение **null**. То есть в данном коде **оператор** **И &&** запинается об ложное значение **null**, а **null** как и другие: **0**, '', **undefined**, **NaN** - являются по **булиновому** значению - ложными. А оператор  **ИЛИ ||** запинается об правду.

```JavaScript
console.log(2 && 1 && null && 0 && undefined);
```

![[Untitled 6 12.png|Untitled 6 12.png]]

**7)**

Сравниваем 2 выражения и получаем **false**. Получается, что эти 2 выражения не равны друг другу. И здесь нужно вспомнить, что 2 знака !! (2 знака не) , превращает выражение в **булиновое**, и понятное дело, что **булиновое** значение не будет равняться значению, которое вернется нам из этих круглых скобок.

![[Untitled 7 11.png|Untitled 7 11.png]]

**8)**

Когда мы не уверены какой из **операторов** сработает первым, необходимо всегда смотреть:

**таблицу приоритетов операторов** - [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

По таблице мы увидели, что **логический оператор** **И &&** будет выполняться первее, чем **ИЛИ ||** .

Поэтому сначала смотрим на это выражение  **2 && 3** , если у нас оба **аргумента** при логическом сравнении равны, то у нас **оператор** **И &&** будет возвращать последнее значение (то есть результатом будет 3).

Дальше идет часть, где мы **null** с помощью **логического оператора ИЛИ ||** сравниваем с 3, и здесь мы и вспоминаем, что у нас **ИЛИ ||** запинается на **правде** и в результате нам вернется опять 3.

И дальше в последней части 3 сравнивается с  4 **( 3 || 4 )** , **ИЛИ ||** запинается на **правде** и в результате мы с вами получаем 3.

```JavaScript
alert( null || 2 && 3 || 4 );
```

![[Untitled 8 10.png|Untitled 8 10.png]]

**9)**

В данном коде **a** не будет равно **b**, потому что это 2 различных хранилища информации, которые просто содержат одинаковые данные.

```JavaScript
const a = [1, 2, 3];
const b = [1, 2, 3];
console.log(a == b);
```

![[Untitled 9 8.png|Untitled 9 8.png]]

**10)**

В данном коде на экран будет выводиться **Infinity**, но нужно заметить, что **Infinity** из **строчного типа данных** превратиться в **числовой тип данных**, за счет **унарного плюса**.

```JavaScript
alert( +"Infinity" );
```

![[Untitled 10 6.png|Untitled 10 6.png]]

**11)**

**Строки** на самом деле сравниваются и это происходит за счет посимвольного сравнения. Но если попадается такая задачка, нужно открыть таблицу с символами Unicode.

```JavaScript
console.log("Ёжик" > "яблоко");
```

**12)**

Результатом работы этого кода будет 2.  **ИЛИ** запинается об правду, а конкретно об двойку, а дальше код просто не пойдет.

```JavaScript
console.log(0 || "" || 2 || undefined || true || falsе );
```

![[Untitled 11 5.png|Untitled 11 5.png]]