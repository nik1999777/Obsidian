[https://tproger.ru/translations/javascript-this-keyword/](https://tproger.ru/translations/javascript-this-keyword/) - большой гайд про **this**

  

Если говорить по простому, то это то что окружает **функцию** и в каких условиях она вызывается.

Чтобы представить что такое **контекст вызова this**, давайте обратимся к реальному примеру.

Представьте человека без определенного места жительства, в таком случае получается, что этот человек функционирует в пределах всего мира, у него нет какой-то конкретной привязки к определенному месту жительства. Но если мы поместим его в специальное учреждение, где он сможет жить и чем то заниматься, то он уже получит так называемый **контекст вызова**, теперь у него есть свое место для функционирования. **Функции** в JS ведут себя точно также и в течении всех примеров постарайтесь представлять себе такую картину.

  

**Функция** может вызываться 4 способами и в каждом **контекст вызова** отличается:

**1)** Первый способ - это просто вызов нашей **функции**:

**this** будет везти себя по разному, в зависимости установлен ли у нас **строгий режим 'use strict'**

Обычная **функция**: **this = window**, но если **use strict - undefined!**

```JavaScript
function showThis() {
    console.log(this);
}

showThis();
```

![[Untitled 125.png|Untitled 125.png]]

Создадим внутри **функции function showThis()** другую **функцию function sum()** и эта **функция** должна будет возвращать сумму двух **аргументов**:

**return a + b**

Эти **аргументы** будут передаваться в **функцию** **showThis(a, b)**

В таких задачках частенько прописывают вот таким образом: **return this.a + this.b** с использованием **контекста**

Чтобы посмотреть как это все работает внутри **функции** **sum()** прописываем **console.log(this)**

Ну в конце эту **функцию** вызываем в консоле: **console.log(sum())**

Вызываем **функцию** **showThis(4, 5)** и передаем **аргументы** **4** и **5**.

И тут 2 главных вопроса, какой **контекст вызова** у **нашей функции sum()** и будет ли работать **return this.a + this.b** с использованием **контекста вызова?**:

- **console.log(this)** будет точно также равен **undefined**, потому что не важно, где **функция** запускается, самое главное что у нее **контекст вызова,** точно также будет либо **window**, либо **undefined**, все зависит от **режима**.
- И чтобы **return** заработала нам достаточно использовать **замыкания функции**, **this** убираем. Да **аргументов** **a** и **b** в **функции** **sum()** - нет, но за счет того, что у нас **замыкание функции**, мы когда запускаем **sum()**, она сначала ищет эти **аргументы** внутри себя, не находит, и обращается уже к **родительской функции showThis(a, b)**.

```JavaScript
function showThis(a, b) {
    console.log(this);
    function sum() {
        console.log(this);
        return this.a + this.b;
    }
    console.log(sum());
}
showThis(4, 5);
```

![[Untitled 1 59.png|Untitled 1 59.png]]

```JavaScript
function showThis(a, b) {
    console.log(this);
    function sum() {
        console.log(this);
        return a + b;
    }
    console.log(sum());
}
showThis(4, 5);
```

![[Untitled 2 46.png|Untitled 2 46.png]]

**2)** Второй способ - через **метод**

Внутри **объекта** мы записываем **метод** **sum** и смотрим какой **контекст вызова** будет у этой **функции**. И в консоле получаем с вами тот **объект**, в котором находится этот **метод**. И это главный постулат нашего второго пункта:

Если мы используем **метод** внутри **объекта**, то **контекст вызова** всегда будет ссылаться на **объект**, в котором лежит этот **метод**.

Значит **контекст** у **методов объекта** - это сам **объект!**

```JavaScript
const obj = {
    a: 20, 
    b: 15,
    sum: function() {
        console.log(this);
    }
};

obj.sum();
```

Если внутри этого **метода** будет создана **функция** **function shout()**, которая внутри себя будет обращаться к **контексту вызова** и эту функцию вызываем внутри метода. Смотрим в консоль и видим **undefined**. Почему? Потому что это простой вызов **функции**, он уже не относится к **методу**, поэтому **контекст вызова** она просто здесь взяла и потеряла.

```JavaScript
a: 20, 
    b: 15,
    sum: function() {
        function shout() {
            console.log(this);
        }
        shout();
    }
};
obj.sum();
```

![[Untitled 3 33.png|Untitled 3 33.png]]

![[Untitled 4 24.png|Untitled 4 24.png]]

**3)** Третий способ использования **функции** - это использование **функции - конструктора** через **оператор new**.

Эта **функция - конструктор**, то есть когда она будет вызвана, она создаст новый **объект**.

Внутри мы прописывали **свойства**, который обращаются к **this**.

То есть мы для того, чтобы записать какое-то **свойство** обращаемся к **объекту**. И это действительно так. Внутри **функций - конструкторов** **контекст** **вызова** для всех **методов** и **свойств** будте только что созданный **объект**, в данном случае: **let ivan = new User('Ivan', 23)**

**this** всегда ссылается на этот экземпляр, который был создан в этой строчке: **new User('Ivan', 23)**

Точно работает и с **классами**.

**this** в **конструкторах** и **классах** - это новый экземпляр **объекта**! - и это правило нужно выучить наизусть, потому что на нем будет строиться огромное кол-во интерактивов в будущем, на любой библиотеке или фреймворке каждый раз мы будем сталкиваться вот с таким вот поведением **this**.

```JavaScript
function User(name, id) {
    this.name = name;
    this.id = id;
    this.human = true;
}

let ivan = new User('Ivan', 23);
```

**4)** Четвертый вариант - это ручное присвоение **this** любой **функции**.

Ручная привязка **this**: **call**, **apply**, **bind**.

Как сделать так, чтобы **функция** **sayName()**, когда запускалась была как **контекст** не **window** или **undefined**, а именно **const user**, то есть чтобы мы могли получить доступ к **свойству** **name**.

И для того чтобы это сделать существуют 2 **метода**: **call()** и **apply()**

Мы прописываем **sayName.call(user)** или **sayName.apply(user)** и во мы передаем как раз **контекст вызова**, который мы хотим передать в эту **функцию**.

Смотрим в консоль и мы сначала с вами получаем **контекст вызова** - **объект**, к которому мы привязались и далее тот **метод**, который показывается имя у этого **объекта**.(картинка слева)

Получается, что **функция** приобрела свой **контекст**, благодаря тому, что мы использовали эти **методы**(то есть мы можем гибко контролировать **контекст вызова**)

Эти 2 **метода** работают одинаково, разница лишь начинается лишь тогда, когда наша **функция** принимает какие-то дополнительные **аргументы**:

к примеру **аргумент** **surname** и разница в синтаксие у этих **методов**, когда мы передаем этот **аргумент**:

**sayName.call(user, 'Smith');**

**sayName.apply(user, ['Smith']);**

```JavaScript
function sayName(surname) {
    console.log(this);
    console.log(this.name + surname);
}

const user = {
    name: 'John'
};

sayName.call(user, 'Smith');
sayName.apply(user, ['Smith']);
```

Существует еще один **метод** **bind()** -  он создает новую **функцию** и под нее уже подвязывает **контекст**.

Мы создаем новую **переменную** **const double** и в нее мы помещаем новую **функцию**, делается это так: мы обращаемся к существующей **функции** **count** и используем **метод** **bind()**:  **const double = count.bind(2)**

```JavaScript
function count(num) {
    return this*num;
}
const double = count.bind(2);
console.log(double(3));
console.log(double(13));
```

![[Untitled 5 19.png|Untitled 5 19.png]]

![[Untitled 6 18.png|Untitled 6 18.png]]

Когда у нас в **обработчике события** записана **callback - функция** в классическом виде, то в таком случае наш **контекст вызова** будет сам элемент, на котором произошло **событие**.

```JavaScript
const btn = document.querySelector('button');

btn.addEventListener('click', function() {
    console.log(this);
});
```

Мы можем использовать **контекст вызова** **this**, вместо **event.target**, но чаще всего в практике используется **объект события** **event**, а не **контекст** **вызова**.

```JavaScript
const btn = document.querySelector('button');

btn.addEventListener('click', function() {
    this.style.backgroundColor = 'red';
});
```

![[Untitled 7 17.png|Untitled 7 17.png]]

![[Untitled 8 14.png|Untitled 8 14.png]]

![[Untitled 9 12.png|Untitled 9 12.png]]

Эта **стрелочная функция** будет возвращать число, только уже умноженное на 2. Но **стрелочная функция** создана была для того, чтобы укорачивать наш код.Если бы у нас внутри **метода** **sayNamber** была бы обычная **функция**, то это поведение мы уже разобрали, **this** превратился бы в **undefined** или **window**. Но так как в данном примере мы используем **стрелочную функцию** мы вспоминаем, что у нее нет своего **контекста вызова**, она всегда берет **контекст** у своего **родителя**. **Родителем** этой **функции** является **метод**, а у **метода** **контекст** всегда ссылается на **объект**, в котором он существует, соответсвенно **this** будет ссылаться на сам **объект**.

```JavaScript
const obj = {
    num: 5,
    sayNamber: function() {
        const say = () => {
            console.log(this);
        };

        say();
    }
};

obj.sayNamber();
```

![[Untitled 10 8.png|Untitled 10 8.png]]

Эта **стрелочная функция** будет возвращать число, только уже умноженное на 2. Но **стрелочная функция** создана была для того, чтобы укорачивать наш код.

```JavaScript
const double = (a) => {
    return a * 2;
};
```

Если тело **функции** помещается в одну строку, то мы можем ее написать без фигурных скобок.

```JavaScript
const double = (a) => a * 2;
```

И если **стрелочная функция** принимает только один **аргумент**, она может быть записана без круглых скобок.

```JavaScript
const double = a => a * 2;
```

Если мы здесь используем **стрелочную функцию**, то **контекст вызова** теряется, мы его использовать уже не можем и **this** будет равен **undefined**, а если в классическом виде, то имеем доступ к **this**.

```JavaScript
const btn = document.querySelector('button');
btn.addEventListener('click', () => {
    this.style.backgroundColor = 'red';
});
```