[https://learn.javascript.ru/destructuring#destrukturizatsiya-obekta](https://learn.javascript.ru/destructuring#destrukturizatsiya-obekta) - **деструктуризация объектов**

[https://javascript.ru/tutorial/object/intro](https://javascript.ru/tutorial/object/intro) - **объекты** в JS в примерах

[https://learn.javascript.ru/descriptors-getters-setters](https://learn.javascript.ru/descriptors-getters-setters) - **дескрипторы, геттеры и сеттеры свойств**

[https://learn.javascript.ru/object-for-in](https://learn.javascript.ru/object-for-in)  - про **for in**

  

**Объекты** в JS - это так называемые **ассоциативные массивы**, которые присутствуют в некоторых других языках (например в PHP).

Внутри **объекта** можно записать еще один **объект**. Может-быть огромная вложенность **объект** внутри **объекта** и это нормально, к этому нужно привыкать.

```JavaScript
colors: {
        border: 'black',
        bg: 'red'
    }
```

Если мы хотим достучаться к какому-нибудь из **свойств**, мы можем воспользоваться синтаксисом при помощи квадратных скобок или точки console.log(options.name), запускаем такой код (картинка слева) и получаем test.

А если вдруг нам необходимо удалить какое-то **свойство**, пару **ключ** и **значение**, то нам понадобится **операто**р с которым мы еще не знакомились delete, то есть удалить что-то. В данном случае удаляем options.name, запускам код и видим, что у нас вывелся **объект**, только без **свойства** name (картинка справа).

Не забываем кстати, что мы работаем с const, но при этом **объект**, который находится внутри мы модифицируем по собственному желанию, удаляем, меняем внутренности и никаких ошибок нет. **Помним, что прямых const в JS не существует.**

```JavaScript
const options = {
    name: 'test',
    with: 1024, 
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    }
};

console.log(options.name);
```

```JavaScript
const options = {
    name: 'test',
    with: 1024, 
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    }
};

console.log(options.name);

delete options.name;

console.log(options);
```

Чтобы перебрать все **свойства объекта**, мы можем воспользоваться конструкцией **for in**: for (let key in options). Каждое **свойство** называется словом key. Мы задаем **переменную** let key и говорим, что будем копаться внутри in options. Такой своеобразный **цикл** у нас будет работать столько раз, сколько **свойств** находится внутри этого **объекта**. И внутри пишем действие console.log(`Свойство ${key} имеет значение ${options[key]}`), написав такую конструкцию ${options[key]} мы каждый раз будем получать значение **ключа**, который перебирается в этой **итерации цикла**.

Также кроме способа перебора **for in**, есть еще способ перебора **for of**:  for (let key of options)  и перебрать **объект** с помощью этого способа не получится.

```JavaScript
const options = {
    name: 'test',
    with: 1024, 
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    }
};

for (let key in options) {
    console.log(`Свойсвто ${key} имеет значение ${options[key]}`);
}
```

Когда мы перебирали при помощи **for in** у нас вывелось такое вот сообщение Свойство colors имеет значение [object Object], дело в том, что в предыдущем коде все значения выводились в качестве **строк**, но одно из **свойств** нашего **объекта** является тоже **объектом**, и когда JS натыкается на такое значение, он не может объект превратить в **строку**. Как же это исправить? Когда мы перебираем все эти **ключи**, мы также внутри можем их проверять при помощи **условий**, и если значение **ключа**, который мы перебираем будет **объектом**, мы можем запустить перебор внутри перебора.

Запускаем **условие**, где будем проверять на то что **ключ** будет **объектом** if (typeof(options[key]) === 'object'), если это будет, то мы внутри этого **объекта** должны опять запустить какой-то перебор for (let i in options[key]), здесь уже key не получится задать, иначе у нас будет пересечение, просто создадим **переменную** i  и обращаемся к **объекту** не options а,  к **объекту** options[key]. Прописываем действие console.log(`Свойство ${i} имеет значение ${options[key][i]}`) и для того чтобы достучаться до элементов внутри colors, мы используем двойные квадратные скобки, [key][i]. Пример такого доступа к элементам еще на картинке справа. Дальше пишем второе ответвление нашего кода else  и помещаем вот это сообщение console.log(`Свойство ${key} имеет значение ${options[key]}`), если **ключ** не будет **объектом**, то мы выводим как это было раньше. Запускаем код и видим результат.

```JavaScript
const options = {
    name: 'test',
    with: 1024, 
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    }
};

for (let key in options) {
    if (typeof(options[key])) {
        for (let i in options[key]) {
            console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
        }
    } else {
        console.log(`Свойство ${key} имеет значение ${options[key]}`);
    }
}
```

```JavaScript
const options = {
    name: 'test',
    with: 1024, 
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    }
};

console.log(options["colors"]["border"]);
```

Чтобы узнать количество, сколько пар **ключ** и **значение** находится в **объекте**, используя так называемый **прием счетчика**. Создадим переменную let counter = 0 и напишем внутри counter++, и в конце прописываем console.log(counter).

```JavaScript
const options = {
    name: 'test',
    with: 1024, 
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    }
};

let counter = 0;
for (let key in options) {
    counter++;
}
console.log(counter);
```

Более удобный способ посчитать количество **свойств** в **объекте** - это один из **методов объектов**, который называется Object.keys. Если говорить по простому, то этот **метод** берет наш **объект** и на его основании создает **массив**, в котором все элементы это **ключи.** Запускаем код и получаем **массив** со всеми **ключами** (картинка слева).

Также как у **строк** и у **массивов** есть **свойство length**, которое мы можем использовать для того чтобы узнать, какое количество элементов там содержится Object.keys(options).length. Запускаем код и получаем 4 (картинка справа).

```JavaScript
const options = {
    name: 'test',
    with: 1024, 
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    }
};

console.log(Object.keys(options));
```

```JavaScript
const options = {
    name: 'test',
    with: 1024, 
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    }
};

console.log(Object.keys(options).length);
```

Также мы можем создавать **методы** вручную. Помним, что **методы** это действия, которые умеет совершать наш **объект**. Создаем **ключ** makeTest: (то есть проделать какой-то тест) и главное отличие то, что мы записываем **функцию** function(), действие, которое она будет делать - это выводить в консоль слово Test console.log("Test"). Мы создали наш первый **метод**, который будет работать внутри options. Этот **метод** это почти тоже самое, что мы прописывали Object.keys(options).length, только эти **методы** встроены в JS, а эти:

```JavaScript
makeTest: function() {
        console.log("Test");
    }
```

мы создаем самостоятельно. И для того, чтобы запустить этот **метод** прописываем options.makeTest();. Запускаем код и видим слово Test, а это значит наш **метод** сработал.

Для того, чтобы **объект** умел что-то делать, мы можем во внутрь его записывать **функции** и таким образом, мы будем создавать **методы** нашего **объекта**.

```JavaScript
const options = {
    name: 'test',
    with: 1024, 
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    },
    makeTest: function() {
        console.log("Test");
    }
};

options.makeTest();
```

Также рассмотрим одну возможность, которая появилась в стандарте **ES6** - **деструктуризация объектов**, то же самое относится и к **массивам**.

Иногда нам необходимо достучаться до вложенных **свойств** и использовать каждый раз вот такую конструкцию ["colors"]["border"] не очень удобно. И чтобы таким не заниматься у нас и существует **деструктуризация объектов**. По простому мы будем вытаскивать нужные нам **свойства** в качестве отдельных структур.

Создаем **переменную** const, открываем фигурные скобки и помещаем те **свойства**, которые мы хотим вытащить {border, bg}, дальше ставим знак присваивания и сюда мы помещаем ту структуру, из которой хотим вытащить options.colors, (то есть их **деструктурировать**, разделить на более мелкие и удобные кусочки). Прописываем console.log(border), запускаем код и видим, что у нас все работает.

```JavaScript
const options = {
    name: 'test',
    with: 1024, 
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    },
    makeTest: function() {
        console.log("Test");
    }
};

options.makeTest();

const {border, bg} = options.colors;
console.log(border);
```

Как устроен JS изнутри? Мы должны понимать, что все что существует в языке так или иначе идет от **объектов**, например, когда мы используем **метод** **toUpperacase** на строке, когда она превращает всю строку в верхний регистр. Откуда у обычной **строки** появляется **метод**, который еще и что-то умеет делать. Дело в том, что строка на базовом уровне тоже является **объектом** и получает этот **метод** через цепочку прототипов.

![[Untitled 105.png|Untitled 105.png]]

**Надо помнить, что JS является объектно-ориентированным языком и все сущности, которые в нем есть сводятся к объектам. (Если же вдаваться в терминологию программирования, то JS правильнее называть прототипно-ориентированным.)**