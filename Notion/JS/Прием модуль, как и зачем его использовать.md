[https://habr.com/ru/company/ruvds/blog/419997/](https://habr.com/ru/company/ruvds/blog/419997/) - **Паттерн "Модуль"**

**Модуль** используется для того, чтобы скрыть внутренние делали реализации **скрипта**. То есть, когда у нас весь **скрипт** находится в одном файле, его неудобно читать и работать с ним, легче этот большой код разбить на **модули**.

Преимущества модулей:

- они самодостаточны и независимы
- они обеспечивают частоту **глобального пространства**
- **модули** помогают нам избежать загрязнения **глобального пространства**, а также избежать конфликтных ситуаций с одинаковыми именами, ведь все данные модуля существуют только в его собственной области видимости

Пример: если у нас в сторонней **библиотеке**, которую мы скачали есть **переменная** **const app = 2**, и мы в своем главном **скриптовом** файле тоже задали эту **переменную**, то у нас произойдет ошибка, потому что уже такая **переменная** объявлена. Именно поэтому мы стараемся не работать в **глобальном пространств**е и скрывать **переменные** в **локальной области видимости**.

Сейчас на практике все пользуются классами, как мы и видели это в предыдущем уроке, но прием уже был придуман до создания классов, да и мы помним, что внутри там обычная функция.

Для общего понимания мы разберем 2 основных способов создания **модулей** через **нативную** реализацию.

Первый способ - это использовать **анонимную самовызывающуюся функцию**. В данном коде мы задаем **переменную** **const number**, создаем **анонимную самовызывающуюся функцию**, внутри нее создаем **перменную let number**. Запускаем код и видим результат в консоле. И получается, там где конструкция с  **функцией** мы с вами создали **отдельный модуль со своей областью видимости**, но при этом если какие-то действия внутри нее есть, они исполняются нормально во всем скрипте.

```JavaScript
const number = 1;

(function(){
    let number =2; 
    console.log(number);
    console.log(number + 3);
}());

console.log(number);
```

```JavaScript
[Running] node "/Users/nikitaelin/Desktop/work/JS_React/react/my-app/src/tempCodeRunnerFile.js"
2
5
1

[Done] exited with code=0 in 0.162 seconds
```

Второй способ - это использование **объектного интерфейса**. Мы наш модуль записываем в **переменную** и в нее уже возвращаем **методы**, доступные снаружи. То есть наша **анонимную самовызывающуюся функция** создает **объект** и она экспортирует те **методы** и **свойства**, которые нам действительно будут нужны снаружи.

```JavaScript
const user = (fucntion(){
    const privat = fucntion() {
        console.log('I am privat!');
    };

    return {
        sayHello: privat
    };
}());

user.sayHello();
```

Такие конструкции в качестве **анонимных самовызывающихся функций** мы вручную прописывать не будем, за нас это будет делать специальный инструмент, который называется **webpack**.