[http://www.codenet.ru/progr/cpp/ipn.php](http://www.codenet.ru/progr/cpp/ipn.php) - **инкапсуляция, полиморфизм, наследование**

[https://medium.com/devschacht/javascripts-new-private-class-fields-c60daffe361b](https://medium.com/devschacht/javascripts-new-private-class-fields-c60daffe361b) - **новые #приватные поля классов в JavaScript**

  

**Инкапсуляция** - это один из принципов **объектно-ориентированного программирования**.

Сокрытие от внешнего мира внутренностей программы: **переменных**, **функций** и прочего называется **инкапсуляцией**.

В **ООП** это означает, что **объект** хранит свое состояние в приватном порядке и только **методы** **объекта** имеют доступ для его изменений.

Зачем это делается?

- во-первых - эта защита от вмешательства пользователя
- во-вторых мы всегда без последствий сможем улучшать и дорабатывать нашу программу
- в-третьих - это удобно, когда внутренности программы сокрыты, а мы используем лишь ее результат

Разберем на **функции конструкторе**. Рассмотрим код, в нем мы поменяли возраст **ivan** с **27** на **30**. И это то о чем мы говорим, любой может вмешаться в работу нашего **объекта** и поменять те значения, которые у него стояли изначально. Произойдет какое-то вмешательство извне, таким образом внутри у нас все может поломаться. (картинка слева)

Нам нужно пофиксить такое поведение, для этого нам и нужна **инкапсуляция**. Давайте примени ее. Если мы сейчас скажем, что вместо **свойства** **this.age** мы пропишем **переменную** **let** **userAge**, которая будет в себя принимать тот параметр, который приходит к ней при создании этого **объекта**. И мы везде вместо **this.age** и **age** подставляем **userAge**. Запускаем код и видим, что наша **переменная** **userAge** никак не поменялась, осталась 27. Хотя мы прописали прямой доступ к **userAge**. Дело в том, что внутри нашего **объекта** мы создали просто **переменную**, которая недоступна снаружи. Это и есть задатки **инкапсуляция**.(картинка справа)

```JavaScript
'use strict';

class User {
    constructor(name, age) {
        this.name = name;
        this._age = age;
    }

    \#surname = 'Petrychenko';

    say = () => {
        console.log(`Имя пользователя: ${this.name} ${this.\#surname}, возраст ${this._age}`);
    }

    get age() {
        return this._age;
    }

    set age(age) {
        if (typeof age === 'number' && age > 0 && age < 110) {
            this._age = age;
        } else {
            console.log('Недопустимое значение!');
        }
    }
}

const ivan = new User('Ivan', 27);
```

Обычно на этапе разработки каждый программист понимает, в этом **классе** какое-то **свойство** нам необходимо скрыть от внешних факторов. И для этого мы используем такой синтаксис, что мы **свойство** начинаем с нижнего подчеркивания **_age**(это такой договор у программистов, чтобы закрыть доступ к какому ту **свойству**) и используем **геттеры** и **сеттеры**. В результате мы можем использовать **свойства** **аксессоры** и соблюдаем **инкапсуляция**(картинка слева)

И представим, что мы плохие программисты и в **console.log** прописываем не **ivan.age**, а **ivan._age**. И мы получаем все точно также, как и раньше, но теперь мы обходим **геттеры** и **сеттеры** стороной - это неправильно.

Но сейчас появился новая возможонсть - **поля классов**, но нам пока циклиться не нужно на этом синтаксисе. По факту это **свойство**, которое записывается без **конструктора**.