После создания первых нескольких веб-приложений с полным стеком вы, вероятно, привыкли к шаблону запроса и ответа между клиентом и сервером. Клиент запрашивает у сервера информацию, и если сервер определяет, что мы уполномочены делать запрос, и знает, как его выполнить, он отправляет ответ.

И первоначальная идея сети заключалась в том, что она функционирует следующим образом: односторонний запрос от клиента к серверу; соединение, которое заканчивается, когда запрос выполнен.

Но мы знаем из нашего собственного использования Интернета, что данные часто потребляются клиентом гораздо более динамичным образом.

![[Untitled 10.png|Untitled 10.png]]

После того, как в 2005 году был представлен AJAX, разработчики начали искать способы сделать связь между клиентом и сервером двунаправленной, чтобы серверы могли передавать данные клиенту без запроса HTTP-запроса для каждого пакета данных. Если клиенту необходимо получать новые данные с высокой частотой, создание группы HTTP-запросов будет неэффективным, поскольку каждый раз, когда отправляется HTTP-запрос, также отправляются заголовки и данные cookie, что при большом количестве запросов может составлять до довольно много данных, которые необходимо передать. Это вызывает задержку, которую, как мы знаем, пользователи не ценят. Кроме того, клиентская сторона узнает, есть ли новые данные, только если она сделает запрос.

Поэтому отрасли нужны решения, обеспечивающие постоянное соединение с малой задержкой, которое может поддерживать транзакции, инициированные клиентом или сервером.

Если мы подумаем о популярных веб-сайтах, таких как Facebook или Twitter, мы знаем, что новые данные отображаются на странице без того, чтобы мы инициировали запрос на них с нашей стороны. В мессенджере Facebook новые сообщения появляются на нашем экране без обновления или каких-либо действий на стороне клиента. Как это работает?

# **Long polling**

Одно из решений этой проблемы называется длительным опросом, при котором HTTP-соединение остается открытым до тех пор, пока сервер не получит данные для отправки клиенту. Если при запросе к серверу данных еще нет, сервер продлевает ответы, пока клиент ждет.

Если за это время становятся доступными новые данные, они отправляются клиенту. При отправке данных или истечении времени ожидания запроса — в зависимости от того, что произойдет раньше — создается новый запрос на восстановление соединения.

Это создает иллюзию соединения, инициированного сервером, показывая пользователю новую информацию по мере ее появления. Этот механизм используется, например, в Gmail и Facebook.

# **Server-side events**

Если данные должны последовательно передаваться от сервера к клиенту, а не наоборот (например, новостные ленты), разработчик может использовать интерфейс EventSource, чтобы разрешить события, отправляемые сервером. Следующий код откроет соединение с сервером, чтобы начать получать от него события, с URL-адресом скрипта, который генерирует события.

```JavaScript
const newEventSource = new EventSource("example.php")
```

Преимущество этого метода заключается в наличии только одного HTTP-запроса и позволяет клиенту получать события в формате текста/потока событий, не закрывая соединение.

# **Websockets**

Когда приложение включает в себя функциональность, которая зависит от согласованных данных в реальном времени с сервера, разработчик может рассмотреть возможность использования веб-сокета, который после первоначального HTTP-запроса для начального «рукопожатия» для установления соединений позволяет серверу и клиенту обмениваться данными. отправлять сообщения друг другу в любое время без запроса какой-либо из сторон.

**Websockets** по существу преобразуют HTTP-соединение в соединение через веб-сокет. **Websockets** являются частью HTML5 и поддерживаются всеми современными браузерами — другими словами, существует API-интерфейс javascript для их изначального использования в браузере. В отличие от других механизмов, упомянутых в этом сообщении в блоге, **websockets** могут обнаруживать упавших или отключенных клиентов, а также могут обрабатывать до 1024 подключений на браузер.

Наиболее распространенными реализациями веб-сокетов являются голосовой/видеочат, многопользовательские игры, приложение мгновенного чата или push-уведомления.

Создание соединения **Websocket** со стороны клиента может быть выполнено с помощью следующего кода (с реальным URL-адресом, который использует API **Websocket**):

```JavaScript
// Create WebSocket connection.
const socket = new WebSocket('example.com');
// Connection opened
socket.addEventListener('open', function (event) {
socket.send('Hello Server!');
});
// Listen for messages
socket.addEventListener('message', function (event) {
console.log('Message from server ', event.data);
});
```

Источник: [веб-документы MDN .](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)

В этих трех механизмах гораздо больше, чем то, что я упомянул здесь, поэтому я рекомендую себе, своим коллегам по Flatiron и коллегам-младшим разработчикам делать то, что у нас получается лучше всего, и использовать Google, чтобы узнать больше. :)