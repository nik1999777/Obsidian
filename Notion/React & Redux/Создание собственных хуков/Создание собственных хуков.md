[https://ru.reactjs.org/docs/hooks-custom.html](https://ru.reactjs.org/docs/hooks-custom.html) - документация создания пользовательских хуков

[https://usehooks.com/](https://usehooks.com/) - сервис готовых хуков useHooks

[https://www.bornfight.com/blog/top-10-react-hook-libraries/](https://www.bornfight.com/blog/top-10-react-hook-libraries/) - топ 10 react hooks

[https://www.random.org/clients/http/api/](https://www.random.org/clients/http/api/) - api случайного числа для д/з

![[Untitled 51.png|Untitled 51.png]]

В данном коде мы работаем с формой.

Мы создали некий функционал по **валидации** формы.

Но тут можно сразу обнаружить 2 проблемы:

- когда полей ввода мало, то **state** создавать достаточно удобно. Но как только их станет намного больше, то код будет очень сильно повторятся.
- в приложении может быть много форм и каждый раз писать одну и ту же **логику** внутри них - это тоже будет дублированием

И здесь хотелось бы создать какую-то абстракцию через которую мы бы могли избавиться от дублирования, то есть какая-то отдельная **функция**, которая будет всем этим заниматься.

App.js

```JavaScript
import {useState} from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

const Form = () => {
    const [text, setText] = useState('');
		const [textArea, setTextArea] = useState('');

		const validateInput = (text) => {
	      return text.search(/\d/) >= 0 
    }

    const color = validateInput(text) ? 'text-danger' : null;

    return (
        <Container>
            <form className="w-50 border mt-5 p-3 m-auto">
                <div className="mb-3">
                    <input value={`${text} / ${textArea}`} type="text" className="form-control" readOnly/>
                    <label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
                    <input onChange={(e) => setText(e.target.value)} 
                           type="email"
                           value={text}
                           className={`form-control ${color}`}
                           id="exampleFormControlInput1" 
                           placeholder="name@example.com"/>
                    </div>
                    <div className="mb-3">
                    <label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
                    <textarea 
												onChange={e => setTextArea(e.target.value)}
												className="form-control" 
												id="exampleFormControlTextarea1" 
												rows="3"></textarea>
                </div>
            </form>
        </Container>
    )
}

function App() {
    return (
        <Form/>
    );
}

export default App;
```

  

Такую **функцию** можно создать и она будет называться нашим **собственным(кастомным, пользовательским) хуком**:

- создаем **функцию** **useInputWithValidate()**, которая содержит внутри себя **состояние**, различные **методы**(в том числе и по работе с этим **состоянием**). И возвращает их наружу в виде **объекта**.
- когда нам понадобится весь этот функционал - теперь его можно не создавать внутри каждого компонента. Мы лишь просто создаем **переменную** и в нее кладем **объект**, который получается в качестве вызова этой **функции**.
- и далее для того чтобы использовать все эти **методы** и **состояния** - мы обращаемся к **переменой**

**Собственный хук** лучше выделить в отдельный компонент, чтобы его можно было использовать где-угодно.

  

**Собственный(кастомный хук)** - это механизм повторного использования **логики** с **состоянием**. Но при этом каждый раз когда мы используем **собственный** **хук** - все **состояния** и **эффекты** внутри него полностью изолированы. (потому что при каждом **вызове** этой **функции** - создается новый **объект**, которые содержит все в уникальном значении)

App.js

```JavaScript
import {useState} from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

function useInputWithValidate(initialValue) {
    const [value, setValue] = useState(initialValue);

    const onChange = event => {
        setValue(event.target.value);
    }

    const validateInput = () => {
        return value.search(/\d/) >= 0 
    }

    return {value, onChange, validateInput}
}

const Form = () => {
    const input = useInputWithValidate('');
    const textArea = useInputWithValidate('');

    const color = input.validateInput() ? 'text-danger' : null;

    return (
        <Container>
            <form className="w-50 border mt-5 p-3 m-auto">
                <div className="mb-3">
                    <input value={`${input.value} / ${textArea.value}`} type="text" className="form-control" readOnly/>
                    <label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
                    <input onChange={input.onChange} 
                           type="email"
                           value={input.value}
                           className={`form-control ${color}`}
                           id="exampleFormControlInput1" 
                           placeholder="name@example.com"/>
                    </div>
                    <div className="mb-3">
                    <label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
                    <textarea 
                        onChange={textArea.onChange}
                        value={textArea.value}
                        className="form-control" 
                        id="exampleFormControlTextarea1" 
                        rows="3"></textarea>
                </div>
            </form>
        </Container>
    )
}

function App() {
    return (
        <Form/>
    );
}

export default App;
```

![[Untitled 1 12.png|Untitled 1 12.png]]

В данном коде мы создали **пользовательский хук** для счетчика.

```JavaScript
function useCounter(initial) {
    const [counter, setCounter] = React.useState(initial);
  
    // Это вариант с запросом, чтобы он нормально работал после активации - уберите все props,
    // которые приходят в компонент + аргумент initial поменяйте на 0 или null
  
    /* React.useEffect(() => {
        fetch('https://www.random.org/integers/?num=1&min=-50&max=50&col=1&base=10&format=plain&rnd=new')
            .then(res => res.text())
            .then(res => setCounter(res))
            .catch(err = conosle.log(err))
    }, []) */
  
    const incCounter = () => {
      if (counter < 50) {
        setCounter(counter => counter + 1)
      }
    } 

    const decCounter = () => {
      if (counter > -50) {
        setCounter(counter => counter - 1)
      }
    }

    const rndCounter = () => {
      setCounter(+(Math.random() * (50 - -50) + -50).toFixed(0))
    }

    const resetCounter = () => {
      setCounter(initial)
    }
    
    return {
      counter,
      incCounter,
      decCounter,
      rndCounter,
      resetCounter
    }
}

const Counter = (props) => {
    const {counter, incCounter, decCounter, rndCounter, resetCounter} = useCounter(props.counter);

    return (
      <div className="component">
        <div className="counter">{counter}</div>
        <div className="controls">
          <button onClick={incCounter}>INC</button>
          <button onClick={decCounter}>DEC</button>
          <button onClick={rndCounter}>RND</button>
          <button onClick={resetCounter}>RESET</button>
        </div>
      </div>
    )
}

const RndCounter = (props) => {
    const {counter, rndCounter, resetCounter} = useCounter(props.counter);

    return (
      <div className="component">
        <div className="counter">{counter}</div>
        <div className="controls">
          <button onClick={rndCounter}>RND</button>
          <button onClick={resetCounter}>RESET</button>
        </div>
      </div>
    )
}

const App = () => {
    return (
        <>
            <Counter counter={0}/>
            <RndCounter counter={5}/>
        </>
    )
}

ReactDOM.render(<App />, document.getElementById('app'));
```