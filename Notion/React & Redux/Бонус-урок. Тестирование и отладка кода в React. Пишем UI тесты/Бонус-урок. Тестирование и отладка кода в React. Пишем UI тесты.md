[https://jestjs.io/](https://jestjs.io/) - Jest

[https://reactjs.org/docs/test-renderer.html](https://reactjs.org/docs/test-renderer.html) - Test Renderer

[https://enzymejs.github.io/enzyme/](https://enzymejs.github.io/enzyme/) - Enzyme

[https://github.com/jest-community/jest-extended](https://github.com/jest-community/jest-extended) - Jest-extended

[https://medium.com/@karafizi/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-react-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D1%81-jest-%D0%B8-enzyme-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4-985dcab18b7e](https://medium.com/@karafizi/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-react-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D1%81-jest-%D0%B8-enzyme-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4-985dcab18b7e) - Тестирование React компонентов с Jest и Enzyme

  

Хороший программист это всегда и **тестировщик**. Он должен продумывать все возможные исходы, проверять эти гипотезы и фиксить ошибки, если они появляются.

Давайте представим большой рабочий проект. У нас все работает. Мы все протестировали. Но со временем продукт меняется.

Часть функционала исчезает, часть появляется, продукт становится все больше и больше. После каких-то таких изменений - мы конечно же не будем проверять заново каждый файл. А ошибки могут в нем возникнуть. Особенно если части приложения будут взаимосвязаны. И чем больше продукт, тем больше ошибок может возникнуть.

Нам нужно то, что будет проверять код на соответствие необходимому результату. Здесь мы и сталкиваемся с таким понятием, как тесты.

Программист, умеющий покрывать свой код грамотными тестами всегда будет цениться больше.

  

Самый простой способ тестирования, которым пользовался каждый - это **console.log()**. Но самая большая проблема в том, что таким образом мы не можем вывести ни где произошла ошибка, ни что эта за ошибка.

  

Также тестировать приложение вручную и очень наглядно можно при помощи **плагина - React Developer Tools**.

В **React** приложение, либо на сайте, который написан на **React** при входе в консоль можно обнаружить вкладку, в которой можно увидеть дерево приложения. Как расположены сами **компоненты**, что они и себя представляют и главное, какие у них **props** и **state**.

![[Untitled 75.png|Untitled 75.png]]

Но мы рассмотрим автоматические тесты на основе **фреймворка JEST**. Подобных инструментов очень много, но все они очень похожи. Но почему **JEST**?

Дело в том, что его разработал все тот же **facebook**. И да, он уже включен в сборку **create-react-app** и уже готов к работе.

![[Untitled 1 22.png|Untitled 1 22.png]]

Также для того чтобы изолированно тестировать **react компоненты** нам необходима только одна **библиотека**. Это **enzyme**.

Установим нужные нам **библиотеки**:

- **библиотека - enzyme**
- для работы с **react** - **библиотека enzyme-adapter-react-17**
- а также **библиотека react-test-renderer**

```Plain
npm intall enzyme enzyme-adapter-react-17 react-test-renderer
```

Теперь мы готовы к практике. Но нам необходимо уяснить: а на чем вообще строятся принципы **тестирования UI компонентов**?

В **react** мы тестируем:

- **визуальную часть**, что она никак не поменялась (в основном этот контролируется **классами**)
- а также **пропсы**, при помощи которых компонент общается с внешней средой (мы можем проверить их, либо на строгое соответствие, либо на тип данных)
- тоже самое и для **state** (но только в самом начале пути нашего **компонента**, ведь позже они могут поменяться при помощи **событий**)
- и для **событий** мы тоже можем написать тесты

А что же не нужно тестировать:

- если мы тестируем **компонент**, нельзя трогать трогать то, что с ним не связано (как пример: это **импортируемые** извне **компоненты**). Вообщем тестируем все по отдельности.
- не тестируйте **функции**, которые пришли из сторонних **библиотек** (в этом нет смысла и эта вообще не наша зона ответсвенности)
- но а также **константы** тоже нет смысла тестировать

  

В каком же порядке нужно тестировать **приложение**?

Понятное дело, что оно сейчас разбито на **компоненты**. **Компоненты** могут быть сложные, простые, зависимые, независимые, повторяемые и используемые только один раз.

В любом учебнике по тестированию вы найдете принцип - от простого к сложному.

- сначала стоит прописывать тесты для независимых **компонентов**, они самодостаточны и вероятность ошибки в них ниже
- далее стоит обратить внимания на вспомогательные **компоненты**: такие как **спиннеры**, ошибки и тому подобное
- далее начинаем тестировать **компоненты** с небольшими зависимостями
- и доходим до самых-самых сложных и объемных

И вот здесь раскрывается смысл этого принципа :

Когда мы дошли до самых больших и сложных **компонентов** - все мелкие, которые включаются в них, уже покрыты тестами.

Рассмотрим **библиотеке JEST**. Сам принцип тестирования прост. Он заключается в сравнении фактического результата с ожидаемым. То есть мы задаем **функцию** или какой-то **объект** и ожидаем от него какого-то результата.

  

Давайте рассмотрим документацию **JEST**.

Самые классические **методы toBe()** и **toEqual()**.

**toBe()** - самый простой **метод** , он сравнивает с тем результатом, который мы получили. (мы сравниваем результат фактический и ожидаемый).

**toEqual()** - немного посложнее. Здесь мы имеет возможность сравнивать по значению.

(картинка слева)

Далее идет блок **методов**, которые отвечают за правдивость наших выражений. Тут мы имеем возможность проверить на **null**, **undefined**, **toBeUndeFined**, а также просто на **true** и **false**.

(картинка справа)

![[Untitled 2 15.png|Untitled 2 15.png]]

![[Untitled 3 5.png|Untitled 3 5.png]]

Далее мы видим, что можем проверять на числа. (картинка слева)

Также мы можем проверять строки на четкое сопоставление, мы используем **регулярные выражения**, которые мы передаем в **метод toMatch()**. (картинка справа)

![[Untitled 4 2.png|Untitled 4 2.png]]

![[Untitled 5 2.png|Untitled 5 2.png]]

Для работы с **массивами** у нас есть **метод toContain()**, который позволяет нам перебрать весь **массив** и узнать: а действительно ли в этом **массиве** есть тот элемент, который мы указали. (картинка слева)

Также мы можем работать с ошибками.

![[Untitled 6 2.png|Untitled 6 2.png]]

![[Untitled 7 2.png|Untitled 7 2.png]]

Для тестирования **асинхронных операций** (таких как например **запрос к сервер**), есть отдельный раздел. И тут существует 3 подхода:

- это **callbacks**
- **promises**
- и **async/await**

![[Untitled 8 2.png|Untitled 8 2.png]]

![[Untitled 9 2.png|Untitled 9 2.png]]

![[Untitled 10 2.png|Untitled 10 2.png]]

Эта **библиотека react-test-renderer**. Для чего она нужна?

Дело в том, что когда мы используем **JEST** у нас есть лишь набор каких-то **test кейсов**. Но в **библиотеке JEST** нет ни слова, как нам тестировать **react** **компоненты**. А чтобы **компонент** протестировать его нужно сначала создать, ведь **JEST** этого совсем не делает. Он предоставляет лишь нам инструменты для тестирования.

А вот для того чтобы создать какой-то **компонент** нам и понадобится **react-test-renderer**. Эта **библиотека**, которая содержит небольшое кол-во **методов**. И один из самых главных - это **TestRenderer.create()**. Он позволяет нам создать экземпляр нашего **компонента** и уже с ним проводить какие-то операции.

Поэтому **JEST** - это **фреймворк** чисто для тестирования. А **библиотека react-test-renderer** позволяет работать именно с **react компонентами**.

![[Untitled 11 2.png|Untitled 11 2.png]]

Существует 2 подхода к тестированию **UI компонентов**:

- на основе снимков (снимок - это запечатление визуального отображения компонента)
- и тестирование их логики

Протестируем **компонент randomChar**. Создадим файл **randomChar.test.js**. Таким образом мы создадим файл теста, в котором и будут написаны наши тесты. В этот файл нам необходимо **импортировать библиотеку react-test-renderer**.

Далее прописываем наши тесты. Начнем с глобального описания (так называемого **Test suite**). **Test suite** - это отдельный блок кода, который тестирует какую-то часть.

**Test suite** начинается с **describe()**. Внутри него будет 2 **аргумента**:

- первый - это описание, который будет выводится нам в консоль **('Testing <RandomChar/>')**
- вторым - **callback функция**, которая и будет выполнять те тесты, который мы напишем.

Далее в **Test suite** мы будем прописывать **Test Case**. **Test Case** - это тестовые случаи, которые мы будем проверять.

Каждый **Test Case** начинается с ключевого слова **it()** - эта **функция**, которая также принимает в себя 2 **аргмуента**:

- первый - это описание **('RandomChar have rendered correctly')**
- вторым - это опять же **callback функция**, далее внутри нее мы будем описывать, что будет происходить в нашем **Test Case**.

Чтобы протестировать **компонент** его нужно в первую очередь создать: **const char = renderer.create(<RandomChar/>).toJSON()** - здесь мы используем **переменную renderer** и ее **функцию create()**, а во внутрь **функции** мы как раз и передаем тот **компонент**, который мы хотим отрендорить **<RandomChar/>** и переводим все в **формат JSON**.

И далее мы хотим снимок (слепок того, как этот компонент визуально должен выглядеть). Для этого пишем команду **expect()** - это как раз основная команда нашего **Test Case**, она и будет проверять на соответствие. Во внутрь мы передаем **переменную** **char**. И тут используем команду **toMatchSnapshot()** (снимок нашего **компонента**).

В итоге, когда наш тест будет проводиться, этот снимок будет сравниваться оригиналом (то есть с тем, который был изначально получен). И если вдруг что-то не совпадает, нам тест выдаст ошибку и скажет: Что ваш компонент возможно обновился. Вы хотите обновить этот снимок? И здесь мы будем решать по какому пути нам пойти. Либо фиксить баги, либо обновлять **snapshot** (снимок).

Прописываем команду **npm run test** и получаем результат теста. (картинка справа)

При запуске теста у нас запускается как бы **сервер**, который автоматически следит за тестами и за тем, что вы изменяете в файлах.

![[Untitled 12 2.png|Untitled 12 2.png]]

![[Untitled 13 2.png|Untitled 13 2.png]]

Посмотрим на **snapshot** и то как он выглядит. И видим, что это вот такое вот визуальное оформление нашего **компонента**

![[Untitled 14 2.png|Untitled 14 2.png]]

Теперь проверим насколько правильно отрабатывает наш тест. В компоненте **randomChar** в визуальном отображении добавим **класс** **ronded some**. И в терминал мы получаем **fail**. И мы видим что-изменилось, различия в **snapshots** (снимках).

![[Untitled 15 2.png|Untitled 15 2.png]]

![[Untitled 16 2.png|Untitled 16 2.png]]

Создадим файл c настройками теста - **setupTests.js**. В нем **импортируем** значение **configure** из **enzyme**. И также нам необходимо вторая зависимость, **импортируем Adapter** из **библиотеке** **enzyme-adapter-react-16**.

И далее запустим очень простую команду: **configure({adapter: new Adapter()})**. Все на этом настройка закончена. Теперь мы можем спокойно использовать **enzyme**  в наших тестах.

![[Untitled 17 2.png|Untitled 17 2.png]]

Попробуем теперь протестировать **компонент headaer**. Точно также как и **randomChar**. Но запустив тест, у нас вылезет ошибка (что наши **Link** не могут обходится без **router**). Почему? Д потому что когда мы используем команду **create()**, мы **рендерим** все что включается в **компонент**.

Но допустим мы бы хотели отбросить **Link** и протестировать **компонент** изолированно. В этом нам и поможет **библиотека enzyme**.

И далее мы импортируем **функцию shallow(**).

Запускаем тест.

Открываем **snapshot** и видим уже немного другую структуру. Получается то что было внутри самого **<Link>**  нас не интересует, нас интересует лишь изолированный **компонент header**. Именно для этого используется **библиотека enzyme**.

![[Untitled 18 2.png|Untitled 18 2.png]]

![[Untitled 19 2.png|Untitled 19 2.png]]

Но тестирование **snapshots** (снимками) - это не самая эффективная методика.

Далее нам необходимо тестировать **props** и **state**.

На примере рассмотрим тестирование **props-ов**. Мы создаем **компонент** **<Document/>** с определенным **property** и далее мы ожидаем, что этот **property** в итоге окажется тем же текстом, который мы ему передали.

Таким образом, тесты на **свойства** (на **props**) - это не особо полезная возможность. По факту то что мы передаем в это же **свойство**, этим же и останется. И даже проверка на **тип данных** будет иметь тот же эффект. Единственное применение - это проверка **props-ов**, установленных по умолчанию.

Нужно стараться избегать написание тестов ради тестов.

![[Untitled 20 2.png|Untitled 20 2.png]]

**Библиотека JEST** не уметь проверять на **тип данных**: действительно ли наш результат является **объектом** или **массивом**. Для этого существует еще одна **библиотека jest-extended**. Она как раз и позволяет проверять на различные **типы данных**.

![[Untitled 21 2.png|Untitled 21 2.png]]

```Plain
npm install jest-extended --save-dev
```

Также после того, как мы установили пакет нам нужно его настроить. Данной настройкой мы говорим, что **JEST** должен использовать доп пакет в своей работе.

![[Untitled 22 2.png|Untitled 22 2.png]]

Давайте теперь протестируем **state** (состояния). В данном коде мы проверяем, чтобы наш **state**:

- был **объектом** - **toBeObject()**
- что он действительно существует и изначально он у нас true - **toBeTruthy()**
- также на то что **state** у нас **false** - **toBeFalsy()**

И далее протестируем **события** в наших **компонентах**.

Сначала создадим еще **2 Test suite** и разместим в них тесты **состояний** (states) и **свойств** (props).

Для того чтобы создать тест для **событий** мы используем **метод instance()** и вызываем то **событие**, которое мы проверяем - **onCharLoaded()**. Далее мы проверяем **state loading** на **false** - **toBeFalsy()**.

Таким же способом проверяем **события onError()** и **updateChar()**.

![[Untitled 23 2.png|Untitled 23 2.png]]

Иногда мы хотим протестировать **события** на вложенных элементах, здесь нам понадобится другой **метод** из **библиотеке enzyme - mount()**.

В данном коде мы тестируем **компонент** **<ItemList/>**.

![[Untitled 24 2.png|Untitled 24 2.png]]

![[Untitled 25 2.png|Untitled 25 2.png]]