  

- ==[Основные принципы ООП?](https://youtu.be/w-vUj0gHGgg?t=538)==
    
    ООП (Объектно ориентированный подход к программированию) базируется на 4 основных принципов:
    
    - абстракция - это отделение концепции от реализации
    
    Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов для решения поставленной задачи.
    
    - наследование - это способность объекта или класса базироваться на другом объекте или классе
    
    Это главный механизм для повторного использования кода.
    
    - инкапсуляция - размещение одного объекта или класса внутри другого для разграничения доступа к ним
    - полиморфизм - это реализация задач одной и той же идеи разными способами
- ==[Что такое SOLID?](https://youtu.be/w-vUj0gHGgg?t=603)==
    
    SOLID - это аббревиатура для обозначения 5 принципов, которые используются в ООП.
    
    Общая идея говорит о том, что использование сразу нескольких принципов как единого целого - намного лучше, чем использования их по отдельности.
    
    SOLID принципы:
    
    - Single responsibility (принцип единственной ответственности) - у модуля должна быть только одна причина для изменения или класс должен отвечать только за что-то одно
    - Open-closed (принцип открытости / закрытости) - модуль должен быть открыт для расширения, но закрыт для изменения
    - Liskov substitution (принцип подстановки Барбары Лисков) - необходимо, чтобы подклассы могли служить заменой для своих суперклаcсов.
    - Interface segregation (принцип разделения интерфейса) - сущности не должны зависеть от интерфейсов, которые не используют
    - Dependency inversion (принцип инверсии зависимостей) - модули высших уровней не должны зависеть от модулей низких уровней. Оба должны зависеть от абстракций, а абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.
- ==[Разница между классовым и прототипным наследованием?](https://youtu.be/rWEsjNWBoIE?t=751)==
    
    Классовое наследование - это механизм наследования, при котором экземпляры наследуются от классов, а также создается иерархическая система классов или под классовые отношения.
    
    Экземпляры реализуются через конструктор функций через дескриптер - new. Также экземпляр класса может не содержать дескриптер - class, начиная с версии ES6.
    
    Прототипное наследование - это механизм наследования при котором экземпляры наследуются напрямую от других объектов. Реализуется данный подход через фабрики или метод Object.create().
    
    Экземпляры могут быть составлены из множества различных объектов для упрощения выборочного наследования.
    
    К плюсом прототипного наследования можно отнести:
    
    - простота (если сравнивать с классовым)
    - слабая связь (экземпляр никогда не нуждается в прямой ссылке на родительский класс или прототип)
    - с прототипным наследованием легко поддерживать плоские иерархии, используя конкатенацию
    - выборочное использование свойств одного объекта для создания другого и делегирование
    - клонирование одного объекта в другой
    - гибкая архитектура, поскольку можно выборочно наследоваться - больше не нужно беспокоиться о проблеме неправильного дизайна
    - новый класс может наследовать любую комбинацию свойств от любой комбинации исходных объектов
- ==[Однонаправленный поток данных и двусторонняя связь данных? В чем между ними разница?](https://youtu.be/rWEsjNWBoIE?t=845)==
    
    Эта довольна важная концепция, которая активно используется в архитектуре современных библиотек и фреймворков.
    
    Однонаправленный поток данных означает, что только модель - это источник истины. Смысл в том, что данные всегда идут в одном направлении, что облегчает понимание. Любые изменения в интерфейсе - запускает событие, которое сообщает пользователю о намерении модели. Для простоты понимания - в Rect приложениях такой моделью может-быть - state.
    
    Двухстороння связь данных подразумевает, что поля интерфейса связаны с моделью данных - динамически. Другими словами при изменении интерфейса - происходит изменение модели и наоборот. Здесь для понимания можно вспомнить директиву v-model из vue.js.
    
    Однонаправленные потоки данных - четко определены и обычно по иерархии элементов идут сверху вниз, то есть от родителя к потомку.
    
    В то время как двустороння привязка может вызывать нежелательные эффекты, которые труднее отследить и понять.
    
- ==[Что такое функциональное программирование?](https://youtu.be/ovV8GhIkzBE?t=410)==
    
    Функциональное программирование - это парадигма программирования, в которой процесс вычисления трактуется как вычисления значения функций.
    
    Противопоставляется парадигме императивного программирования, который описывает процесс вычислений, как последовательное изменение состояний.
    
    При необходимости в функциональном программировании вся совокупность последовательных состояний вычисленного процесса предоставляется явным образом - например как список.
    
    Функциональное программирование предполагает обходиться вычислением результата функций - от исходных данных и результатов других функций и не предполагает явного хранения - состояния программой. Соответсвенно оно и не предполагает изменяемость этого состояния, в отличие от императивного, где одной из базовых концепций является переменная, хранящая свое значение и позволяющая менять его по мере выполнения алгоритма.
    
    Таким образом - приложение, написанное в функциональном стиле проходит через 3 основных этапа:
    
    - это получение аргументов для работы
    - выполнение функции с этими аргументами или без них
    - возвращение результата
- ==[Что такое MVC?](https://youtu.be/xZLxdts7ZW4?t=181)==
    
    MVC - это паттерн или шаблон проектирования.
    
    Данный патерн помогает разбить монолитное приложение на независимые, сформированные структуры - каждая из которых отвечает за свою конкретную логику.
    
    Это позволяет держать код модульно, увеличить его переиспользуемость, тестируемость, читаемость и поддерживаемость.
    
    MVC - это аббревиатура, которая описывает основные части паттерна:
    
    - Modal (Модель)
    - View (Представление)
    - Controller
    
    ![[Untitled 90.png|Untitled 90.png]]
    
- ==[Что такое MVVM?](https://youtu.be/ovV8GhIkzBE?t=489)==
    
    Model-View-ViewModel (MVVM) (Модель Представление МодельПредставления) - это архитектурный паттерн, используется для разделение модели (Model) и ее представления (View), что необходимо для их изменения - отдельно друг от друго. (Например - Разработчик создает логику работу с данными, а верстальщик работает с пользовательским интерфейсом).
    
    Данный подход позволяет связывать - элементы представления (View) со свойствами и событиями View Model.
    
    View Model - это со одной стороны абстракция представления (View), а с другой - это обертка данных из модели (Model), которая подлежит связыванию. То есть она содержит модель (Model) - преобразованную к представлению (View), а также команды - которыми может пользоваться представление (View), чтобы влиять на модель (Model).
    
    Можно утверждать, что каждый слой этого паттерна - не знает о существовании другого слоя.
    
    К признаком View Model можно отнести - двухстороннюю коммуникацию с представлением (View).
    
    View Model - это абстракция представления (View), обычно означает, что свойство представления (View) совпадает со свойствами View Model.
    
    View Model не имеет ссылки на интерфейс представления (View). Изменение состояния View Model - автоматически изменяет представление (View) и наоборот, поскольку используется механизм связывания данных. Один экземпляр View Model связан с одним отображением.
    
    ![[Untitled 1 31.png|Untitled 1 31.png]]
    
- ==[Что такое MVP?](https://youtu.be/ovV8GhIkzBE?t=581)==
    
    MVP (MODEL - VIEW - PRESENTER) - это архитектурный паттерн проектирования, который позволяет создать абстракцию представления (VIEW).
    
    Для этого необходимо выделить интерфейс представления (VIEW) с определенным набором свойств и методов.
    
    PRESENTER в свою очередь получает ссылку на реализацию интерфейса, подписывается на событие представления (VIEW) и по запросу изменяет модель (MODEL).
    
    Паттерн разработан с целью упрощения процесса модульного автоматизированного тестирования и улучшения разделения ответсвенности к презентационной логики.
    
    К признакам PRESENTER можно отнести - двухстороннюю коммуникацию с представлением (VIEW).
    
    Представление (VIEW) взаимодействует напрямую с PRESENTER - путем вызова соответствующих функций или событий экземпляра - PRESENTER.
    
    PRESENTER взаимодействует с VIEW - путем использования специального интерфейса, реализованного представлением.
    
    Один экземпляр - PRESENTER связан с одним отображением (VIEW).
    
    ![[Untitled 2 21.png|Untitled 2 21.png]]
    
- ==[Недостатки паттерна MVW?](https://youtu.be/xZLxdts7ZW4?t=282)==
    
    MVW - Model View Whatever (Модель Представления что-угодно).
    
    MVW легко управлять в простом приложении, содержащим несколько моделей и контроллеров.
    
    При росте приложения можно столкнуться со следующими проблемами:
    
    - модели и контроллеры - взаимодействуют
    
    Эти модули меняют состояния друг друга. И чем больше модулей, тем легче утратить контроль над тем, как изменено состояние того или иного модуля.
    
    - асинхронные сетевые запросы добавляют элемент неожиданности в то - когда модель будет изменена или модифицирована
    
    Тут достаточно представить кейс, что пользователь изменил UI до того - как пришел ответ на асинхронный запрос
    
    - изменение состояния (state) модели добавляют еще один уровень сложности - мутацию
    
    Требуется определить - каким образом изменяется состояние или модель. И какие инструменты необходимы для распознавания мутации.
    
    - код совместно использованного приложения (такого как google docs например, где множества данных меняются в режиме реального времени) - будет просто огромным
    - нет возможности отменять действие, возвращаться назад во времени - без добавления большого кол-ва дополнительного кода
- ==[Разница между функцией и методом?](https://youtu.be/ovV8GhIkzBE?t=645)==
    
    Функция - это фрагмент кода, который вызывается по имени и не связан с каким-либо объектом и не определен внутри объекта.
    
    В функции могут быть переданы данные для работы, то есть параметры и при желании могут-быть возвращены данные.
    
    Метод - это фрагмент кода, который вызывается по имени и определяется внутри объекта, он почти идентичен функции за исключением того, что он всегда связан с объектом и работает только с данными внутри него.
    
- ==[Что такое каррирование (Currying)?](https://youtu.be/ovV8GhIkzBE?t=681)==
    
    Каррирование - это процесс в функциональном программировании, в котором возможно преобразовать функцию с несколькими аргументами в набор вложенных функций с одним аргументом.
    
    1. Исходная функция возвращает новую функцию, которая ожидает следующий встроенный аргумент.
    2. Новая функция, ожидающая следующего аргумента - возвращается при каждом вызове каррированной функции до тех пор, пока функция не получит все необходимые ей аргументы.
    3. Ранее полученные аргументы, благодаря механизму замыканий - ждут того момента, когда функция получит все что ей нужно для выполнения вычислений.
    4. После получения последнего аргумента - функция выполняет вычисления и возвращает результат.
    
    Преобразование функции - позволяет легко получать частичные данные, избегая многократной передачи одной и той же переменной.
    
    Каррирование - создает вложенные функции в соответствии с кол-вом аргументов функции. Поэтому каждая функция получает аргумент и если аргумента нет - то каррирование не выполняется.
    
    ![[Untitled 3 11.png|Untitled 3 11.png]]
    
- ==[Плюсы и минусы ФП и ООП?](https://youtu.be/70VnuTXi4Wk?t=327)==
    
    - ФП
    
    Большой плюс функционального программирования - это использование функциональной парадигмы, которая позволяет избежать общих состояний и нежелательных эффектов.
    
    Также исключаются ошибки, возможные из-за конкурирования функций.
    
    Благодаря таким фичам как - неявное программирование - функции радикально упрощаются и легко перестраиваются для более легкого по сравнению с ООП - повторного использования.
    
    Вычисления, которые используют чистые функции - легко масштабируются на несколько процессов без опасения возникновения проблем с ресурсами.
    
    Минус ФП - это чрезмерная эксплуатация функциональных подходов, что иногда может привезти к снижению читабельности кода - так как конечный код получается более абстрактным, кратким и менее конкретным.
    
    Некоторые общие идиомы ФП - могут вызывать трудности у начинающих разработчиков. Концепции ФП - описываются идиомами и обозначениями из λ (лямбда) исчислений и теорией категорий, требующих для понимания - знания основ в этих областях.
    
    - ООП
    
    Если говорить о плюсах ООП - то это простоя для понимания концепция объектов и методов вызова.
    
    ООП стремится использовать императивный стиль нежели декларативный, который читается как прямой набор машинных инструкций.
    
    Минусы ООП - это как правило зависимость от общих состояний - объекты и их поведение связаны с одной сущностью, к которой может-быть получен доступ - любым кол-вом функций в неопределенном порядке - что в конечном итоге может привезти к непредсказуемому поведению.
    
- ==[Разница между монолитной и микросервисной архитектурами?](https://youtu.be/70VnuTXi4Wk?t=436)==
    
    - Монолитная архитектура
    
    Монолитная архитектура рассматривается - как традиционный метод разработки приложений. Приложение в монолитной архитектуре разрабатывается как единый пакет.
    
    Монолитная архитектура означает, что приложение написано - как единый связный блок кода, чьи компоненты спроектированы для совместной работы и использования общих ресурсов.
    
    То есть это единый компонент, с которым работает пользователь и ресурсы которого могут использовать друг друга.
    
    - Микросервисная архитектура
    
    Микросервисная архитектура подразумевает - что приложение состоит из множества небольших независимых под приложений, каждая из которых способна работать с собственными ресурсами и потенциально на большом кол-ве отдельных машин.
    
    Другими словами микросервис - это небольшая программа, запущенная на своем сервере и работающая только над одним типом задач.
    
    Например:
    
    - сервис - авторизации, который принимает на вход логин и пароль и далее решает - давать пользователю доступ в систему или нет
    - сервис - отправки сообщений
    
    ![[Untitled 4 7.png|Untitled 4 7.png]]
    
- ==[Плюсы и минусы монолитной и микросервисной архитектур?](https://youtu.be/70VnuTXi4Wk?t=506)==
    
    - Монолитная
    
    Одним из основных преимуществ монолитной архитектуры является то - что большинство приложений имеют по сути общие нюансы: логирование, ограничение скорости, безопасность.
    
    В монолитном приложении для каждого компонента - их проще решать.
    
    Минусы такого подхода заключаются в том, что так как все компоненты тесно связаны друг с другом - по мере развития приложения становится труднее его понимать и поддерживать, то есть возникает плохая масштабируемость.
    
    И как следствие - практически полная невозможность использовать компоненты - изолированно, а также появляется много неочевидных зависимостей и побочных эффектов.
    
    - Микросервисная
    
    Что касается плюсов микросервисной архитектуры - то зачастую она лучше организована, так как каждый компонент выполняет свою задачу и работает независимо от других компонентов.
    
    Приложение на основе таких независимых компонентов - также проще изменять и конфигурировать.
    
    В долгосрочной перспективе - микросервисы выигрывают именно за счет лучшего масштабирования.
    
    Однако минусы у микросервисов - тоже есть. При создании нового микросервиса может появится много внезапных проблем, которые не ожидались при проектировании.
    
    Для монолитного приложения - можно использовать промежуточное программное обеспечение или Middlwares - для решения различных сквозных проблем без особых трудозатрат.
    
    При микросервисной архитектуре - либо потребуются дополнительные расходы на отдельные модули для каждой сквозной проблемы, либо их нужно инкапсулировать на другом уровне обслуживания, через который проходит весь трафик.
    
    Также микросервисы часто развертываются в собственных виртуальных машинах или контейнерах, что приводит к быстрому увеличению числа конфликтов по виртуальным ресурсам.
    
- ==[Какие принципы можно использовать вместе с наследованием?](https://youtu.be/XtQPrt8G0n8?t=119)==
    
    Есть еще 3 важных принципа ООП, которые можно использовать совместно с наследованием:
    
    - делегация - перепоручение задачи от внешнего объекта к внутреннему
    - композиция - включение объектом-контейнером - объекта-содержимого и управлением его поведением, причем последний не может существовать вне первого
    - агрегация - включение объектом-контейнером - ссылки на объект-содержимое, при уничтожении первого - последний продолжает существование
- ==[Какие ещё принципы кроме SOLID вы знаете?](https://youtu.be/XtQPrt8G0n8?t=156)==
    
    SOLID - это основной принцип объектно-ориентированного программирования, однако помимо него также есть принципы:
    
    - DRY/DIE (”Don't repeat yourself” или “не повторяйся”)/(”Duplication Is Evil” или “дублирование это зло”) - принцип заключается в том, что нужно избегать повторений одного и того же кода. Лучше использовать универсальное свойство и функции.
    - KISS (”Keep it simple stupid” или “не усложняй”) - смысл заключается в том, что стоит делать максимально простую и понятную архитектуру, применять шаблоны проектирования и не изобретать велосипед.
    - YAGNI (”You Aren't Gonna Need It” или “вам это не понадобится”) - его суть в том, чтобы реализовывать только поставленные задачи и отказаться от избыточного функционала.
    - API (”Avoid Premature Optimization” или “избегайте преждевременной оптимизации”) - эта практика призывает разработчиков не оптимизировать код до того, как это необходимость будет доказана. Преждевременная оптимизация может привести к задержкам в коде и следовательно увеличит затраты времени на вывод функций на рынок.
- ==[Что такое дескрипторы свойств объектов?](https://youtu.be/XtQPrt8G0n8?t=237)==
    
    Дескриптер - это объект, который описывает поведение свойства.
    
    А дескриптеры - это поля данного объекта - они позволяют описать, как будет вести себя свойство при выполнении определенных операций на ним. (Например чтение или запись)
    
    У каждого свойства есть 6 основных дескриптеров:
    
    - value - значение свойства
    - writable - если установлен true, то значение свойства можно изменять
    - configurable - если установлен true, то свойство можно перезаписать с помощью новых вызовов Object.defineProperties()
    - enumerable - если установлен true, то свойство будет перечисляться в цикле for in и при использовании метода Object.keys()
    - get() - функция, которая будет вызвана при запросе к свойству
    - set() - функция, которая будет вызвана при записи свойства
    
    2 последних дескриптера еще называют - геттер и сеттер.
    
    Получить доступ к изменению дескриптеров - можно только, используя функцию Object.defineProperties(), которая:
    
    - первым аргументом - принимает объект, в которое будет записано свойство
    - вторым - название свойства
    - третьим - объект, содержащий необходимые дескриптеры
- ==[В чем заключаются особенности геттеров и сеттеров?](https://youtu.be/XtQPrt8G0n8?t=315)==
    
    К основным особенностям геттеров и сеттеров можно отнести следующие:
    
    ![[Untitled 5 4.png|Untitled 5 4.png]]
    
- ==[Что такое статический метод класса (](https://youtu.be/G4iYlbilozM?t=641)====[`static`](https://youtu.be/G4iYlbilozM?t=641)====[)? Как осуществляется его вызов?](https://youtu.be/G4iYlbilozM?t=641)==
    
    Свойства и методы называются статическими, если они не привязаны к конкретному экземпляру класса и имеют одинаковое значение вне зависимости от того какой экземпляр ссылается на них.
    
    Данные свойства и методы внутри класса обозначаются специальным словом static.
    
- ==[Разница между композицией и наследованием?](https://youtu.be/GZUy2i6QN7o?t=29)==
    
    Наследование - это концепция объектно-ориентированного программирования - когда один класс наследует поля и методы другого класса. Это может-быть полезным - для обеспечения возможности повторного использования кода.
    
    Композиция - это также концепция ООП, только вместо наследования свойств базового класса - расширяемый класс ссылается на экземпляры другого класса.
    
    Наследование предполагает тесную взаимосвязь между компонентами. Производные компонента - должны наследовать свойства базового компонента - что сильно усложняют модификацию конкретного компонента.
    
    Композиция же предполагает наследование поведения, а не свойств - это существенно облегчает процесс добавления новых свойств в конкретный компонент.
    
    Компоненты по возможности должны быть переиспользуемыми - такая тесная связь наследующих компонентов - делает эти компоненты зависящими от специфики реализации приложения, в котором они используются.
    
    Композиция делает связи между слабыми компонентами - что повышает их автономность.