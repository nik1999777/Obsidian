  

- ==[Что такое HTTP?](https://youtu.be/w-vUj0gHGgg?t=422)==
    
    HTTP (HyperText Transfer Protocol — «протокол передачи гипертекста») - это прикладной протокол для передачи гипертекстовых документов по типу HTML
    
    В настоящее время используется для передачи произвольных данных.
    
    Создан он в основном для связи между веб-браузерами и веб-серверами. (Хотя в настоящее время может использоваться и для других целей)
    
    Все программное обеспечение для работы протокола разделяется на 3 категории:
    
    - клиент (непосредственно потребитель услуг)
    - сервер (это поставщик услуг)
    - прокси или посредник (используется для выполнения транспортных служб)
- ==[Из чего состоит HTTP-запрос?](https://youtu.be/w-vUj0gHGgg?t=483)==
    
    HTTP запрос содержит следующие элементы:
    
    - http метод (GET, POST, PUT, DELETE и т д.) - он помогает определить какой тип операции хочет выполнить пользователь
    - путь к ресурсу
    - в запросе указывается версия http-протокола
    - различные заголовки, которые отправляют дополнительную информацию на сервер
    - а также в запросе может быть тело, которое содержит информацию
- ==[Какие методы может иметь HTTP-запрос?](https://youtu.be/G4iYlbilozM?t=419)==
    
    HTTP определяет множество методов запроса, которые указывают какое именно действие хочет произвести пользователь.
    
    Можно выделить 9 основных методов:
    
    - GET - запрос на получение данных (запросы с использованием этого метода могут только извлекать данные)
    - POST - используется для отправки данных на определенный ресурс
    - PUT - заменяет все текущие представления ресурса - данными запроса, используется для редактирования
    - DELETE - запрос на удаление указанных данных
    - HEAD - запрашивает данные аналогично GET, но без тела ответа
    - CONNECT - устанавливает туннель к серверу или определенному ресурсу
    - TRACE - выполняет вызов возвращаемого тестового сообщения с ресурса
    - PATCH - используется для частичного изменения ресурса
    - OPTIONS - используется для описания параметров соединения с ресурсом
- ==[Что такое HTTP cookie? Для чего они используются?](https://youtu.be/G4iYlbilozM?t=488)==
    
    HTTP - это протокол без сохранения состояния. А это значит, что каждая пара: запрос ответ - не связана с предыдущим запросом и ответом.
    
    Иногда нам нужно запомнить аутентификацию пользователя или хранить данные корзины с товаром.
    
    Поэтому для хранения такой информации используются HTTP cookie.
    
    HTTP cookie - это небольшой фрагмент данных, отправляемых сервером на браузер пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу.
    
    cookie могут использоваться для:
    
    - управления сеансом (это логины, корзины для виртуальных покупок)
    - мониторинга (отслеживание поведения пользователя)
    - персонализация (это пользовательские предпочтения)
    
    Получив HTTP запрос вместе с ответом - сервер может отправить заголовок Set-Cookie
    
- ==[Что такое](https://youtu.be/yvOXvZ8aEFo?t=237)== ==[`WebSocket`](https://youtu.be/yvOXvZ8aEFo?t=237)====[? В чем принцип его работы?](https://youtu.be/yvOXvZ8aEFo?t=237)==
    
    WebSocket - это протокол, который обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение.
    
    Данные передаются по этому соединению в обоих направлениях в виде пакетов без разрыва соединения и дополнительных http запросов.
    
    Чтобы открыть WebSocket соединение нужно создать объект new WebSocket, указав в url адресе специальный протокол ws.
    
    Как только создан объект WebSocket - на его событие можно подписаться и прослушивать их.
    
    Есть 4 основных события:
    
    - onopen - соединение установлено
    - onmessage - получение данных
    - onerror - ошибка
    - onclose - соединение закрыто
- ==[Разница между](https://youtu.be/xZLxdts7ZW4?t=31)== ==[`HTTP`](https://youtu.be/xZLxdts7ZW4?t=31)== ==[и](https://youtu.be/xZLxdts7ZW4?t=31)== ==[`HTTPS`](https://youtu.be/xZLxdts7ZW4?t=31)====[?](https://youtu.be/xZLxdts7ZW4?t=31)==
    
    HTTP - это наиболее широко используемый протокол в интернете. Он является стандартом для запросов и ответов клиентов и серверов. Он используется для передачи гипертекста с сервера на локальный браузер.
    
    HTTPS - это канал HTTP, цель которого безопасность. Проще говоря - это безопасная версия HTTP. То есть к HTTP добавляется уровень SSL.
    
    SSL требуется для деталей шифрования.
    
    Основные функции протоколы HTTPS можно разделить на 2 типа:
    
    - установить информационный канал для обеспечения безопасности данных
    - подтвердить подлинность веб сайта
    
    HTTP запрос не зашифрован, а HTTPS - зашифрован.
    
    HTTP port - 80, HTTPS port - 443
    
- ==[Разница между Long-Polling, Websockets и Server-Sent Events?](https://youtu.be/xZLxdts7ZW4?t=98)==
    
    Все 3 подхода начинаются одинаково:
    
    - Клиент запрашивает веб страницу сервера, используя обычный http
    - Далее происходит выполнение JS. Клиент получает запрошенную веб страницу и выполняет JS на странице, которая запрашивает
    
    В Websockets - server и client после установки связи могут отправлять друг другу сообщения, когда доступны новые данные причем с обеих сторон.
    
    А в Long Polling и Server-Sent Events - server не сразу отвечает запрошенной информацией, а ждет пока не появится новая. Когда появляется новая информация - сервер отвечает этой новой информацией. Клиент получает ее и немедленно отправляет другой запрос на сервер, перезапуская процесс.
    
    С помощью Websockets можно подключаться к серверу из другого домена, также можно использовать сторонней сервер вебсокетов. Таким образом, достаточно реализовать только клиентскую часть.
    
    В Server-Sent Events трафик идет в реальном времени от сервера к клиенту. А соединение сервера из других доменов возможны только при правильных настройках CORS.
    
    ![[Untitled 89.png|Untitled 89.png]]
    
- ==[Разница между](https://youtu.be/ngyOYuTrUk8?t=29)== ==[`PUT`](https://youtu.be/ngyOYuTrUk8?t=29)====[и](https://youtu.be/ngyOYuTrUk8?t=29)== ==[`POST`](https://youtu.be/ngyOYuTrUk8?t=29)====[запросами?](https://youtu.be/ngyOYuTrUk8?t=29)==
    
    - PUT запросы приводят - к замене целевого ресурса на данные передаваемые в запросе.
    
    Его можно использовать для обновления содержимого существующего ресурса или для создания нового ресурса.
    
    - POST запросы приводят - к специфической для ресурса обработки данных передаваемых в запросе.
    
    Их можно использовать для выполнения различных действий - в том числе для создания различных ресурсов для выгрузки файлов на сервер или для отправки формы.
    
    - Еще одно отличие между PUT и POST запросами заключается в том - что PUT запросы можно выполнять многократно, получая один результат. А POST запросы - нет.
    
    То есть - если PUT, в котором передаются одни и те же данные и которые выполняются по одному и тому же url - будет выполнен несколько раз - это равносильно однократному выполнению этого запроса.
    
    Многократное выполнение POST запроса - не эквивалентно его однократному выполнению, так как несколько таких запросов могут привести к созданию нескольких объектов на сервере.
    
- ==[Что такое безопасные (Secure) и HttpOnly cookies?](https://youtu.be/ovV8GhIkzBE?t=158)==
    
    Безопасные cookie отсылаются на сервер только если запрос выполняется по протоколу SSL и HTTPS.
    
    Однако важные данные никогда не следует передавать или хранить в cookies. Поскольку сам их механизм весьма уязвим в отношении безопасности, а флаг secure никакого дополнительного шифрования или средств защиты не обеспечивает.
    
    Начиная с 52 версии в Chrome и FIrefox - незащищенные сайты, то есть сайты с протоколом http не могут создавать куки с флагом secure.
    
    Cookie HttpOnly - недоступны из JS через свойство document cookie и через HTML http request, а также request api, что помогает избежать межсайтового скриптинга (XSS).
    
    Устанавливать этот флаг можно для тех cookie, которым не требуется обращаться через JS.
    
    В частности если cookie используется только для поддержки сеанса - то в JS они не нужны - в этом случае стоит устанавливать флаг - HttpOnly.
    
    ![[Untitled 1 30.png|Untitled 1 30.png]]
    
- ==[Что такое Content Security Policy (CSP)?](https://youtu.be/ovV8GhIkzBE?t=231)==
    
    Content Security Policy (политика безопасноти контента) - это http header, который позволяет операторам сайта - детально контролировать откуда могут быть загружены ресурсы на их сайт.
    
    Использование данного заголовка - эта лучший способ, чтобы предотвратить уязвимости межсайтового скриптинга (XSS) и атаки внедрения данных.
    
    CSP - является обязательным для всех новых вебсайтов и настоятельно рекомендуется для всех существующих сайтов с высоким уровнем риска.
    
    В случае если сайт не предоставляет CSP заголовки - браузер в свою очередь будет использовать стандартные правила по ограничению домена.
    
    Настройка CSP включает в себя - добавление на страницу http заголовка - Content-Security-Policy и его настройку в соответствии со списком доверенных источников из которых пользователь может получать контент.
    
- ==[Что такое CORS?](https://youtu.be/w-vUj0gHGgg?t=360)==
    
    Cors (Cross-origin resource sharing) — технология современных браузеров, которая позволяет предоставить веб-страницам доступ к ресурсам другого домена.
    
    CORS - это система, состоящая из отправки HTTP заголовок, которые определяют: заблокировать или выполнить запрос к ограниченному ресурсу на веб-странице из другого домена, отличного от домена происхождения запрашиваемого ресурса.
    
    Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.
    
    В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.
    
- ==[Разница между протоколами](https://youtu.be/trriSYNrHw4?t=234)== ==[`TCP`](https://youtu.be/trriSYNrHw4?t=234)== ==[и](https://youtu.be/trriSYNrHw4?t=234)== ==[`UDP`](https://youtu.be/trriSYNrHw4?t=234)====[?](https://youtu.be/trriSYNrHw4?t=234)==
    
    При разработке веб-приложения важно учитывать множество факторов. Один из таких факторов - это то как приложение будет взаимодействовать с браузером пользователя.
    
    Передача данных между сервером и браузером опирается на протоколы транспортного уровня - то есть TCP И UDP.
    
    Знания о там как они работают - позволяет оптимизировать передачу данных и улучшить пользовательский опыт.
    
    На практике TCP используется в случаях - когда необходимо гарантировать целостность и порядок приходящих данных в ущерб скорости их передачи. Эта важно для обмена файлами (Например запрос на получение файлов разметки HTML или стилей CSS).
    
    UDP используется - если скорость важнее соблюдения подобных требований (Например доставка потокового аудио или видео). Гарантий доставки и порядка получения данных в этом случае - нет.
    
    Таким образом можно сделать вывод - что тип используемого протокола в первую очередь будет зависеть от данных, которые нужно отправить.
    
- ==[Как работает](https://youtu.be/trriSYNrHw4?t=178)== ==[`JSONP`](https://youtu.be/trriSYNrHw4?t=178)====[?](https://youtu.be/trriSYNrHw4?t=178)==
    
    JSONP - это часто используемый способ для обхода политики ограничения домена в браузерах.
    
    Потому что AJAX запросы с текущей страницы к серверу, находящемуся в другом домене - запрещены. Эта так называемая политика same-origin policy.
    
    JSONP работает, отправляя запросы к серверу в другом домене через тэг <script> и обычно с параметром запроса в виде callback-функции. Затем сервер оборачивает данные внутри функции и возвращает их клиенту. У клиента должна быть своя функция с глобальной областью видимости, и эта функция будет выполнена клиентом, когда будет получен ответ с сервера из другого домена.
    
    Основной недостаток JSONP - это то что он может-быть небезопасным, поэтому нужно быть уверенным в поставщике данных JSONP.
    
    ![[Untitled 2 20.png|Untitled 2 20.png]]
    
- ==[Что такое IndexedDB в браузере? Преимущества IndexedDB?](https://youtu.be/V-m0sQ-hW58?t=653)==
    
    InexedDB - это низкоуровневый API для хранения на клиенте значительного кол-ва структурированных данных, а также немного более сложное и проработанное решение для хранения данных в браузере, чем например localStorage или sessionStorage.
    
    По своей сути - это объектно-ориентированная б/д, основанная на JS и которая позволяет легко сохранять и извлекать данные - проиндексированные по ключу.
    
    Использование InexedDB является более сложным в сравнении с остальными методами хранения данных в браузере. Перед тем как создавать, читать, обновлять, удалять какие-либо данные - нужно сначала открыть б/д и создать хранилище, аналогичное таблицам в б/д.
    
    Если говорить вообщем - то эта мини б/д в браузере.
    
    Преимуществом InexedDB можно отнести следующее:
    
    - могут обрабатывать более сложные структуры данных
    - могут работать с разными б/д и таблицами внутри каждой б/д
    - больший объем хранения, больше контроля по взаимодействию с хранилящем
    
    ![[Untitled 3 10.png|Untitled 3 10.png]]
    
- ==[Что такое Service Workers?](https://youtu.be/V-m0sQ-hW58?t=727)==
    
    Service Workers по сути действуют как proxy servers, которые находятся между веб-приложениями, браузером и сетью - если они доступны.
    
    Если говорить простыми словами - это сценарий, который запускается браузером в фоновом режиме, он никак не связан с веб-страницой или DOM. И представляет функции из коробки, такие как обработка сетевых запросов, push-уведомления и фоновая синхронизация.
    
    Service Workers предназначены для обеспечения эффективного взаимодействия в автономном режиме - перехвата сетевых запросов и принятия соответствующих мер в зависимости от доступности сети и наличия обновленных данных на сервере.
    
    Если говорить просто - то Service Workers обеспечивают возможность работы оффлайн. Также они являются посредником между клиентом и сервером и пропускают через себя все запросы к серверу. С их помощью можно перехватывать все запросы налету.
    
    Service Workers запускается в контексте Worker, поэтому не имеют доступа к DOM и работают в потоке, отличным от основного потока JS, на котором работает приложение. Поэтому они являются не блокирующими и полностью асинхронными.
    
    Работают Service Workers - только по https из-за соображений безопасности.
    
- ==[Что такое Web Workers?](https://youtu.be/V-m0sQ-hW58?t=811)==
    
    Web Workers предоставляют простое средство для запуска скриптов в фоновом режиме или рабочем потоке. Рабочий поток может выполнять задачи, не мешая пользовательскому интерфейсу.
    
    После создания - Web Worker может отправлять сообщения в JS код, который его создал, отправляя сообщения через обработчик событий, указанный этим кодом и наоборот.
    
    Web Worker - это объект, созданный с помощью конструктора, который запускает именованный JS файл. Этот файл содержит код, который будет выполняться в рабочем потоке.
    
    Объекты Web Workers не запускаются в другом глобальном контексте, отличающимся от текущего.
    
    Данные между Web Workers и главным потоком передаются через систему сообщений. Обе стороны передают свои сообщения, используя метод - postMessage и отвечают на сообщения при помощи обработчика событий - onMessage. При этом сообщение хранится в атрибуте - data, событие - message, а данные копируются, а не делятся. В свою очередь объект - Web Workers могут создавать новые объекты Web Workers и так до тех пор, пока все работает в рамках текущей страницы.
    
    (Web Workers это механизм, который **позволяет скрипту выполняться в фоновом потоке, который отделен от основного потока веб-приложения**. Преимущество заключается в том, что ресурсоёмкие вычисления могут выполняться в отдельном потоке, позволяя запустить основной (обычно пользовательский) поток без блокировки и замедления.)
    
- ==[Что такое History API в браузере?](https://youtu.be/XtQPrt8G0n8?t=352)==
    
    History API дает доступ к управлению историй браузера в рамках текущей сессии.
    
    Браузер создает новую сессию, когда пользователь открывает новую вкладку или новое окно браузера.
    
    С помощью History API можно переходить по истории вперед, назад и управлять содержимым истории.
    
    Доступ к History API осуществляется с помощью объекта window history.
    
    Основные методы это:
    
    - history.back() - перемещает пользователя по истории на страницу назад
    - history.forward() - перемещает пользователя по истории на страницу вперед
    - history.go() - универсальный метод для перемещения по истории вперед или назад
    - history.pushState() - добавляет новую запись в истории сессии
    - history.replaceState() - изменяет текущую запись в истории сессии
- ==[Что такое веб-хранилище (web storage)?](https://youtu.be/XtQPrt8G0n8?t=406)==
    
    Web storage - это интерфейс, позволяющий хранить данные в виде пары ключ значение - локально, то есть в браузере пользователя. Причем делать это более удобным способ, чем при использовании cookie.
    
    Web storage представляет 2 основных механизма хранения данных:
    
    - это локальное хранилище (localStorage), предназначенное для хранения данных текущего пользователя - неограниченное кол-во времени
    - и сессионное хранилище (sessionStorage) - служит для хранения данных на протяжении текущей сессии, то есть при закрытии вкладкой браузера - данные будут потеряны
- ==[Что такое BOM?](https://youtu.be/XtQPrt8G0n8?t=448)==
    
    BOM (Browser Object Model или объектная модель браузера) - это модель, которая позволяет JS взаимодействовать с браузером.
    
    Данная модель включает в себя такие объекты как:
    
    - history
    - navigator
    - location
    - screen
    - XMLHttpRequest
    - и т д
    
    Другими словами BOM - это дополнительные объекты, предоставляемые браузером, чтобы работать совсем, кроме документа.
    
    Также стоит обратить внимание - что BOM не стандартизирован, поэтому ее реализация может отличаться в разных браузерах.
    
- ==[Разница между](https://youtu.be/nvktMVFM0_M?t=604)== ==[`cookie`](https://youtu.be/nvktMVFM0_M?t=604)====[,](https://youtu.be/nvktMVFM0_M?t=604)== ==[`sessionStorage`](https://youtu.be/nvktMVFM0_M?t=604)== ==[и](https://youtu.be/nvktMVFM0_M?t=604)== ==[`localStorage`](https://youtu.be/nvktMVFM0_M?t=604)====[?](https://youtu.be/nvktMVFM0_M?t=604)==
    
    Все 3 технологии используются для хранения данных на клиенте.
    
    Сами данные хранятся в виде ключ - значение в формате строки.
    
    ![[Untitled 4 6.png|Untitled 4 6.png]]