  

- [Что такое React?](https://youtu.be/7TvS0iKR3_c?t=638)
    
    React - это JS библиотека с открытым исходным кодом, разработанная компанией facebook.
    
    Предназначена она для создания пользовательских интерфейсов.
    
    Основная философия React - это компонентный подход, то есть весь интерфейс может-быть разбит на минимальные функционирующие компоненты.
    
    Переиспользуя такие компоненты в других местах приложения - можно в разы ускорить разработку.
    
- [Перечислите особенности React?](https://youtu.be/7TvS0iKR3_c?t=671)
    
    Особенности:
    
    - Virtual DOM - использование виртуального DOM, вместо реального. Делается это - потому что манипуляции с реальным DOM деревом - тяжеловесны, а виртуальный DOM - это по сути объект на основании которого строится реальный DOM
    - SSR (Server Side Rendering) - поддержка рендеринга на стороне сервера. Идея в том, что используя React - вся разметка отрисовывается внутри одного корневого div элемента, а это не очень хорошо для SEO. В связи с тем- была добавлена поддержка SSR. В этом случае первоначальная разметка строится на сервере и полностью передается и отрисовывается на клиенте.
    - One-way direction data flow - React придерживается принципа однонаправленного потока данных. Другими словами все данные передаются от корневых компонентов во вложенные.
    - Reusable components - использование переиспользуемых компонентов для построения пользовательского интерфейса
- [Что такое Virtual DOM? Как он работает с React?](https://youtu.be/7TvS0iKR3_c?t=740)
    
    Главная проблема DOM - это что он никогда не был рассчитан для создания динамического пользовательского интерфейса.
    
    Даже на небольших веб страницах располагается тысяча DOM узлов. Поэтому любая операция - занимает длительный временной интервал.
    
    React предложил альтернативный путь работы с DOM деревом - это Virtual DOM.
    
    Представляет оно из себя обычный объект, который по сути является легковесной копией реального DOM деревом.
    
    Поэтому если в компоненте происходят какие-то изменения, которые ведут к перерисовке - то сначала происходит сравнение старой версии Virtual DOM и новой.
    
    После нахождения разницы - изменения применяются к реальному DOM дереву.
    
    Этот процесс называется алгоритмом согласования.
    
    В результате перерисовывается не вся страница, а лишь часть элементов, которых затронуло изменение.
    
- [Для чего нужен атрибут](https://youtu.be/yvOXvZ8aEFo?t=526) [`key`](https://youtu.be/yvOXvZ8aEFo?t=526) [при рендере списков?](https://youtu.be/yvOXvZ8aEFo?t=526)
    
    Ключи (key) помогают React определять какие элементы были изменены, добавлены или удалены.
    
    Их необходим указывать, чтобы React мог сопоставлять элементы массива с течением времени и помочь библиотеке точно определить то место, где произошло изменение.
    
    Чаще всего ключи применяются при рендеринге однотипных списков.
    
- [Что такое](https://youtu.be/yvOXvZ8aEFo?t=581) [`PureComponent`](https://youtu.be/yvOXvZ8aEFo?t=581)[?](https://youtu.be/yvOXvZ8aEFo?t=581)
    
    React PureComponent похож на стандартный React Component.
    
    Отличия заключается в том, что React Component не реализует метод shouldComponentUpdate().
    
    А React PureComponent реализует его поверхностным сравнением props-ов и состояний.
    
    Если метод render у React Component - всегда рендорит одинаковый результат при одних и тех же props-ах и состояниях, то для повышения производительности в некоторых случаях - используется React PureComponent.
    
    Метод shouldComponentUpdate() внутри React PureComponent - делает только поверхностное сравнение объектов и если props-ы или состояния не изменяются - то дополнительный переренодринг компонента не произойдет.
    
    Однако PureComponent - не подойдет, если props-ы и состояния имеют сложную структуру. В этом случае при поверхностной проверке - рендер может и не произойти в тот момент, когда он действительно нужен.
    
- [Что такое Компонент высшего порядка (Higher-Order Component / HOC)?](https://youtu.be/yvOXvZ8aEFo?t=637)
    
    Компоненты высшего порядка - это продвинутая техника переиспользования компонентной логики.
    
    Компоненты высшего порядка - эта функция, которая принимает другой компонент, расширяет его функциональность (не изменяя его исходный код) и возвращает новый компонент.
    
- [Разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?](https://youtu.be/yvOXvZ8aEFo?t=684)
    
    В HTML такие элементы как input, textarea и select - обычно сами управляют своим состоянием и обновляют его, когда пользователь вводит данные.
    
    В React изменяемые состояния - обычно содержатся в свойстве компонента state и обновляется через вызов setState.
    
    Либо при использовании хука - useState().
    
    - Неуправляемые компоненты опираются на DOM в качестве источника данных. Другими словами - это обычные HTML элементы, которые обновляются динамически, инкапсулируют данные внутри себя и никак не связаны с React.
    - В управляемом компоненте с каждым изменением состояния - связана функция обработчик. А сами обновляемые данные хранятся внутри свойства компонента - state. Благодаря этому механизму данные, которые хранятся внутри управляемых элементов могут быть доступны за их пределами и с ними можно легко взаимодействовать.
- [Методы жизненного цикла компонента в React?](https://youtu.be/RpcB5jnJvcI?t=35)
    
    ![[Untitled 97.png|Untitled 97.png]]
    
    - constructor - это конструктор компонента, который вызывается до того, как компонент будет смонтирован.
    - componentDidMount() - вызывается сразу после монтирования компонента. Это отличное место для создания сетевых запросов и настройки подписок компонента на различные события. А также в этом методе должны происходить действия для работы которых требуется наличие DOM узлов.
    - сomponentDidUpdate() - вызывается сразу после обновления. Метод позволяет работать с DOM при обновления компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих props-ов с предыдущими.
    - componentWillUnmount() - вызывается непосредственно перед размонтированием компонента. В нем выполняются необходимые сбросы: отмена таймера, а также сетевых запросов и подписок, созданных в componentDidMount().
    - shouldComponentUpdate() - вызывается перед рендором, когда получает новые props-ы или состояния. Используется для повышения производительности, чтобы избежать лишних перерисовок.
    - render() - это единственный обязательный метод в компоненте. Предназначен он для возврата разметки.
    - componentDidCatch() - используется для логирования ошибок. Вызывается после возникновения ошибки у компонента потомка.
- [Стадии жизненного цикла компонента в React?](https://youtu.be/RpcB5jnJvcI?t=173)
    
    Жизненный цикл компонента состоит из 3-х основных стадий:
    
    - монтирование - компонент готов к встраиванию в браузерный DOM.
        
        Эта стадия охватывает инициализацию в конструктор, а также методы жизненного цикла:
        
        - getDerivedStateFromProps
        - render
        - componentDidMount
    - обновление - на данной стадии компонент обновляется, либо из-за получения новых props-ов, либо из-за обновления состояния.
        
        Эта стадия охватывает такие методы жизненного цикла как:
        
        - getDerivedStateFromProps
        - shouldComponentUpdate
        - render
        - getSnapshotBeforeUpdate
        - componentDidUpdate
    - размонтирование - на этой последней стадии компонент удаляется из браузерной DOM.
        
        Она включает метод жизненного цикла:
        
        - componentWillUnmount
    
    Следует отметить, что в React также имеются особые стадии применения изменений к DOM:
    
    - render (компонент рендерится без каких-либо побочных эффектов. На данной стадии React может приостанавливать, прерывать или перезапускать рендеринг)
    - pre-commit - перед обновлением компонента есть момент, когда React читает DOM через getSnapshotBeforeUpdate
    - commit - React изменяет DOM и выполняет завершающие методы жизненного цикла:
        - componentDidMount - при монтирование
        - componentDidUpdate - при обновлении
        - componentWillUnmount - при размонтировании
- [Что такое React Reconciliation?](https://youtu.be/RpcB5jnJvcI?t=271)
    
    Это механизм сравнения, посредством которого React обновляет DOM дерево.
    
    Когда состояние компонента изменяется - React должен рассчитать необходимость обновления DOM.
    
    Это делается путем создания Virtual DOM и сравнения его с текущим.
    
    В этом контексте - виртуальный DOM будет содержать новое состояние компонента.
    
    При сравнении 2-х деревьев первым делом React сравнивает 2 корневых элемента.
    
    Всякий раз когда корневые элементы имеют различные типы - React уничтожает старое дерево и строит новое с нуля.
    
    При сравнении 2-х React DOM элементов одного типа - React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов лежачий DOM узел и обновляет только измененные атрибуты.
    
    По умолчанию при рекурсивном обходе дочерних элементов DOM узла - React проходит по обоим спискам потомков одновременно и создает мутация, когда находит отличия.
    
    Когда у дочерних элементов есть ключи - React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева.
    
- [Что такое портал (](https://youtu.be/RpcB5jnJvcI?t=342)[`Portal`](https://youtu.be/RpcB5jnJvcI?t=342)[)?](https://youtu.be/RpcB5jnJvcI?t=342)
    
    Это компонент, который рендерит свое содержимое в произвольную часть DOM дерева.
    
    Такое поведение позволяет отображать элементы за пределами блоков (например со свойством overflow: hidden) и при этом минимально менять дерево компонентов.
    
    И самые первые кейсы использования порталов, которые приходят на ум - это модальные или диалоговые окна.
    
    В большинстве своем они не зависят от текущей разметки и появляются поверх любого layota.
    
    Создается портал с помощью метода createPortal() - данный метод принимает 2 аргумента:
    
    - children (или разметка, которую будет принимать компонента портала)
    - созданный DOM элемент
- [Что такое контекст (](https://youtu.be/RpcB5jnJvcI?t=390)[`Context`](https://youtu.be/RpcB5jnJvcI?t=390)[)?](https://youtu.be/RpcB5jnJvcI?t=390)
    
    Это способ передачи данных через дерево компонентов без необходимости передавать свойство вручную на каждом уровне.
    
    В стандартном React приложении - данные передаются сверху вниз по иерархии элементов. (Или проще говоря от родителя к потомку через свойство props)
    
    Однако если представить, что свойство определенное на верхнем уровне - используется на нижнем (причем предположим через 2-3 уровня вложенности), то пробрасывать такое свойство через react компоненты - достаточно проблематично.
    
    Также ситуация может усложниться тем, что если пробрасывать сразу несколько свойств - то таким образом кол-во props-ов у компонентов верхнего уровня может-быть огромным.
    
    Обычно когда такие ситуации возникают - то подключается Redux и часть ответсвенности он берет на себя.
    
    Однако с версии React 16.3 был представлен механизм контекста.
    
    В этом случае, используя метод createContext() - создаются данные, которые нужно передать через несколько уровней. (Это может-быть строка, функция, объект)
    
    А далее эти данные с помощью специальных оберток Consumer и Provider - можно получить и использовать в целевом компоненте.
    
    С версии React 16.8 для аналогичной задачи используется хук - useContext()
    
- [Что такое React хуки (Hooks)?](https://youtu.be/RpcB5jnJvcI?t=475)
    
    Хуки - это нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.
    
    По сути хуки - это функции с помощью которых можно подцепиться к состоянию и методом жизненного цикла из функционального компонента.
    
    Хуки не работают внутри классов и дают возможность использовать React вообще без классовых компонентов.
    
    К основным хукам можно отнести:
    
    - useContext - позволяет использовать контекст
    - useState - дает возможность на использование state
    - useEffect - по сути это аналог всех методов жизненного цикла
    - useRef - позволяет использовать ссылки
    - useReducer - хук для использования редъюсера
    - useLayoutEffect - аналогичен useEffect, но только он запускается синхронно после всех изменений в DOM дереве
    - useCallback - используется для возврата мемоизированного коллбэка, предназначен для повышения перфомонса и является аналогом shouldComponentUpdate()
    - useMemo - используется для возврата сохраненного значения, также предназначен для повышения перфомонса
    - useImperativeHandle - кастомизирует значение instance(экземпляра), которое предоставляется родитедем при использовании ref
    - useDebugValue - создает label для пользовательских хуков
    
    Помимо стандартного набора хуков, которые предоставляются самой библиотекой - можно создать и пользовательские хуки.
    
- [Что Такое](https://youtu.be/RpcB5jnJvcI?t=571) [`JSX`](https://youtu.be/RpcB5jnJvcI?t=571)[?](https://youtu.be/RpcB5jnJvcI?t=571)
    
    JXS расшифровывается как JS XML.
    
    Фактически - это новый диалект языка JS, который внедряет необработанный HTML шаблон внутрь кода JS.
    
    React использует этот формат для того, чтобы сделать код HTML более простым для чтения и записи.
    
    В нем есть некоторые несущественные ограничения:
    
    - он не поддерживает конструкцию if else
    
    А также особенности:
    
    - инлайновые функции
    - специфичное наименование HTML атрибутов
    - уникальный тэг для фрагмента
    
    JSX код - сам по себе не может быть прочитан браузером, поэтому изначально он должен быть переведен в JS с помощью Babel и Webpack.
    
- [Разница между состоянием(](https://youtu.be/RpcB5jnJvcI?t=621)[`state`](https://youtu.be/RpcB5jnJvcI?t=621)[) и пропсами(](https://youtu.be/RpcB5jnJvcI?t=621)[`props`](https://youtu.be/RpcB5jnJvcI?t=621)[)?](https://youtu.be/RpcB5jnJvcI?t=621)
    
    Состояние(state) - это объект содержащий некоторую информацию, которая может изменится с течением жизненного цикла компонента.
    
    State похоже на prop, но оно является приватным и полностью контролируется компонентом. (То есть оно недоступно для других компонентов, кроме того которому оно принадлежит и который его определяет)
    
    Props - это входные данные для компонента, то есть те которые он получает снаружи.
    
    Основное назначение props-ов в React - заключается в предоставлении компоненту следующего функционала:
    
    - передача данных компоненту
    - вызов изменения состояния
    - использование внутри метода - render
    
    Prop и state - являются обычными JS объектами. И несмотря на то, что они оба содержат информацию, которая используется при рендеринге компонента - функционал у них разный.
    
    Props - передаются компоненту подобно аргументам, передаваемым в функции. А state - управляется компонентом, как переменные объявленные внутри функции.
    
- [Что такое React Fiber?](https://youtu.be/RpcB5jnJvcI?t=689)
    
    React Fiber - это новый движок согласования. Изменение основного алгоритма в React 16.
    
    Основной задачей React Fiber является повышение производительности в таких областях как:
    
    - анимация
    - создание макета страницы
    - обработка жестов
    - возможность приостанавливать, прерывать или повторно запускать выполнение операций и предоставления приоритета определенным типом обновлений
    
    Его основная особенность - это Incremental rendering (Инкрементальный рендеринг).
    
    Incremental rendering - это возможность разделения процесса рендеринга на части и их объединение через различные фреймы.
    
- [Что такое фрагмент (](https://youtu.be/RpcB5jnJvcI?t=730)[`Fragment`](https://youtu.be/RpcB5jnJvcI?t=730)[)? Почему фрагмент лучше, чем](https://youtu.be/RpcB5jnJvcI?t=730) [`div`](https://youtu.be/RpcB5jnJvcI?t=730)[?](https://youtu.be/RpcB5jnJvcI?t=730)
    
    Fragment - это распространенный паттерн в React, который используется в компонентах возвращающих несколько элементов.
    
    Fragment позволяет группировать дочерние элементы без создания лишних DOM узлов. (Другими словами это специальный тэг JSX, который не отрисовывается внутри реального DOM дерева)
    
    Использование Fragment вместо пустого оборачивающего элемента на подобие div - лучше по нескольким причинам:
    
    - Fragment немного быстрее и используют меньше памяти (реальная польза от этого ощущается в очень больших и глубоких деревьях элементов
    - некоторые механизмы CSS (например flexbox и grid используют связь родитель-ребенок, поэтому добавление дополнительных div - может сломать макет страницы)
    - удобнее пользоваться инспектором DOM, так как оборачивающий фрагмент никак не отображается
- [Что такое синтетические события в React?](https://youtu.be/81yRgVQ1ciM?t=34)
    
    Синтетическое событие(Synthetic Event) - это кроссбраузерная оболочка для нативных событий браузера.
    
    То есть любые события с которыми работает React - являются не нативными, а всего лишь обертками.
    
    Данный API полностью аналогичен браузерному - stopPropagation и preventDefault. Поэтому особой разницы и незаметно.
    
    Однако синтетические события работают одинаково во всех браузерах, поэтому им не требуются никакие fullback-и или полифиллы.
    
- [Что такое React-ссылка (Ref)? Как создать ссылку?](https://youtu.be/81yRgVQ1ciM?t=69)
    
    Ссылки (Ref) - используются для получения ссылки на узел DOM дерева или экземпляр компонента в React.
    
    Если кратко, то Ref возвращает ссылку на элемент. Можно сказать, что это почти аналог метода getElementById().
    
    В самой документации React говорится о том, что в большинстве случаев - использование ссылок следует избегать, так как структура компонентов, их вложенность и передача данных между ними должны быть максимально простыми для понимания.
    
    Для того чтобы создать ссылку существует 2 варианта:
    
    - использование хука useRef()
    - применение метода createRef()
- [Разница между теневым (Shadow) и виртуальным (Virtual) DOM?](https://youtu.be/81yRgVQ1ciM?t=112)
    
    Оба варианта решают одну и ту же проблему - это оптимизация перфомонса (скорость загрузки страницы).
    
    А также оба создают - отдельный instance (экземпляр) реального DOM дерева.
    
    Но помимо всего эти концепции - абсолютно различны.
    
    Virtual DOM создает копию всего объекта DOM. А Shadow DOM создает небольшие части объекта DOM, имеющие собственную изолированную область действия для элемента.
    
    Shadow DOM - это браузерная технология спроектированная для ограничения области видимости переменных и CSS в веб компонентах.
    
    А Virtual DOM - это концепция, реализуемая некоторыми библиотеками JS поверх браузерных API. И по сути это представление реального DOM дерева, которое хранится в оперативной памяти.
    
- [Назовите преимущества использования React?](https://youtu.be/81yRgVQ1ciM?t=170)
    - повышение производительности приложения благодаря Virtual DOM
    - JSX облегчает написание и чтение кода
    - возможность рендеринга на стороне клиента, а также на стороне сервера
    - возможно относительно простой интеграции с фреймворками (поскольку React - это всего лиши библиотека)
    - возможность быстрого unit и интеграционного тестирования (JEST, React Testing Library)
    - декларативность
    - универсальность
    - компонентный подход
    - огромное комьюнити и куча библиотек уже с готовой реализации различных компонентов
- [Что такое условный рендеринг (Conditional Rendering)? Как его выполнить?](https://youtu.be/81yRgVQ1ciM?t=224)
    
    Условный рендеринг (Conditional Rendering) - это возможность отрисовки элементов разметки или компонента на основании входного условия.
    
    Другими словами - это своеобразная if else условие, которое помогает отрендорить разные варианты интерфейса.
    
    Указывается условный рендоринг внутри метода render. И из-за того, что синтаксис JSX не поддерживает конструкцию if else - выполнить его можно 2 доступными вариантами:
    
    - использование двойного амперса́нда &&
    - применение тернарного оператора
- [Что такое компонент-переключатель (Switching Component)?](https://youtu.be/81yRgVQ1ciM?t=265)
    
    Компонент-переключатель (Switching Component) - это компонент, который рендорит один из нескольких компонентов.
    
    Это своеобразный React pattern, который позволяет реализовать удобный механизм отрисовки нескольких компонентов на основании какого-нибудь условия.
    
    Основная идея - эта структура в виде объекта, которая содержит ключи и соответствующие им компоненты.
    
    Получая props-ы, компонент-переключатель вытягивает из них значение ключа - после чего по этому значению возвращает нужный компонент, которому с помощью spread - оператора передаются все props-ы.
    
- [Разница между](https://youtu.be/81yRgVQ1ciM?t=305) [`React`](https://youtu.be/81yRgVQ1ciM?t=305) [и](https://youtu.be/81yRgVQ1ciM?t=305) [`ReactDOM`](https://youtu.be/81yRgVQ1ciM?t=305)[?](https://youtu.be/81yRgVQ1ciM?t=305)
    
    Изначально 2 эти библиотеки были вместе, однако для обеспечения рендеринга в разных средах - команда React разделила основной пакет React с версии 0.14 на 2 независимые части:
    
    - React
    - ReactDOM
    
    И это стало позволять создавать компоненты, которые могут использоваться как веб так и в мобильных версиях приложения.
    
      
    
    Библиотека React содержит createElement, Component, Children и другие вспомогательные функции, связанные с элементами и компонентами.
    
    По сути это изоморфные (универсальные) элементы предназначенные именно для создания компонентов.
    
    ![[Untitled 1 38.png|Untitled 1 38.png]]
    
    ReactDOM - это пакет предоставляющий специальные для браузера методы, которые могут-быть использованы на верхнем уровне приложения для эффективного управления DOM элементами, имеющимися на странице.
    
    Он содержит такие методы как: render, findDOMNode, hydrate, createPortal и т д.
    
    ![[Untitled 2 28.png|Untitled 2 28.png]]
    
- [Разница между компонентом и контейнером?](https://youtu.be/81yRgVQ1ciM?t=370)
    
    Component (компонент)- это классовый или функциональный компонент, описывающий визуальное представление приложения.
    
    Контейнер - это неофициальный термин для описания компонента, подключенного к хранилищу Redux (Redux Store).
    
    Контейнеры подписываются на обновление состояния Redux и диспачат (dispatch) операции.
    
    То есть по сути они являются посредниками и отвечают за взаимодействия хранилища (store) и компонентов, отвечающих за отрисовку интерфейса.
    
    Поэтому в большинстве своем - контейнеры не рендерят DOM элементы, а делегируют рендоринг - дочерним компонентам, задача которых визуализация данных.
    
      
    
- [Как React обрабатывает, или ограничивает использование пропсов определенного типа?](https://youtu.be/81yRgVQ1ciM?t=413)
    
    Речь в вопросе идет о ProTypes.
    
    ProTypes - это один из вариантов перехвата ошибок, связанных с неправильными типами props-ов.
    
    С помощью ключевого слова isRequered - он позволяет помечать props-ы, как обязательное.
    
    А компонент с помощью defaultProps - определяет их значение по-умолчанию.
    
    ProTypes - определяет тип пропса.
    
    Каждый раз, когда через props передается какое-либо значение - prop проверяется на правильный тип. Если будет обнаружен неправильный тип - в консоль будет выведено сообщение об ошибки.
    
    Это позволяет гарантировать, что компоненты получают props-ы с верными типами.
    
    Также аналогами проверки типов в React можно назвать:
    
    - Flow - библиотека для статической типизации JavaScript
    - TypeScript - язык программирования, представленный Microsoft в 2012 году и позиционируемый как средство разработки веб-приложений, расширяющее возможности JavaScript
- [Что такое строгий режим в React? Его преимущества?](https://youtu.be/81yRgVQ1ciM?t=469)
    
    Strict Mode (Строгий режим) - это инструмент для определения потенциальных проблем приложения.
    
    Как и Fragment - Strict Mode ничего не рендорит. Он активирует дополнительные проверки и предупреждения для дочерних компонентов.
    
    Проверки выполняются только в developer mode (режиме разработки).
    
    Эти проверки не влияют на production сборку.
    
    К преимуществами Strict Mode можно отнести:
    
    - предупреждение об использовании устаревшего API строковых ссылок (string ref)
    - предупреждение об использовании устаревшего метода findDOMNode
    - определение компонентов с небезопасными методами жизненного цикла
    - определение неожиданных побочных эффектов
    - определение использования устаревшего API контекста
- [Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?](https://youtu.be/81yRgVQ1ciM?t=532)
    
    В React props-ы передаются в одном направлении - сверху вниз от родительского компонента к дочернему.
    
    При наличии незначительного кол-во props-ов - это не является проблемой.
    
    Однако при росте приложения - для того чтобы передать props-ы с верхнего уровня приложения в компоненты находящиеся на третьем или четвертом уровне вложенности - приходится передавать одни и те же props-ы на каждом уровне дерева компонентов.
    
    Также ситуация может усугубиться тем, что пробрасывать нужно сразу несколько свойств.
    
    И таким образом - кол-во props-ов у компонентов верхнего уровня может быть огромным.
    
    Данный механизм - называется prop drilling. Он является антипаттерном.
    
    А для того чтобы его избежать существует 2 подхода:
    
    - использование Redux Store или любого другого state management
    - воспользоваться контекстом или хуком useContext
- [Что такое «опрос» (Polling)? Как его реализовать в React?](https://youtu.be/81yRgVQ1ciM?t=597)
    
    Механизм Polling (Опрос) - это распространенный подход для регулярных асинхронных запросов.
    
    Предположим у нас есть компонент и сервер, у которого мы должны запрашивать данные.
    
    Чтобы не блокировать работу пользователя с компонентом или приложением - асинхронные запросы могут идти либо отложено, либо в фоновом режиме.
    
    Таким образом можно наладить опрос сервисов через определенные промежутки времени.
    
    В React такой механизм реализуется с помощью метода setInterval и хука useEffect.
    
    При первом рендеринге компонента - запускается таймер, который каждую секунду делает запрос на сервер.
    
    Также чтобы этот таймер остановить при размонтировании компонента - из useEffect возвращается метод clearInterval.
    
    ```JavaScript
    import React, { useState, useEffect } from 'react';
    
    const IntervalExample = () => {
        const [data, setData] = useState(null);
    
        const getItems = () => {
            fetch('api-url')
                .then(result => result.json())
                .then(result => setData(result));
        };
    
        useEffect(() => {
            const interval = setInterval(() => getItems(), 1000);
            return () => clearInteral(interval);
        }, []);
    
        return (
            <div className='App'>
                <Component data={data} />
            </div>
        );
    };
    ```
    
      
    
- [Разница между элементом и компонентом?](https://youtu.be/81yRgVQ1ciM?t=663)
    
    Компонент - это шаблон, проект или схема. Он может быть - функцией или классом с методами жизненного цикла или хуками.
    
    Элемент - это то, что возвращается из компонента. Это объект описывающий виртуальное представление определенного DOM-узла, содержащегося в компоненте.
    
    В случае с функциональными компонентами - указанный объект возвращается функцией.
    
    В классовых компонентах - объект возвращается методом render.
    
    Элементы React - это не то, что отображается в браузере. Это всего лишь объекты хранящиеся в памяти, которые напрямую невозможно изменять.
    
    Элемент - это обычный JS объект с определенными методами.
    
    Элемент имеет 4 свойства:
    
    - type - строковое представление HTML тэга или ссылка на React компонент
    - key - строка идентификатор React элемента
    - ref - ссылка на узел DOM или экземпляр компонента React
    - props - объект со свойствами
    
    Элемент описывающий компонент не знает в каком DOM узле он будет отрендорин. Эта связь абстрагирована и определяется в процессе рендеринга.
    
    Компоненты - это строительные блоки приложения. Они могут иметь состояния или получать данные с помощью props-ов, а также им доступны методы. жизненного цикла.
    
    А если компонент функциональный - то он может воспользоваться хуками. И он обязательно должен иметь метод render.
    
- [Что такое](https://youtu.be/81yRgVQ1ciM?t=763) [`ReactDOMServer`](https://youtu.be/81yRgVQ1ciM?t=763)[?](https://youtu.be/81yRgVQ1ciM?t=763)
    
    Объект ReactDOMServer позволяет рендорить компоненты в виде статической разметки.
    
    Обычной данный объект используется на node серверах.
    
    Рендоринг на стороне сервера (SSR - Server Side Rendering) - это техника позволяющая отрисовывать клиентские одностраничные приложения на сервере и отправлять их клиенту в виде готовой разметки.
    
    Это делает динамические компоненты - статичными.
    
    Плюсы данного подхода в том:
    
    - повышает скорость рендоринга страниц, что улучшает UX
    - повышает поисковую оптимизацию (SEO), облегчая индексацию страниц поисковыми роботами
    - а также это повышает доступность meta-данных (изображения, заголовки, описания и т д.), что позволяет пользователем легко делится контентом приложения
- [Что такое предохранители (Error Boundaries)?](https://youtu.be/HBSAjY-xh3k?t=36)
    
    Error Boundaries (Предоханители) - React компоненты, которые перехватывают любые ошибки, возникающие в дереве потомков. После чего выводят сообщение об ошибках в консоль или отображает резервный UI вместо сломанного.
    
    Предохранители перехватывают ошибки во время:
    
    - рендеринга
    - в методах жизненного цикла
    - и в конструкторах любых дочерних компонентов
    
    Компонент становится предохранителем, когда в нем определяется методы жизненного цикла:
    
    - getDerrivedStateFromError
    - componentDidCatch
    
    И хоть оба метода служат для обработки ошибок - задачи, которые они выполняют немного отличаются.
    
    getDerrivedStateFromError - используется для рендеринга запасного UI после возникновения ошибки
    
    componentDidCatch - используется для вывода сообщения об ошибке в консоль
    
    Предохранители не перехватывают ошибки в:
    
    - обработчиках событий
    - асинхронном коде
    - при серверном рендеринге
    - при выбрасывание исключения в самом предохранители
- [Что такое «ленивая» (Lazy) функция?](https://youtu.be/HBSAjY-xh3k?t=103)
    
    Изначально стоит отметить, что это метод из нового API - React.Suspense
    
    React.lazy (ленивая функция) - эта функция, которая позволяет создавать компоненты загружаемые с помощью динамического импорта, которые рендарятся как обычные компоненты.
    
    Это позволяет уменьшить размер bundle - поскольку загружаются только те компоненты, которые реально отрисовывается на UI в текущий момент.
    
    React.lazy в качестве аргумента принимает функцию. Эта функция возвращает promise в результате вызова импорта для загрузки компонента.
    
- [Разница между рендерингом и монтированием?](https://youtu.be/HBSAjY-xh3k?t=149)
    
    Рендеринг - эта функция или метод render, вызываемый компонентом и возвращающий инструкции для создания DOM.
    
    Метод render вызывается при каждом рендеринге компонента. А обновление компонента происходит при изменении его состояния или props-ов.
    
    Монтирование - это первый ренедеринг компонента и построение первоначальной объектной модели документа.
    
    Монтирование компонента означает встраивание создаваемых им элементов в браузерный DOM.
    
    Повторный рендеринг - это повторный вызов функции для получения информации об уже смонтированном компоненте.
    
- [Что такое](https://youtu.be/HBSAjY-xh3k?t=191) [`сhildren`](https://youtu.be/HBSAjY-xh3k?t=191)[?](https://youtu.be/HBSAjY-xh3k?t=191)
    
    Children (потомки, дети) - это prop, позволяющий передавать одни компоненты другим, как другие любые props-ы.
    
    Дерево компонентов, размещаемое между открывающим и закрывающим тэгами - передается компоненту в качестве props-а children.
    
    Children ссылается на контейнер, содержимое которого неизвестно до передачи данных из родительского компонента.
    
    Также для работы с этим типом props-ов в React API существуют такие методы как:
    
    - React.Children.map
    - React.Children.forEach
    - React.Children.count
    - React.Children.only
    - React.Children.toArray
- [Что такое события указателя (Pointer Events)?](https://youtu.be/HBSAjY-xh3k?t=239)
    
    Pointer Events (События указателя) - предоставляет унифицированный способ обработки всех событий ввода.
    
    Событие указателя похоже на событие мыши:
    
    - mousedown
    - mouseup
    - и т д.
    
    Однако не зависит от устройства. Поэтому это может быть: мышь, стиллус или даже прикосноваения
    
    Это позволяет избежать реализацию функционала для каждого устройства.
    
    Рассматриваемый API работает также как и существующие обработчики событий.
    
    Событие указателя добавляется к React компонентам в качестве атрибутов с callback-ми, принимающими событие.
    
    Внутри callback происходит обработка события.
    
    В ReactDOM доступны следующие типы событий указателя:
    
    (Важно помнить, что эти события работают только в браузерах - поддерживающих pointer events.
    
    ![[Untitled 3 17.png|Untitled 3 17.png]]
    
      
    
- [Что такое инверсия наследования (Inheritance Inversion)?](https://youtu.be/HBSAjY-xh3k?t=301)
    
    Инверсия наследования - это HOC (компонент высшего порядка), который мы может видеть в коде.
    
    В данном коде внутри HOC возвращается класс, расширяющий WrappedComponent.
    
    ```JavaScript
    const inheritanceInversionHOC = (WrappedComponent) => {
        return class extens WrappedComponent {
            render() {
                return super.render()
            }
        }
    }
    ```
    
    Данная техника называется - инверсией наследования, так как вместо расширения некоторого класса усилителя с помощью WrappedComponent - последний сам пассивно расширяется.
    
    Отношение между ними напоминает - инверсию.
    
    Инверсия наследования предоставляет HOC-у доступ к экземпляру WrappedComponent, а это означает - что можно использовать state, props, методы жизненного цикла и даже render данного компонента.
    
    Есть два случая, когда HOC можно использовать:
    
    - перехват рендеринга
    - управление состоянием
    
      
    
- [Как в React реализовать двустороннее связывание данных?](https://youtu.be/HBSAjY-xh3k?t=355)
    
    Данный вопрос - это еще один пример запутанной формулировки, но простого объяснения.
    
    Двустороннее связывание данных означает следующее:
    
    - Данные, которые изменяются в представлении - обновляют состояние. Данные в состояние - обновляют представление.
    
    Компоненты (или даже элементы), в которых реализована такая связь называются - управляемыми.
    
    Но выполнить такую связку можно с помощью:
    
    - setState - в классовом компоненте
    - или хука useState - в функциональном компоненте
    - а также обработчика, который добавляется к примеру на input элемент
    
    Таким образом - данные вводимые на UI попадают в state и обновляют его. А обновление state - вызывает обновление на UI.
    
- [Разница между классовым и функциональным компонентами?](https://youtu.be/xZLxdts7ZW4?t=664)
    
    В этом вопросе мы не затрагиваем хуки.
    
    Функциональные компоненты - это обычные функции JS.
    
    Чаще всего они представлены в виде - стрелочных функций. Но их вполне можно создавать и с помощью ключевого слова - function.
    
    Их часто называют компонентами без состояния, которые просто принимают данные и отображают их в некоторой форме.
    
    Поэтому они в основном отвечают за рендоринг UI.
    
    В них нельзя использовать - методы жизненного цикла. В них нет метода render. Им следует отдавать предпочтение в тех случаях, когда не требуется работать с состоянием.
    
    Если говорить о классовых - то они:
    
    - используют состояние
    - используеют методы жизненного цикла
    - принимают props-ы и имеют к ним доступ через свойство this.props
    - могут содержать ref (ссылки на дочерние DOM узлы)
    - а также могут использовать такие техники улучшения перфомонса, как shouldComponentUpdate и Pure Component
- [Разница между](https://youtu.be/xZLxdts7ZW4?t=754) [`useEffect()`](https://youtu.be/xZLxdts7ZW4?t=754) [и](https://youtu.be/xZLxdts7ZW4?t=754) [`componentDidMount()`](https://youtu.be/xZLxdts7ZW4?t=754)[?](https://youtu.be/xZLxdts7ZW4?t=754)
    
    В React при использовании классовых компонентов - мы получаем доступ к методам жизненного цикла.
    
    В функциональных компонентах - альтернативой методам жизненного цикла являются хуки.
    
    componentDidMount() и useEffect() - запускаются сразу же после монтирования компонента.
    
    Тем не менее useEffect() вызывается после отображения на экране результата рендоринга.
    
    А это значит, что мы можем получить мерцание (flicker) - в случае, когда необходимо прочитать DOM и синхронно обновить состояние для получения нового UI.
    
    Другой хук, который называется useLayoutEffect() был спроектирован специально для таких случаев.
    
    Он вызывается перед отображением на экране результатов рендеринга, поэтому useLayoutEffect() по времени выполнения ближе, чем useLayoutEffect().
    
- [Преимущества хуков?](https://youtu.be/xZLxdts7ZW4?t=819)
    - с ними легче работать и легче тестировать, как отдельные функции компонентов
    - хуки делают код чище, улучшают его читаемость
    - позволяет разделять сложную логику на маленькие функции, используемые внутри компонентов
    - повышает уровень переиспользуемости кода
    - позволяют распределять логику между компонентами через пользовательские хуки
    - являются более податливыми к перемещению в дереве компонентов
    - благодаря переиспользованию отдельных кусков логики - нет необходимости использовать HOC-и, которые зачастую только усложняют понимание работы компонента
- [Правила (ограничения) использования хуков?](https://youtu.be/xZLxdts7ZW4?t=873)
    - выполнять хуки следует в самом верху иерархии функции
    - вызывать хуки можно только в функциях или функциональных компонентах либо в пользовательских хуках
- [Что такое поднятие состояния вверх (Lifting State Up)?](https://youtu.be/ngyOYuTrUk8?t=700)
    
    Поднятие состояния вверх по иерархии компонентов (Lifting State Up) - это паттерн с помощью которого одно состояние может быть использовано сразу для нескольких компонентов.
    
    Обычно некоторые компоненты должны реагировать на одни и те же события или изменения состояния.
    
    Поэтому необходимо каким-то образом уведомлять все компоненты, когда что-то изменилось.
    
    Рекомендуемый подход для того чтобы это сделать - как раз таки поднять состояния вверх.
    
    Это означает, что общее состояние должно быть поднято до ближайшего общего предка.
    
    Этот паттерн базируется на утверждение, что state - должен быть один для любых данных, которые изменяются в React приложении.
    
- [Что делает метод](https://youtu.be/ngyOYuTrUk8?t=748) [`shouldComponentUpdate`](https://youtu.be/ngyOYuTrUk8?t=748)[?](https://youtu.be/ngyOYuTrUk8?t=748)
    
    В жизненном цикле классового компонента имеется метод shouldComponentUpdate, который позволяет отказаться от участия в процессе сравнения некоторых компонентов и их дочерних элементов.
    
    Цель сравнения заключается в том, чтобы самом эффективном путем обновить интерфейс на основе нового состояния.
    
    Поэтому если мы знаем, что часть интерфейса не изменится - то нет причин составлять React, прогонять проверку обновления самостоятельно.
    
    Именно для таких кейсов используется shouldComponentUpdate, который возвращает булевое значение.
    
    При возвращении false из этого метода - React будет понимать, что текущий компонент и все его дочерние компоненты останутся такими же какими и являются в данный момент.
    
    При этом механизм согласования не будет запущен, что в некоторых случаях ускорит перфоманс. А аналогом shouldComponentUpdate - является хук useEffect.
    
- [Разница между](https://youtu.be/ngyOYuTrUk8?t=816) [`createElement()`](https://youtu.be/ngyOYuTrUk8?t=816) [и](https://youtu.be/ngyOYuTrUk8?t=816) [`cloneElement()`](https://youtu.be/ngyOYuTrUk8?t=816)[?](https://youtu.be/ngyOYuTrUk8?t=816)
    
    Функция cloneElement() - возвращает копию указанного элемента. В нее можно передать дополнительные props-ы, либо дочерние элементы.
    
    cloneElement() можно использовать когда родительский компонент хочет добавить или изменить свойство своих дочерних элементов.
    
    Что же касается createElement() - то данная функция предназначена для создания и возврата нового React элемента заданного типа.
    
    Аргумент типа может быть:
    
    - строкой именем тэга (например div или span)
    - а также типом React компонента: класс или функция
    - либо типом React фрагмента.
    
    Код написанный с помощью JSX - будет преобразован для использования в React.
    
- [Что такое](https://youtu.be/GZUy2i6QN7o?t=257) [`useReducer()`](https://youtu.be/GZUy2i6QN7o?t=257)[?](https://youtu.be/GZUy2i6QN7o?t=257)
    
    useReducer() - это хук принимающий функцию reducer и начальное состояние приложения в качестве аргументов. И возвращающий текущее состояние и dispatch - для отправки операций.
    
    Кстати несмотря на то, что useState() это базовый хук, а useReducer() продвинутый - на самом деле useState() реализован с помощью useReducer().
    
    А это означает, что useReducer() - это примитив, который может использоваться во всех случаях использования useState().
    
    Механизм работы следующий:
    
    1. Сначала определяется начальное состояние и reducer
    2. Затем их передают в хук useReducer()
    3. Хук в свою очередь возвращает текущее значение состояний и dispatch, который используется для обновления состония.
    4. Когда пользователь нажимает на кнопку - происходит отправка определенной операции в reducer, которая обновляет счетчик на основе операции. Таким образом можно определять столько операций - сколько требуется приложению.
    
    ```JavaScript
    import React, {useReducer} from 'react';
    
    // Store
    const initialState = { count: 0};
    
    //Reducer 
    const reducer =({ count }, { type }) => {
        switch (type) {
            case 'increment': return { count: count + 1};
            case 'decrement': return { count: count - 1};
            default: return{};
        }
    };
    
    const Counter = () => {
        const [state, dispatch] = useReducer(reducer, initialState);
    
        return(
            <>
            <div>{state.count}</div>
            {/* Actions */}
                <button onClick={() => dispacth({type: 'increment'})}>+1</button>
                <button onClick={() => dispacth({type: 'increment'})}>-1</button>
            </>
        );
    };
    ```
    
- [Как реализовать однократное выполнение операции при начальном рендеринге?](https://youtu.be/GZUy2i6QN7o?t=321)
    
    Для того чтобы какая-то операция выполнялась только один раз при первом рендеринге React компонента - существует несколько подходов:
    
    - можно использовать метод жизненного цикла componentDidMount() - если мы работаем с классовым компонентом.
    
    Любые операции, определенные в componentDidMount() - будут выполнены только один раз при монтирование компонента.
    
    - аналогичный функционал можно реализовать с помощью хука useEffect() с пустым массивом зависимостей.
    
    useEffect() является более гибким и современным, чем методы жизненного цикл.
    
    Он принимает 2 параметра:
    
    1. функцию обратного вызова, которая должна выполниться
    2. опциональный 2 параметр - это массив, содержащий отслеживаемые переменные
    
    Если массив остается пустым - то эффект выполнится только один раз, что по сути эквивалентно методу componentDidMount().
    
- [Что такое распределенный компонент?](https://youtu.be/GZUy2i6QN7o?t=386)
    
    Это разновидность компонента, который управляет своим внутренним состоянием, а логику рендоринга - делегирует другому компоненту.
    
    Таким образом - место определения компонента отделяется от места его реализации.
    
    Это предоставляет возможность защитить специфическую логику от остального приложения, предоставляя компонентам - чистый и выразительный API для использования.
    
    Они конструируются таким образом - чтобы оперировать набором данных, которые передаются через дочерние компоненты вместо props-ов.
    
    Под капотом используется низкоуровневый API - такой как:
    
    - _React_._Children_._map()_
    - _React_._cloneElement_()
- [Расскажите о хуках](https://youtu.be/GZUy2i6QN7o?t=449) [`useCallback()`](https://youtu.be/GZUy2i6QN7o?t=449)[,](https://youtu.be/GZUy2i6QN7o?t=449) [`useMemo()`](https://youtu.be/GZUy2i6QN7o?t=449)[,](https://youtu.be/GZUy2i6QN7o?t=449) [`useImperativeHandle()`](https://youtu.be/GZUy2i6QN7o?t=449)[,](https://youtu.be/GZUy2i6QN7o?t=449) [`useLayoutEffect()`](https://youtu.be/GZUy2i6QN7o?t=449)[?](https://youtu.be/GZUy2i6QN7o?t=449)
    
    - useCallback() - может использоваться для оптимизации рендоринга функциональных компонентов.
    
    Он возвращает мемоизированную версию callback-а - это означает, что такой callback обновляется только при изменении его зависимостей.
    
    Это может-быть полезным при передаче callback-ов - оптимизированным дочерним компонентам.
    
    - useMemo() - может использоваться для оптимизации вычислений, производимых в функциональных компонентах.
    
    useMemo() похож на useCallback() за исключением того - что он принимает любые значения, а не только функции.
    
    В основном useMemo() принимает функцию возвращающую значение и массив зависимостей.
    
    Значение возвращаемое функцией - вычисляется повторно только при изменение зависимостей.
    
    - useImperativeHandle() - позволяет кастомизировать значение, передаваемое родительскому компоненту с помощью ref.
    
    Однако нужно помнить, что императивный код ,в котором используются ссылки - является плохой практикой.
    
    А useImperativeHandle() - должен использоваться совместно с forwardRef().
    
    - useLayoutEffect() - запускается после выполнения всех манипуляций с DOM, но до его отрисовки с браузером.
    
    Это может-быть полезным для получения дополнительной информации из DOM.
    
    Например - получение величины прокрутки или стилей элемента и использование этой информации для корректировки DOM или запуска повторного рендоринга путем обновления состояния.
    
    Данный хук предназначен для выполнения тех же задач, которые выполняют методы: componentDidMount() и componentDidUpdate().
    
- [Как отрендерить HTML код в React-компоненте?](https://youtu.be/GZUy2i6QN7o?t=572)
    
    По другому этот вопрос может звучать: как использовать innerHTML в React?
    
    Основная идея в том, что например - мы сделали запрос на сервер, а в ответ нам вернулись не просто данные - а разметка.
    
    И эту самую разметку нужно отрисовать внутри компонента.
    
    Для подобных задача в React существует специальный атрибут - dangerouslySetInnerHTML.
    
    Он по сути и является альтернативой стандартного innerHTML.
    
    dangerouslySetInnerHTML также как и innerHTML - представляет собой угрозу межсайтового скриптинга.
    
    В качестве аргумента он принимает объект с ключом HTML и HTML разметкой в качестве значения.
    
    После чего - эта разметка будет отрендорина на странице.
    
    **XSS**([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA) _Cross-Site Scripting_ — «межсайтовый [скриптинг](https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D1%80%D0%B8%D0%BF%D1%82)») — тип [атаки](https://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BA%D0%B5%D1%80%D1%81%D0%BA%D0%B0%D1%8F_%D0%B0%D1%82%D0%B0%D0%BA%D0%B0) на [веб-системы](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5), заключающийся во внедрении в выдаваемую веб-системой [страницу](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0) [вредоносного кода](https://ru.wikipedia.org/wiki/%D0%92%D1%80%D0%B5%D0%B4%D0%BE%D0%BD%D0%BE%D1%81%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4) (который будет выполнен на [компьютере](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80) пользователя при открытии им этой страницы) и взаимодействии этого кода с веб-сервером злоумышленника. Является разновидностью атаки «[Внедрение кода](https://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BA%D0%B5%D1%80%D1%81%D0%BA%D0%B0%D1%8F_%D0%B0%D1%82%D0%B0%D0%BA%D0%B0#%D0%98%D0%BD%D1%8A%D0%B5%D0%BA%D1%86%D0%B8%D1%8F_%D0%BA%D0%BE%D0%B4%D0%B0)».
    
    ```JavaScript
    const createMarkup = () => ({__html: 'First &middot; Second'});
    
    const MyComponent = () => {
        <div dangerouslySetInnerHTML={createMarkup()}/>;
    }
    ```
    
- [Зачем в](https://youtu.be/GZUy2i6QN7o?t=627) [`setState()`](https://youtu.be/GZUy2i6QN7o?t=627) [нужно передавать функцию?](https://youtu.be/GZUy2i6QN7o?t=627)
    
    Дело в том, что setState() - эта асинхронная операция.
    
    React откладывает обновление состояния по причинам производительности - поэтому состояние может обновиться не сразу после вызова setState().
    
    А это означает, что не нужно полагаться на текущее состояние при вызове setState() - поскольку нельзя быть уверенным в том, каким оно является.
    
    Решение данной проблемы является - передача в setState() функции с предыдущим состоянием в качестве аргумента.
    
    Это позволяет избежать проблем, связанных с получением старого состояния из-за асинхронной природы setState.
    
- [Для чего предназначен метод](https://youtu.be/GZUy2i6QN7o?t=665) [`registerServiceWorker()`](https://youtu.be/GZUy2i6QN7o?t=665) [в React?](https://youtu.be/GZUy2i6QN7o?t=665)
    
    Данный метод можно довольно часто увидеть в различных React приложениях.
    
    А также по умолчанию - он интегрирован в create-react-app.
    
    React создает ServiceWorker без настройки по умолчанию.
    
    ServiceWorker - это веб API, позволяющий записывать файлы приложения в кэш и возвращать их из него при отсутствии подключения к сети или медленном соединении, что в свою очередь отлично улучшает пользовательский опыт.
    
    Так что ServiceWorker - это своего рода прокси для HTTP запросов.
    
    Прокси-сервер — промежуточный сервер в компьютерных сетях, выполняющий роль посредника между пользователем и целевым сервером, позволяющий клиентам как выполнять косвенные запросы к другим сетевым службам, так и получать ответы.