  

- ==[Типы данных в JavaScript?](https://youtu.be/ycYp7CYOnO0?t=471)==
    - Строка «string»
    - Число «number»
    - BigInt
    - Булевый (логический) тип «boolean»
    - Символы «symbol» - представляет собой уникальный идентификатор
    - null
    - undefined
- ==[Разница между](https://youtu.be/ycYp7CYOnO0?t=529)== ==[`==`](https://youtu.be/ycYp7CYOnO0?t=529)== ==[и](https://youtu.be/ycYp7CYOnO0?t=529)== ==[`===`](https://youtu.be/ycYp7CYOnO0?t=529)== ==[(нестрогое/строгое равенство)?](https://youtu.be/ycYp7CYOnO0?t=529)==
    - нестрогое - просто сравнивает значения
    - строгое - дополнительно сравнивает их типы
- ==[Что такое Strict mode в JavaScript?](https://youtu.be/ycYp7CYOnO0?t=577)==
    
    Строгий режим “use strict” - позволяет использовать более строгий вариант JS синтаксиса, он заменяет исключениями некоторые ошибки, которые JS интерпретатор пропускает по умолчанию.
    
- ==[Разница между function declaration и function expression?](https://youtu.be/ycYp7CYOnO0?t=632)==
    
    - Function declaration - это функция, созданная в основном потоке документа
    - Function expression - это когда созданная функция присваивается в переменную
    
    Отличия: Function declaration создается JS интерпретатором до выполнения кода, поэтому ее спокойно можно вызвать еще до объявления.
    
- ==[Разница между](https://youtu.be/G7hLwudGWL4?t=511)== ==[`null`](https://youtu.be/G7hLwudGWL4?t=511)== ==[и](https://youtu.be/G7hLwudGWL4?t=511)== ==[`undefined`](https://youtu.be/G7hLwudGWL4?t=511)====[?](https://youtu.be/G7hLwudGWL4?t=511)==
    
    Оба типа данных обозначают отсутствующие данные.
    
    undefined - представляет собой значение по умолчанию для:
    
    - переменной, которой еще не было присвоено никакого другого значения (то есть она была не определена)
    - функции, которой ничего не возвращает явно
    - и несуществующего свойства объекта
    
    null - это явное задание отсутствующего значения (то есть когда разработчик самостоятельно определяет отсутсвие каких-либо данных)
    
- ==[Типы таймеров в JavaScript?](https://youtu.be/G7hLwudGWL4?t=690)==
    
    - setTimeOut - позволяет вызывать переданную функцию один раз по истечению определенного времени.
    - setInterval - позволяет вызывать функцию постоянно через определенный промежуток времени.
    
    Оба таймера принимают 2 значения:
    
    - функция, которая будет выполнена
    - время
    
    Оба таймера возвращает идентификатор, который может быть присвоен в переменную и ее можно передать в одну из функций:
    
    - clearTimeOut - позволяет остановить setTimeOut еще до момента вызова
    - clearInterval - это единственный способ остановить setInterval
    
    ![[Untitled 93.png|Untitled 93.png]]
    
- ==[Что такое поднятие (Hoisting)?](https://youtu.be/G7hLwudGWL4?t=552)==
    
    Hoisting - это механизм подъема функции или переменной в глобальную или локальную(функциональную) область видимости.
    
    Этот механизм является особенностью самого движка JS. Он сначала объявляет, а уже затем инициализирует наши переменные.
    
    И это значит, что к переменным объявленным через var и к function declaration можно получить доступ еще до получения значения.
    
- ==[Что такое область видимости (Scope)?](https://youtu.be/1eIRTdgzHtw?t=282)==
    
    Область видимости (Scope) - это место откуда мы имеем доступ к переменным или функциям.
    
    Типы области видимости:
    
    - глобальная
    - локальная(функциональная)
    - блочная
    
    Область видимости - это по сути набор правил, по которым происходит поиск переменных.
    
- ==[Что такое замыкание (Closure)?](https://youtu.be/kx3dR6ztICU?t=284)==
    
    Если внутри одной функции создать вторую, то вложенная функция получит доступ к переменным, которые были объявлены во внешней. Этот механизм и называется замыканием.
    
    То есть вложенная функция замыкает на себе переменные и аргументы внешней функции.
    
- ==[Что обозначает](https://youtu.be/rlWgI7AvV18?t=507)== ==[`this`](https://youtu.be/rlWgI7AvV18?t=507)== ==[в JavaScript?](https://youtu.be/rlWgI7AvV18?t=507)==
    
    this - это контекст вызова функции или ссылка на значение объекта, который в данный момент выполняет или вызывает функцию.
    
    Соответсвенно this может принимать разные значения в зависимости от контекста выполнения:
    
    - this у вызова функции - глобальный объект (window) или undefined (если use strict**)**
    - this у методов объекта - сам объект
    - this у конструкторах и классов - это новый экземпляр объекта
- ==[Что такое функции высшего порядка (Higher Order Functions)?](https://youtu.be/1eIRTdgzHtw?t=426)==
    
    Функции высшего порядка - это функции, которые возвращают другие функции или же принимают другую функцию в качестве аргумента.
    
    Примеры таких функции можно встретить даже в нативном JS:
    
    - map
    - filter
    - forEach
    - reduce
    
    Они в качестве аргумента принимают функцию и в последующем применяют ее к каждому элементу массива.
    
- ==[Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?](https://youtu.be/CjdCxxqObaM?t=368)==
    
    Для того чтобы осуществить преобразование любого типа данных в булевое значение мы можем использовать:
    
    - функцию Boolean() во внутрь которой мы передаем данные, а на выходе получаем булевое значение
    - использовать двойное отрицание !!
    
    В JS существует 6 основных элементов, которые возвращают ложное значение:
    
    - пустая строка '’
    - 0
    - null
    - NaN
    - false
- ==[Методы строк в JavaScript?](https://youtu.be/CjdCxxqObaM?t=415)==
    
    - str.charAt() - можем получить определенный символ в строке, передав число
    - str.toUpperCase() - меняет регистр строки на верхний
    - str.toLowerCase() - меняет регистр строки на нижний
    - str.indexOff() - используется для поиска указанных символов в строке. Если указанные символы найдены - возвращает числовой индекс и минус один - если нет.
    - str.lastIndexOf() - то же самое что и предыдущее - разница лишь в том, что возвращает индекс именно последнего вхождения (то есть если в строке есть несколько одних и тех же символов - то вернется индекс последнего найденного)
    
    Для извлечения строки и подстроки существует целых 3 метода:
    
    (Разница между ними заключается в том, как происходит вырезка элементов)
    
    - str.slice (..., n) - в этом методе мы указываем индексы с которых начинается и заканчивается подстрока
    - str.substr(..., n) - этот метод в качестве 2 параметра принимает не конечный индекс, а длину вырезаемых символов
    - str.substring(..., n) - этот метод работает также как и в str.slice (..., n), но разница в том, что он не может принимать отрицательные значения
    - str.replace() - предназначен для замены значений в строке
    - str.trim() - отсекает пробельные символы в начале и конце строки
- ==[Методы массивов в JavaScript?](https://youtu.be/CjdCxxqObaM?t=538)==
    - arr.push() - добавляет значение в конец массива
    - arr.pop() - удаляет последний элемент массива
    - arr.unshift() - добавляет значение в начало массива
    - arr.shift() - удаляет первый элемент массива
    - arr.splice() - с помощью этого метода можно добавлять, удалять и заменять на новые элементы массива
    - arr.toString() - превращает массив в строку
    - arr.join() - также превращает массив в строку, только ему можно передать значение, которое будет в качестве разделителя
    - filter() - фильтрует элементы внутри массива
    - map() - перебирает исходный массив и возвращает новый массив
    - reduce() - собирает массив в одно единое целое
    - some() и every() - перебирают и возврщают булевое значение
    - forEach()
- ==[Что такое чистая функция?](https://youtu.be/rlWgI7AvV18?t=401)==
    
    Чистая функция - это одна из концепций функционального программирования.
    
    Она должна удовлетворять 2 условиям:
    
    - в ней не должно быть побочных эффектов
    - каждый раз она возвращает одинаковый результат, когда вызывается с тем же набором аргументов
    
    К побочным эффектам можно отнести:
    
    - видоизменение входных параметров
    - http запросы и dom запросы
    - изменения в файловой системе
    - вывод на экран
- ==[Разница между](https://youtu.be/rlWgI7AvV18?t=456)== ==[`.forEach`](https://youtu.be/rlWgI7AvV18?t=456)== ==[и](https://youtu.be/rlWgI7AvV18?t=456)== ==[`.map()`](https://youtu.be/rlWgI7AvV18?t=456)====[?](https://youtu.be/rlWgI7AvV18?t=456)==
    
    Оба метода можно применять к массивам для того чтобы перебирать их элементы и к каждому из элементов применять переданную функцию.
    
    Ключевое различие между методами заключается в том, что forEach перебирает массив и ничего не возвращает. А map() перебирая массив - формирует и возвращает новый массив, который получен при выполнении функции.
    
- ==[Разница между](https://youtu.be/rlWgI7AvV18?t=548)== ==[`.call()`](https://youtu.be/rlWgI7AvV18?t=548)====[,](https://youtu.be/rlWgI7AvV18?t=548)== ==[`.apply()`](https://youtu.be/rlWgI7AvV18?t=548)== ==[и](https://youtu.be/rlWgI7AvV18?t=548)== ==[`bind()`](https://youtu.be/rlWgI7AvV18?t=548)====[?](https://youtu.be/rlWgI7AvV18?t=548)==
    
    В следствии ошибки или запутанности кода может произойти ситуация, когда значение this изменяется. Это называется потеря контекста.
    
    Для того чтобы избежать такой ситуации и строго определить контекст вызова - можно воспользоваться одним из 3 методов:
    
    - call()
    - apply()
    - bind()
- ==[Почему в JS функции называют объектами первого класса?](https://youtu.be/rlWgI7AvV18?t=624)==
    
    Все дело в том, что в JS любые типы данных ведут себя как объекты.
    
    Даже если мы говорим о примитивах: таких как строка или число - у каждого из них есть набор методов, которые можно использовать.
    
    Функции в этом плане не являются исключением.
    
- ==[Как определить наличие свойства в объекте?](https://youtu.be/kx3dR6ztICU?t=226)==
    
    Способы:
    
    - метод obj.hasOwnProperty(prop) - как результат возвращает булевое значение (true - свойство есть, false - если оно отсутсвует)
    - применение оператора in (prop in obj) - результатом также возвращается true или false
    - обратиться к свойству объекта напрямую с помощью индексной нотации (obj[prop]) - в этом случае, если свойство есть в объекте, то оно вернет значение. Если свойства нет, то вернется undefined.
- ==[Что такое IIFE?](https://youtu.be/kx3dR6ztICU?t=396)==
    
    Immediately invoked function expression (анонимная самовызывающаяся функция) - это JavaScript функция, которая выполняется сразу же после того, как она была определена.
    
    Данный паттерн часто использовался, чтобы не допустить изменения глобального пространства имен.
    
    До появления модуля в ES6 именно IIFE применялся для создания поведения модуля, так как особенность такой конструкции в том, что переменные объявленная внутри - невидимы за ее пределами.
    
- ==[Что такое псевдомассив](https://youtu.be/kx3dR6ztICU?t=442)== ==[`arguments`](https://youtu.be/kx3dR6ztICU?t=442)====[?](https://youtu.be/kx3dR6ztICU?t=442)==
    
    arguments - это коллекция аргументов, которая передается в функцию. Псевдомассивом его называют потому что на самом деле это объект подобный массиву.
    
    С помощью него можно получить доступ к любому из аргументов, которые были переданы в функцию.
    
- ==[Разница между host-объектами и нативными объектами?](https://youtu.be/kx3dR6ztICU?t=484)==
    - host-объекты - это объекты, которые предоставляются средой выполнения (то есть браузером для frontend или например Node.js для backend)
        
        В браузере к ним можно отнести: window, document, location, history, XMLHttpRequest, setTimoeOut, getElementsByTagName, querySelectorAll и т д.
        
    - Нативные объекты - это объекты, которые являются частью языка JS.
        
        К ним можно отнести: String, Object, RegExp, Function и т д.
        
    - Есть еще и третий тип объектов - это пользовательские объекты.
        
        К ним относится: любой объект, который создан пользователем.
        
- ==[Почему результат сравнения 2х объектов это](https://youtu.be/IooJ3P2VUYs?t=100)== ==[`false`](https://youtu.be/IooJ3P2VUYs?t=100)====[?](https://youtu.be/IooJ3P2VUYs?t=100)==
    
    Сравнение примитивов и объектов - отличается:
    
    - примитивы - сравниваются по значению (строки, числа)
    - объекты - сравниваются по ссылке или адресу в памяти, где хранится переменная
    
    Поэтому сравнение 2-х одинаковых объектов - это всегда false.
    
- ==[Что такое прототипное наследование? Как создать объект без прототипа?](https://youtu.be/IooJ3P2VUYs?t=154)==
    
    Все объекты в JS имеют свойство prototype, которое является ссылкой на другой объект.
    
    Когда к свойству объекта происходит обращение и если свойство не находится в текущем объекте - то механизм JS просматривает prototype объекта и ищет это свойство там.
    
    Затем он идет в прототип прототипа и т д, до тех пор пока не найдет свойство на одном из прототипов. Или до тех пор пока не достигнет конца цепочки прототипов.
    
    Это и есть прототипное наследование.
    
    А для того чтобы создать свойство у которого нет прототипа - нужно воспользоваться Object.create(null), внутрь которого в качестве аргумента передать null.
    
- ==[Почему расширение нативных JavaScript-объектов это плохая практика](https://youtu.be/IooJ3P2VUYs?t=202)==
    
    JS использует механизм прототипного наследования. А это значит, что если свойство или метод не будет найден в текущем объекте - то поиск будет осуществляться дальше по цепочки прототипов.
    
    Расширение нативного JS объекта - означает добавление новых свойств или методов его прототипу.
    
    В результате:
    
    - наше кастомное свойство может вступить в конфликт с существующим
    - можно получить сложную реализацию логики
    - при использовании сторонней библиотеки - можем получить конфликт логики
- ==[Что такое](https://youtu.be/IooJ3P2VUYs?t=266)== ==[`NaN`](https://youtu.be/IooJ3P2VUYs?t=266)====[? Как определить, что значение равно](https://youtu.be/IooJ3P2VUYs?t=266)== ==[`NaN`](https://youtu.be/IooJ3P2VUYs?t=266)====[?](https://youtu.be/IooJ3P2VUYs?t=266)==
    
    NaN - Not-a-Number (не число).
    
    Это не настраиваемое и не записываемое свойство глобального объекта.
    
    Оно получается, когда математическая функция сработала не верно.
    
    Для того чтобы проверить является ли значение не числом - используют функцию inNaN().
    
- ==[Что такое объектная обертка (Wrapper Objects)?](https://youtu.be/w-vUj0gHGgg?t=26)==
    
    В JS основные типы данных - это примитивы и объекты. И тем не менее даже у примитивов есть свои методы.
    
    Это возможно благодаря объектной обертки.
    
    Дело в том, что в момент исполнения кода - примитив временно преобразуется в объект.
    
    У каждого примитива (кроме null и undefined) есть объектная обертка.
    
    После работы с каким-то свойством или методом - временный объект отбрасывается и обратно возвращается примитив.
    
- ==[Как в JavaScript создать объект?](https://youtu.be/w-vUj0gHGgg?t=83)==
    
    Существует 3 способа:
    
    - объектный литерал (обычное создание объект)
    - с помощью функции конструктора
    - испольщование метода Object.create()
- ==[Для чего используется ключевое слово](https://youtu.be/w-vUj0gHGgg?t=125)== ==[`new`](https://youtu.be/w-vUj0gHGgg?t=125)====[?](https://youtu.be/w-vUj0gHGgg?t=125)==
    
    В JS для того чтобы создать объект - существует несколько подходов.
    
    Один из них - это использование функции конструктора, которое вызывается со специальным словом new.
    
    Результатом выполнения получается новый экземпляр класса.
    
    Ключевое слово new делает 4 вещи:
    
    - создает пустой объект
    - привязывает к созданному объекту - значение this (то есть this теперь указывает на вновь созданный объект)
    - каждый объект созданный функции - автоматически получает свойство prototype
    - возвращает значение this (если в реализации не указано иное)
- ==[Операторы «И» и «ИЛИ» (](https://youtu.be/G7hLwudGWL4?t=617)====[`&&`](https://youtu.be/G7hLwudGWL4?t=617)== ==[и](https://youtu.be/G7hLwudGWL4?t=617)== ==[`||`](https://youtu.be/G7hLwudGWL4?t=617)====[)?](https://youtu.be/G7hLwudGWL4?t=617)==
    
    В JS есть 3 логических оператора: И (&&), ИЛИ (||), и логическое отрицание НЕ (!).
    
    && - находит и возвращает первое ложное значение, либо последний операнд (Операнды — это **данные, обрабатываемые сценарием JavaScript**. В качестве операндов могут быть как простые типы данных, так и сложные, а также другие выражения) - когда все значение истинные.
    
    || - находит и возвращает первое истинное значение.
    
    Оба оператора используют короткое замыкание во избежания лишних затрат.
    
    Другими словами, как только находится подходящее значение - дальнейшая проверка не выполняется.
    
- ==[Для чего используется оператор](https://youtu.be/G4iYlbilozM?t=26)== ==[`!!`](https://youtu.be/G4iYlbilozM?t=26)== ==[(двойного отрицания)?](https://youtu.be/G4iYlbilozM?t=26)==
    
    Оператор двойного отрицания используется для привидения значения к логическому типу.
    
    Таким образом, используя его с любым типом данных - на выходе мы получаем true или false.
    
    Еще один способ преобразования данных к логическому типу - это объект Boolean(), который используется в качестве функции.
    
- ==[Как проверить, является ли значение массивом?](https://youtu.be/G4iYlbilozM?t=68)==
    
    Используется метод Array.isArray(), внутрь которого передается значение и на выходе метод возврашает булевое значение.
    
- ==[Для чего используется оператор](https://youtu.be/G4iYlbilozM?t=88)== ==[`%`](https://youtu.be/G4iYlbilozM?t=88)== ==[(остатка)?](https://youtu.be/G4iYlbilozM?t=88)==
    
    Проверяется кратность. Данный оператор возвращает остаток от деления двух чисел.
    
    Если в остатке есть какое-то число отличное от нуля - значит числа не кратны. Если возвращается ноль - значит кратны.
    
    Если делимое число меньше делителя, то нацело оно не делится (то есть результатом получается 0). А в остатке остается делимое число.
    
- ==[Как работает boxing/unboxing в JavaScript?](https://youtu.be/G4iYlbilozM?t=149)==
    
    Процесс объектной обертки - получил название boxing (упаковка).
    
    Такое оборачивание может быть: нативным (когда оно идет под капотом - как раз пример процесс объектной обертки) и явным (когда мы самостоятельно оборачиваем примитив в конструктор)
    
    unboxing - это обратный процесс (пример: методы toString и valueOf)
    
- ==[Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?](https://youtu.be/nvktMVFM0_M?t=30)==
    
    Мемоизация - это прием создания функции, способной запомнить ранее вычисленное значение, а также результат.
    
    Таким образом, при повторном вызове функции с одинаковыми аргументами - она не будет выполнена, а результат работы вернется из кэша.
    
    Минус: для хранения всех полученных результатов - нужно выделять дополнительную память.
    
- ==[Разница между оператором](https://youtu.be/nvktMVFM0_M?t=102)== ==[`in`](https://youtu.be/nvktMVFM0_M?t=102)== ==[и методом](https://youtu.be/nvktMVFM0_M?t=102)== ==[`hasOwnProperty`](https://youtu.be/nvktMVFM0_M?t=102)====[?](https://youtu.be/nvktMVFM0_M?t=102)==
    
    Оба подхода предназначены для проверки наличия определенного свойства в объекте.
    
    Разница между ними заключается в том, что:
    
    Оператор in проверяет наличие свойства не только в самом объекте, но и в его прототипах. В то время, как метод hasOwnProperty проверяет наличие свойства только в основном объекте.
    
- ==[Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?](https://youtu.be/nvktMVFM0_M?t=125)==
    
    В JS существует 2 способа передачи данных: по значению и по ссылке.
    
    - Когда копирование происходит по значению - это значит, что создается новое отдельное и независимое значение подобное оригиналу.
    - Когда копирование происходит по ссылке - то новая сущность не создается, а по сути происходит создание псевдонима для уже существующего значения (такой вариант копирования называется поверхностным)
    
    При глубоком копировании создается независимая копия, поэтому при изменении свойств в копируемом объекте - копия сохраняет свои значения.
    
    При поверхностном - копия также изменяет свои значения.
    
    Для того чтобы создать поверхностную копию объекта - его достаточно присвоить в новую переменную.
    
    Для глубокой копии можно использовать:
    
    - spread оператор
    - метод Object.assign()
    - или комбинацию JSON.parse(JSON.stringify())
- ==[Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?](https://youtu.be/nvktMVFM0_M?t=200)==
    
    Цепочка вызовов - это подход при котором методы объекта вызываются один за другим без дополнительного обращения к исходному объекту.
    
    В нативном JS это некоторые методы строк и массивов: .split().reverse().join().toUpperCase()
    
    В Promise это методы: .then().then().catch()
    
    Чтобы реализовать такую возможность самостоятельно - можно использовать замыкание.
    
    Либо (что кстати проще) - из методов возвращать контекст вызова this.
    
- ==[Что такое необъявленная переменная?](https://youtu.be/nvktMVFM0_M?t=236)==
    
    Необъявленная переменная - это переменные, которые объявляются без использования ключевых слов: var, let или const.
    
- ==[Как передаются параметры в функцию: по ссылке или по значению?](https://youtu.be/nvktMVFM0_M?t=280)==
    
    Параметры, которые передаются в функцию - всегда передаются по значению.
    
- ==[Что такое прототип объекта в JavaScript?](https://youtu.be/yvOXvZ8aEFo?t=287)==
    
    Прототип - это резервное хранилище свойств и методов объекта, которое автоматически используется при поиске.
    
- ==[Как работает метод](https://youtu.be/V-m0sQ-hW58?t=28)== ==[`Object.create()`](https://youtu.be/V-m0sQ-hW58?t=28)====[?](https://youtu.be/V-m0sQ-hW58?t=28)==
    
    Этот метод - это самый простой способ наследования одного объекта от другого без вызова функции конструктора.
    
    ![[Untitled 1 34.png|Untitled 1 34.png]]
    
- ==[Разниц между](https://youtu.be/xZLxdts7ZW4?t=374)== ==[`Object.freeze()`](https://youtu.be/xZLxdts7ZW4?t=374)== ==[и](https://youtu.be/xZLxdts7ZW4?t=374)== ==[`Object.seal()`](https://youtu.be/xZLxdts7ZW4?t=374)====[?](https://youtu.be/xZLxdts7ZW4?t=374)==
    
    Смотри видео
    
- ==[Разница между методами](https://youtu.be/xZLxdts7ZW4?t=435)== ==[`slice()`](https://youtu.be/xZLxdts7ZW4?t=435)== ==[и](https://youtu.be/xZLxdts7ZW4?t=435)== ==[`splice()`](https://youtu.be/xZLxdts7ZW4?t=435)====[?](https://youtu.be/xZLxdts7ZW4?t=435)==
    
    Метод splice() меняет содержимое массива, удаляя существующие элементы или заменяя их на другие элементы. А также он умеет добавлять в массив новые элементы.
    
    Особенность метода splice() в том, что он модифицирует исходный массив.
    
    Что же касается метода slice() - то он возвращает неглубокую копию массива. Данный метод не модифицирует исходный массив, он лишь возвращает описанное при его вызове часть этого массива.
    
- ==[Как работают методы](https://youtu.be/xZLxdts7ZW4?t=488)== ==[`find()`](https://youtu.be/xZLxdts7ZW4?t=488)====[,](https://youtu.be/xZLxdts7ZW4?t=488)== ==[`findIndex()`](https://youtu.be/xZLxdts7ZW4?t=488)== ==[и](https://youtu.be/xZLxdts7ZW4?t=488)== ==[`indexOf()`](https://youtu.be/xZLxdts7ZW4?t=488)====[?](https://youtu.be/xZLxdts7ZW4?t=488)==
    
    Все 3 метода используются для поиска элемента в массиве.
    
- ==[Плюсы и минусы использования](https://youtu.be/xZLxdts7ZW4?t=549)== ==[`use strict`](https://youtu.be/xZLxdts7ZW4?t=549)====[?](https://youtu.be/xZLxdts7ZW4?t=549)==
    
    Смотри видео
    
- ==[Разница между методами](https://youtu.be/ngyOYuTrUk8?t=385)== ==[`push()`](https://youtu.be/ngyOYuTrUk8?t=385)====[,](https://youtu.be/ngyOYuTrUk8?t=385)== ==[`pop()`](https://youtu.be/ngyOYuTrUk8?t=385)====[,](https://youtu.be/ngyOYuTrUk8?t=385)== ==[`shift()`](https://youtu.be/ngyOYuTrUk8?t=385)== ==[и](https://youtu.be/ngyOYuTrUk8?t=385)== ==[`unshift()`](https://youtu.be/ngyOYuTrUk8?t=385)====[?](https://youtu.be/ngyOYuTrUk8?t=385)==
    
    Все 4 методы используются для работы с массивом, а если быть поточнее - удаляют или добавляют элемент с начала или конца массива.
    
    - push() - добавляет элемент в конец массива
    - unshift() - добавляет элемент в начало массива
    - pop() - удаляет из массива последний элемент
    - shift() - удаляет из массива первый элемент
- ==[Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?](https://youtu.be/ngyOYuTrUk8?t=445)==
    
    Иммутабельность - это тоже самое, что и не изменяемый объект.
    
    Если состояние является иммутабельным - это означает, что оно не может быть изменено после создания.
    
    К плюсам иммутабельности можно отнести:
    
    - простое и быстрое отслеживание изменений (например: не нужно отдельно сравнивать значения каждого поля вложенного объекта - можно просто сравнить ссылки на объекты и отсеить вложенные ветки сравнений)
    - более безопасное использование и тестирование
    - разный уровень производительности, зависящий от конкретной реализации структур данных, с которыми ведется работа
    
    Последний пункт также является и минусом - так как в одном случае будет прирост скорости работы, а в другом можно получить деградацию.
    
    Для того чтобы достичь иммутабельности JS предоставляет 2 нативных способа:
    
    - это использование const и метода Object.freeze()
    - использование сторонних библиотек - [**Immutable.js**](https://immutable-js.com/)**,** [**mori**](https://swannodette.github.io/mori/)
- ==[Типы всплывающих окон в JavaScript?](https://youtu.be/ngyOYuTrUk8?t=515)==
    
    И тут речь идет о 3-х типах модальных окон, которые JS поддерживает из коробки:
    
    - alert() - выводит диалоговое окно с кнопкой ОК.
    - confirm() - отображает диалоговое окно с кнопками ОК и cancel.
    - prompt() - диалоговое окно с кнопками ОК и cancel, а также с полем для ввода данных
- ==[Типы объектов JavaScript?](https://youtu.be/ngyOYuTrUk8?t=595)==
    
    В JS можно выделить 9 основных типов объектов:
    
    - объект массива - используется для обработки данных
    - строковый объект - используется со строковыми значениями
    - объект даты - используется для манипулирования датой и временем
    - числовой объект - работает с числовыми данными
    - логический объект - предоставляет истинные или ложные значения
    - функциональный объект - небольшой фрагмент кода, который выполняет некоторые функции
    - объект Math - используется для математических операций
    - объект RegExp - служит для сопоставления текста с шаблоном
    - объект Object - создает пользовательские объекты
- ==[Парадигмы программирования в JavaScript?](https://youtu.be/ngyOYuTrUk8?t=653)==
    
    JS - мульти-парадигмальный язык, поддерживающий процедурное программирование на ряду с ООП (Объектно-ориентированном программированием) И ФП (Функциональном программированием).
    
    Следует отметить, что JS поддерживает ООП - именно с прототипнам наследованием.
    
    ООП базируется на принципах:
    
    - наследование
    - полиморфизм
    - инкапсуляции
    - абстракции
    
    ФП основывается на:
    
    - чистых функциях
    - иммутабельности (или неизменяемости)
    - ссылочной прозрачности
    - замыканиях
    - функциях первого класса
    - функция высшего порядка
    
    **Процеду́рное программи́рование** — **программирование**на **императивном** языке, при котором последовательно выполняемые операторы можно собрать в подпрограммы, то есть более крупные целостные единицы кода, с помощью механизмов самого языка.
    
- ==[Типы ошибок в JavaScript?](https://youtu.be/ovV8GhIkzBE?t=754)==
    
    В JS можно выделить 3 основных типа ошибок:
    
    - ошибки времени загрузки - это ошибки, которые возникают при загрузке веб-страницы
    - ошибки времени выполнения - это ошибки, возникающие из-за неправильного использование команды внутри языка HTML
    - логические ошибки - это ошибки, которые возникают из-за неправильной логики, выполняемой в функциях или других операциях.
    
    Исходя из данной классификации можно выделить следующие варианты ошибок:
    
    - EvalError - ошибка в конструкции eval - по сути является устаревшей
    - RangeError - происходит, когда число не попадает в диапазон
    - ReferenceError - ошибка ссылки, когда логика ссылается на не существующий элемент в коде
    - SyntaxError - синтаксическая ошибка
    - TypeError - ошибка при использовании в логики неверного типа
    - URIError
- ==[Разница между](https://youtu.be/ovV8GhIkzBE?t=835)== ==[`typeof`](https://youtu.be/ovV8GhIkzBE?t=835)== ==[и](https://youtu.be/ovV8GhIkzBE?t=835)== ==[`instanceof`](https://youtu.be/ovV8GhIkzBE?t=835)====[?](https://youtu.be/ovV8GhIkzBE?t=835)==
    
    - typeof
    
    Это оператор, который возвращает строку с типом того, что передается.
    
    Он проверяет - принадлежит ли значение одному из 8 основных типов.
    
    - instanceof
    
    Он намного умнее - он работает на уровне прототипов.
    
    В частности он проверяет - появляется ли правый операнд где-нибудь в цепочки прототипов левого.
    
    В большинстве случаев - это означает, что объект был создан с помощью этого конструктора или его потомка.
    
    Оператор проверяет текущий объект и возвращает true - если объект имеет указанный тип.
    
    И false - если объект данный тип не имеет.
    
    ![[Untitled 2 24.png|Untitled 2 24.png]]
    
- ==[JavaScript статически, или динамически типизированный язык?](https://youtu.be/V-m0sQ-hW58?t=98)==
    
    JS - это язык с динамической типизацией.
    
    В языке с динамической типизацией - тип переменной проверяется во время выполнения.
    
    В отличии от языка со статической типизацией, где тип переменной - проверяется во время компиляции.
    
    И поскольку JS - это язык со слабой динамической типизацией - переменные JS не связаны ни с каким типом - а это значит, что переменная может содержать значение любого типа данных.
    
    Таким образом, например - переменная, к которой присвоен числовой тип может-быть преобразована в строковый тип и это не вызовет никаких ошибок и исключений.
    
- ==[Что такое регулярное выражение (Regular Expression)?](https://youtu.be/V-m0sQ-hW58?t=146)==
    
    Регулярные выражения - это шаблоны, используемые для сопоставления последовательности символов в строках.
    
    В JS регулярные выражения также являются объектами.
    
    Создать регулярные выражения можно 2 способами:
    
    - использование литерала регулярного выражения
    - вызвать функцию конструктор RegExp()
    
    ![[Untitled 3 14.png|Untitled 3 14.png]]
    
- ==[Что такое рекурсия?](https://youtu.be/V-m0sQ-hW58?t=220)==
    
    Для начала следует отметить, что рекурсия - это не фича только языка JS.
    
    Данная логика применима для любого языка программирования.
    
    Если говорить просто то рекурсия - эта логика при которой функция в своем теле вызывает саму себя.
    
    Функцию, вызывающую саму себя - называют рекурсивной функцией.
    
    А вызов рекурсивной функцией - называется рекурсивным вызовом.
    
    Одной из самых распространенных задач на собеседовании по рекурсии - может быть сумма чисел в последовательности Фибоначчи:
    
    Когда есть функция, принимающая число - это число раскладывается на ряд Фибоначчи и по результату возвращается сумма вхождений.
    
      
    
    Реализацию можно видеть в данном коде:
    
    Функция называется fibonacci.
    
    Внутри она содержит простое условие - если входящее число ≤ 1 - то оно возвращается, если нет - то возвращается сумма из 2-х предыдущих значений, каждое из которых пробрасывается в эту же функцию.
    
    Это и есть рекурсия - то есть вызов функции из самой себя.
    
    ![[Untitled 4 10.png|Untitled 4 10.png]]
    
- ==[Что такое прототип (Prototype) объекта?](https://youtu.be/V-m0sQ-hW58?t=290)==
    
    Если говорить просто, то прототип - это план объекта.
    
    Если он существует в текущем объекте - то используется, как резерв для свойств и методов. То есть если какого-то значение нет в объекте - оно ищется в прототипе.
    
    Это способ обмена свойствами и функциональностью между объектами.
    
    Когда свойство не существует в объекте - оно ищется в его прототипе, а если нет в прототипе - то в прототипе прототипа и т д. , до тех пор пока не найдено свойство с таким же именем в цепочке прототипов.
    
    Конец цепочки прототипов - это Object.prototype
    
- ==[Какие методы используются в регулярных выражениях?](https://youtu.be/XtQPrt8G0n8?t=495)==
    
    Регулярные выражения используются в методах **test и exec объекта RegExp и с методами match , replace , search , и split объекта String.**
    
- ==[Что такое полифил (polyfill)?](https://youtu.be/XtQPrt8G0n8?t=557)==
    
    По сути это блок кода, который выполняет аналогичную логику метода для которого и был написан.
    
    Полифилы используются для обеспечения работы современного JS кода для старых браузеров.
    
    Это делается за счет реализации новых возможностей языка на старом синтаксисе.
    
    Сам процесс преобразования нового года в старый - называется транспиляция.
    
    В большинстве своем полифилы используются для логики, которая может работать некорректно в разных браузерах, либо в старых версиях браузера.
    
    Также полифилом можно считать - любую пользовательскую функцию, которая решает какие-то проблемы кроссбраузерности.
    
- ==[Что такое](https://youtu.be/XtQPrt8G0n8?t=600)== ==[`switch/case`](https://youtu.be/XtQPrt8G0n8?t=600)====[? Правила использования](https://youtu.be/XtQPrt8G0n8?t=600)== ==[`switch/case`](https://youtu.be/XtQPrt8G0n8?t=600)====[?](https://youtu.be/XtQPrt8G0n8?t=600)==
    
    switch/case - является альтернативой if/else и представляет собой более наглядный способ выполнения кода в зависимости от переданного условия.
    
    ![[Untitled 5 7.png|Untitled 5 7.png]]
    
- ==[Типы функций по способности принимать другие функции?](https://youtu.be/XtQPrt8G0n8?t=726)==
    
    Функция может принимать другие функции, как аргументы или же возвращать их.
    
    В JS можно выделить 3 основных типа функций в зависимости от принимаемых данных:
    
    - функция первого порядка - эта функция, которая не принимает другую функцию в качестве аргумента и не возвращает функцию - как значение.
    - функция высшего порядка - функция, которая принимает другую функцию в качестве аргумента или возвращает функцию - как значение.
    - унарная функция - эта функция, которая принимает только один аргумент, который не является функцией.
    
    ![[Untitled 6 6.png|Untitled 6 6.png]]
    
- ==[Что такое выражения (expression) и инструкции (statement) в JavaScript?](https://youtu.be/VYQl2GhbCUs?t=706)==
    
    - expression
    
    Выражения (expression) - это фрагмент кода, некая комбинация значений, переменных, операций и функций, которые в ходе своего выполнения - приводят к вычислению и возврату некоторого значения (Например - числа, строки или значения логического типа).
    
    Выражения могут-быть сколь угодно длинными - но они всегда будут приводить к вычислению некоторого одного значения.
    
    - statement
    
    Инструкция (statement) - это фрагмент кода, который выполняет какое-то определенное действие. Или если говорить другими словами - является командой.
    
    (Примеры инструкций - это if/else, while, for, switch/case и т д.
    
    ![[Untitled 7 6.png|Untitled 7 6.png]]
    
- ==[Разница между](https://youtu.be/VYQl2GhbCUs?t=762)== ==[`.some()`](https://youtu.be/VYQl2GhbCUs?t=762)== ==[и](https://youtu.be/VYQl2GhbCUs?t=762)== ==[`.every()`](https://youtu.be/VYQl2GhbCUs?t=762)====[?](https://youtu.be/VYQl2GhbCUs?t=762)==
    
    Оба метода предназначены для перебора массива.
    
    Они проверяют каждый элемент массива - на соответствие условием в переданной функции - после чего возвращают полученный результат.
    
    Метод some() - перебирает массив и смотрит - соответсвует ли один конкретный элемент в массиве логическому условию.
    
    Метод every() - можно использовать, чтобы узнать соответствуют ли все элементы массива логическому условию.
    
    Оба метода возвращают булевое значение.
    
    ![[Untitled 8 6.png|Untitled 8 6.png]]
    
- ==[Как сгенерировать случайное число в JavaScript?](https://youtu.be/VYQl2GhbCUs?t=801)==
    
    Самый простой вариант - это воспользоваться функцией Math.random() - она возвращает случайное число в диапазоне от 0 до 1, не включая единицу.
    
    ![[Untitled 9 5.png|Untitled 9 5.png]]
    
- ==[Как работает «сборщик мусора» в JavaScript?](https://youtu.be/trriSYNrHw4?t=786)==
    
    Основной алгоритм сборки мусора - называется алгоритм пометок (Mark-Sweep).
    
    Согласно этому алгоритму сборщик мусора регулярно выполняет следующие шаги:
    
    - он помечает, запоминает все корневые объекты
    - затем идет по ним и помечает все ссылки из них
    - далее он идет по помеченным объектам и отмечает их ссылки
    - все посещенные объекты запоминаются, чтобы в будущем не посещать один и тот же объект - дважды, и так далее - пока не будут посещены все достижимые из корней - ссылки
    - все не помеченные объекты в заключении - удаляются