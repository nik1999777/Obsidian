  

- [Что такое DOM?](https://youtu.be/1eIRTdgzHtw?t=471)
    
    DOM (Document Object Model) - это объектная модель документа, которую браузер создает в памяти компьютера на основание HTML кода, полученного им от сервера.
    
    Если говорить просто:
    
    HTML код - это текст страницы, а DOM - это набор связанных объектов, созданных браузером при парсинге этого текста.
    
    По сути DOM это интерфейс, используя который JS может взаимодействовать с элементами страницы.
    
- [Что такое распространение события (Event Propagation)?](https://youtu.be/1eIRTdgzHtw?t=522)
    
    Распространение события - это механизм, который отрабатывает, когда какое-либо событие происходит в документе.
    
    Событие распространяется от объекта window до вызывающего его элемента. При этом событие последовательно затрагивает всех предков целевого элемента.
    
    Существуют 3 основные фазы распространения событий:
    
    - фаза погружения (capturing phase) – событие начинается от корня документа и проходит по DOM дереву до целевого элемента
    - фаза цели (target phase) – событие достигает целевого элемента
    - фаза всплытия (bubbling stage) – событие возвращается обратно до window параллельно вызывая все события на родительских элементах
- [Что такое делегирование событий (Event Delegation)?](https://youtu.be/1eIRTdgzHtw?t=576)
    
    Делегирование - это прием разработки, когда вместо того чтобы вешать кучу однотипных обработчиков на все элементы - можно добавить только один на общего предка (родительский элемент)
    
- [Разница между](https://youtu.be/CjdCxxqObaM?t=650) [`e.preventDefault()`](https://youtu.be/CjdCxxqObaM?t=650) [и](https://youtu.be/CjdCxxqObaM?t=650) [`e.stopPropagation()`](https://youtu.be/CjdCxxqObaM?t=650)[?](https://youtu.be/CjdCxxqObaM?t=650)
    
    Метод e.preventDefaut() - отключает поведение элемента по умолчанию.
    
    Метод e.stopPropagation - отключает распространение события, то есть всплытие или погружение.
    
- [Методы поиска элементов в DOM?](https://youtu.be/CjdCxxqObaM?t=678)
    
    В браузерном JS (DOM) - существует 6 основных методов для поиска произвольных элементов на странице:
    
    - getElementById()
    - getElementsByTagName()
    - getElementsByName()
    - querySelectorAll()
    - querySelector()
    - getElementsByClassName()
- [Разница между](https://youtu.be/kx3dR6ztICU?t=539) [`event.target`](https://youtu.be/kx3dR6ztICU?t=539) [и](https://youtu.be/kx3dR6ztICU?t=539) [`event.currentTarget`](https://youtu.be/kx3dR6ztICU?t=539)[?](https://youtu.be/kx3dR6ztICU?t=539)
    
    event.target - это элемент, в котором происходит событие или элемент вызвавший событие
    
    event.currentTarget - это непосредственно элемент, которому прикреплен прослушиватель события
    
- [Разница между](https://youtu.be/kx3dR6ztICU?t=580) [`.stopPropagation()`](https://youtu.be/kx3dR6ztICU?t=580) [и](https://youtu.be/kx3dR6ztICU?t=580) [`.stopImmediatePropagation()`](https://youtu.be/kx3dR6ztICU?t=580)[?](https://youtu.be/kx3dR6ztICU?t=580)
    
    При наступлении события в браузере - происходит всплытие.
    
    В результате обработчики вызываются на самом вложенном элементе, а затем по цепочки вложенности на всех родителях.
    
    Остановить такое поведение, то есть всплытие - можно в любом промежуточном обработчике.
    
    Для этого достаточно добавить один из 2-х методов:
    
    - stopPropagation()
    - stopImmediatePropagation()
    
    Разница между ними в том, что stopPropagation() - отменяет дальнейшее всплытие, но на текущем элементе все обработчики срабатывают.
    
    А stopImmediatePropagation() - не только остановит дальнейшее всплытие, но и остановит обработку событий на текущем элементе.
    
- [Разница между событиями](https://youtu.be/kx3dR6ztICU?t=627) [`load`](https://youtu.be/kx3dR6ztICU?t=627) [и](https://youtu.be/kx3dR6ztICU?t=627) [`DOMContentLoaded`](https://youtu.be/kx3dR6ztICU?t=627)[?](https://youtu.be/kx3dR6ztICU?t=627)
    
    Оба события происходят при загрузке веб страницы в браузере.
    
    Разница между ними в том, что DOMContentLoaded - отрабатывает когда браузер полностью загрузил HTML и после чего было построено DOM дерево, однако внешние ресурсы: стили, скрипты, картинки, шрифты - еще не прогружены.
    
    А load - это событие, когда браузер загрузил HTML и все зависимые внешние ресурсы.
    
    Из этого следует, что DOMContentLoaded срабатывает раньше, чем load.
    
- [Разница между attribute и property у DOM-элементов?](https://youtu.be/IooJ3P2VUYs?t=659)
    
    attribute - это статичное значение определенного DOM элемента, которое не изменяемо и в большинстве своем может быть добавлена в HTML разметку.
    
    property - это вычисленное значение DOM элемента, причем его особенность в том, что оно может динамически изменяться.
    
- [Разница между HTMLCollection и NodeList?](https://youtu.be/IooJ3P2VUYs?t=705)
    
    HTMLCollection - это динамическая HTML коллекция, которая представляет собой массиво-подобный, итерируемый объект дочерних элементов.
    
    NodeList - это статический список node (узлов), в которые входят все найденные в документе элементы.
    
    Разница в том, что HTMLCollection может изменяться каждый раз после обновления HTML разметки, а NodeList - не меняется после формирования, даже если изменился HTML код страницы.
    
- [Как динамически добавить элемент на HTML-страницу?](https://youtu.be/nvktMVFM0_M?t=551)
    
    Создание новых элементов осуществляется с помощью метода createElement().
    
    С помощью classList.add() на созданный элемент можно навесить класс.
    
    Используя createTextNode() - можно создать текстовую node.
    
    Которую можно поместить внутрь созданного элемента с помощью appendChild().
    
    И лишь когда новый элемент полностью готов, используя тот же метод appendChild() - он помещается в основную разметку DOM дерева.
    
    ```JavaScript
    const newP = document.createElement("p");
    
    newP.classList.add("pStyle");
    
    const textNode = document.createTextNode("Hello world");
    
    newP.appendChild(textNode);
    
    document.getElementById("test").appendChild(newP);
    ```
    
- [Типы узлов DOM-дерева?](https://youtu.be/7TvS0iKR3_c?t=201)
    
    Спецификация браузерного JS насчитывает целых 12 типов узлов.
    
    Однако на практике чаще всего применяются только 4:
    
    - document - входная точка DOM - дерева
    - elementNode - узлы элементы (по сути - это узлы обычных HTML тэгов из которых состоит страница)
    - textNode - текстовые узлы (содержат текст)
    - commentNode - узлы комментарии (любой комментарий HTML страницы становится отдельным типом узла)
    
    Каждому из типов соответсвует свое цифровое значение от 1 до 12.
    
    Для того чтобы проверить к какому типу относится узел - используется свойство nodeType.
    
- [Свойства для перемещения по DOM-дереву?](https://youtu.be/7TvS0iKR3_c?t=245)
    
    Существует 12 основных свойств, которые помогают перемещаться по DOM дереву от найденного элемента.
    
    Делятся они на 2 большие группы:
    
    - для всех типов узлов
    - для того чтобы передвигаться только по узловым элементам
    
    childNodes - возвращает коллекцию дочерних элементов
    
    firstChild, lastChild - обеспечивает доступ к первому и последнему дочернему элементам
    
    previosSibling, nextSibling - свойства для возврата соседей (первое - возвращает предыдущий узел, второе - следующий узел) - все это происходит в границах одного элемента, то есть общего родителя
    
    parenNode - для того чтобы получить родительский узел
    
    ![[Untitled 94.png|Untitled 94.png]]
    
- [Виды событий в JavaScript?](https://youtu.be/7TvS0iKR3_c?t=318)
    
    Их очень много.
    
    Здесь перечислены основные виды.
    
    ![[Untitled 1 35.png|Untitled 1 35.png]]
    
- [Как добавить обработчик события на DOM-элемент?](https://youtu.be/7TvS0iKR3_c?t=425)
    
    В браузерном JS есть 3 основных способа для того, чтобы добавить обработчик на элемент:
    
    - встроенный обработчик события - в этом случае добавления происходит непосредственно в HTML разметке на элемент
    - свойство обработчика событий
    - добавление события через функцию addEventListener()
- [Как удалить обработчик события с DOM-элемента?](https://youtu.be/7TvS0iKR3_c?t=505)
    
    Использовать функцию removeEventListener()
    
- [Сколько аргументов принимает](https://youtu.be/7TvS0iKR3_c?t=538) [`addEventListener`](https://youtu.be/7TvS0iKR3_c?t=538)[?](https://youtu.be/7TvS0iKR3_c?t=538)
    
    Она принимает 3 аргумента (два обязательных и один опциональный):
    
    - 1 - это имя события без приставки on
    - 2 - callback функция, которая будет вызвана при срабатывании события
    - 3 - является опциональным и может быть либо объектом, либо булевом значением (это свойства once, capture, passive)
- [Разница между](https://youtu.be/xZLxdts7ZW4?t=621) [`innerHTML`](https://youtu.be/xZLxdts7ZW4?t=621) [и](https://youtu.be/xZLxdts7ZW4?t=621) [`outerHTML`](https://youtu.be/xZLxdts7ZW4?t=621)[?](https://youtu.be/xZLxdts7ZW4?t=621)
    
    Оба свойства предназначаются для возврата разметки HTML элемента.
    
    innerHTML - содержит HTML код, который находится внутри найденного элемента. При установке нового значения этого свойства - внутренний HTML код изменяется и рендерится браузером заново.
    
    outerHTML - аналогично. Разница лишь заключается в том, что outerHTML возвращает полный HTML код найденного элемента, а не его часть.
    
- [Расскажите про координаты в браузере?](https://youtu.be/70VnuTXi4Wk?t=644)
    
    Чтобы перемещать и позиционировать элементы на экране - в браузере имеется система координат.
    
    Оси координат начинаются в левом верхнем углу экрана и идут вправо для - оси X и вниз - для оси Y.
    
    Позиционирование с помощью координат - может быть относительно окна браузера или относительного отдельного элемента.
    
    Всего существует 2 системы координат:
    
    - одна начинается - от угла HTML страницы - с помощью нее можно определять как элемент расположен относительно всей страницы.
    - а вторая - от угла окна браузера - можно определять как элемент расположен относительно окна браузера и того, что там находится.
    
    Объекты события мыши и touch события - содержат координаты места на экране и в документе, где событие произошло.
    
    - pageX и pageY - для документа
    - clientX и clientY - для экрана
    
    Координатами элемента - является расстояние в пикселях от осей системы координат до левого верхнего угла.
    
    `getBoundingClientRect()` - c помощью этого метода можно получить подробные данные о координатах элемента и его размере.
    
    ![[Untitled 2 25.png|Untitled 2 25.png]]
    
- [Разница между](https://youtu.be/XtQPrt8G0n8?t=28) [`JSON`](https://youtu.be/XtQPrt8G0n8?t=28) [и](https://youtu.be/XtQPrt8G0n8?t=28) [`XML`](https://youtu.be/XtQPrt8G0n8?t=28)[?](https://youtu.be/XtQPrt8G0n8?t=28)
    
    JSON - это формат обмена данными.
    
    XML - это язык разметки, к которому можно задавать синтаксис, структуру, типы данных и их модель.
    
    JSON позволяет определять данные любого формата, в то время как в XML - есть свои правила и ограничения.
    
    JSON - более компактный, так как представляет из себя формат - ключ и значение.
    
    XML - объемный за счет того, что данные оборачиваются в разметку и за счет этого нюанса парсинг данных в XML формате - происходит медленнее, чем парсинг данных в JSON формате.
    
    Оба могут быть использованы для передачи данных и для работы с обоими стандартами - используются различные фреймворки и библиотеки.
    
    ![[Untitled 3 15.png|Untitled 3 15.png]]