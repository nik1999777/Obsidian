  

- [Разница между синхронными и асинхронными функциями?](https://youtu.be/kx3dR6ztICU?t=681)
    
    Синхронные функции являются блокирующими, в то время как асинхронные - нет.
    
    Другими словами:
    
    Во время выполнения JS, когда интерпретатор натыкается на синхронную функцию - он блокирует дальнейшее выполнение кода до того момента, пока данная функция не будет выполнена.
    
    А синхронные функции - не блокируют дальнейшее выполнение скрипта.
    
    Именно поэтому различные тяжелые операции по типу запроса данных - делают асинхронными.
    
- [Что такое AJAX?](https://youtu.be/IooJ3P2VUYs?t=547)
    
    AJAX (Asynchronous Javascript and XML — «асинхронный JavaScript и XML»)
    
    Так что сама по себе - это не технология, а термин, который описывает подход использования нескольких существующих технологий вместе для работы на стороне клиента и для создания асинхронных веб приложений.
    
    С помощью AJAX веб приложения могут отправлять данные на сервер и получать их с сервера асинхронно.
    
    Таким образом происходит отделение логики представления (то есть отрисовки UI) от логики обмена данными.
    
    В результате страницы могут динамически изменять содержимое без полной перезагрузки.
    
    Поэтому они работают быстрее и становятся более отзывчивыми к действиям пользователя.
    
    На практике же для получения или передаче данных - используют формат данных JSON (вместо XML). А для работы с асинхронными запросами - используют метод fetch (вместо устаревшего XMLHttpRequest)
    
- [Что такое same-origin policy в контексте JavaScript?](https://youtu.be/IooJ3P2VUYs?t=612)
    
    same-origin policy (принцип одинакового источника) - определяет как документ или скрипт загруженный из одного источника - может взаимодействовать с ресурсом из другого источника.
    
    Другими словами:
    
    Этот принцип не позволяет JS выполнять запросы за границей домена.
    
    Источник определяется как комбинация схемы url + mini host + номер порта.
    
    Это помогает изолировать потенциально вредоносные документы и не дает вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой.
    
    Но для того, чтобы разрешить такие кросс-доменные запросы - используется CORS.
    
- [Что такое цикл событий (event loop) и как он работает?](https://youtu.be/w-vUj0gHGgg?t=293)
    
    В общих чертах механизм звучит следующем образом:
    
    JS является - однопоточным (движок JS в одну единицу времени может выполнять только одну операцию).
    
    Для такого потока выделяется область памяти, которая называется stack.
    
    В stack (стэке) хранятся frames (фреймы) - это локальные переменные и аргументы вызываемых функций.
    
    Список событий, которые должны обрабатываться - формирует очередь событий.
    
    Когда stack освобождается - движок может обработать любое событие из этой очереди.
    
    Координирование данного процесса - это и есть event loap.
    
    event loap - по сути это бесконечный цикл, в котором выполняются многочисленные обработчики событий.
    
    Если очередь пустая, движок браузера ждет, когда поступит новое событие. Если не пустая - первое событие в очереди извлекается и обработчик начинает его выполнять. И так до бесконечности.
    
- [Что такое промисы (Promises)?](https://youtu.be/G4iYlbilozM?t=371)
    
    Promises - это один из приемов работы с асинхронным кодом в JS.
    
    Promises - это объект, который может вернуть одно значение в будущем.
    
    Либо выполненное значение, либо причина по которой Promises не был выполнен (то есть ошибку)
    
    Promises может находится в одном из 3-х возможных состояний:
    
    - выполнено (fulfilled_)_
    - отклонено (rejected)
    - ожидание (pending)
    
    При использовании Promises можно добавлять callback функции для обработки выполненного значения или причины отказа.
    
    Для такого взаимодействия используется цепочка вызовов (chaining_)_ с методами then / catch
    
- [Плюсы и минусы использовании Ajax?](https://youtu.be/yvOXvZ8aEFo?t=352)
    
    Плюсы:
    
    - повышение интерактивности - новые данные с сервера могут быть добавлены динамически без перезагрузки всей страницы
    - сокращение кол-ва обращений к серверу - скрипты и таблицы стилей нужно запрашивать только один раз
    - состояние может быть сохранено на странице - переменные JS и состояние DOM сохраняется, поскольку основная страница контейнера не перезагружается
    
    Минусы:
    
    - проблемная реализация добавления динамической веб страницы в закладки - так как данные добавляются динамически, то любые операции нужно хранить в url адресе, чтобы при повторном открытии не начинать все с нуля
    - AJAX не работает, если в браузере отключен JS
    - некоторые поисковые роботы - не выполняют JS и не видят данные загружаемые при помощи него
- [Подходы при работе с асинхронным кодом?](https://youtu.be/yvOXvZ8aEFo?t=410)
    
    Асинхронный код или асинхронные функции - это функции, которые не блокируют основной поток исполнения.
    
    Из-за такой особенности, если между функциями нам нужна какая-то зависимость - то их нужно обрабатывать последовательно.
    
    Для этого можно воспользоваться 3 подходами:
    
    - использование callback - механизм прост. Внутри одной асинхронной функции - записывается другая и т д. До тех пор пока не получается многоуровневая вложенность
    - использование promise - в этом случае асинхронная функция возвращает специальный объект, который называется promise. Используя его, а также специальные методы then и catch - можно обрабатывать получаемые данные и передавать их дальше по цепочки
    - конструкция async / await - для общей функции добавляется ключевое слово async, а внутри к каждой асинхронной операции добавляется await. Таким образом исполнение асинхронного кода - идет на подобие синхронного
- [Преимущества использовании промисов вместо колбэков?](https://youtu.be/yvOXvZ8aEFo?t=481)
    - помогает избежать callback hell (вложенность callback), который может оказаться не читаем
    - упрощает написание последовательного читаемого асинхронного кода с помощью then, а также обработку ошибок с помощью catch
    - упрощает написание параллельного асинхронного кода с помощью Promise.all()
- [Что такое коллбэк-функция (Callback)? Что такое Callback Hell?](https://youtu.be/V-m0sQ-hW58?t=348)
    
    Сallback функция или функция обратного вызова - эта передача исполняемого кода в качестве одного из параметров в другой код.
    
    Другими словами - эта передача одной функции в виде параметра в другую.
    
    Такой обратный вызов - позволяет функции исполнять код, который задается в аргументах при ее вызове.
    
    Сallback функции - очень распространены в JS и могут использоваться: :
    
    - в функция высшего порядка - таких как: map(), filter(), reduce() и т д.
    - таймерах и асинхронных функция - чтобы гарантировать правильный порядок вызова.
    - а также в браузерном JS - например при добавлении события.
    
    В случаи использовании callback функций в асинхронных функциях - может получиться случай так называемого callback hell.
    
    Callback hell - эта такая вложенность колбэков, при которой получается несколько уровней. То есть первая функция вызывает вторую, вторая - третью, третья - четвертую и т д.
    
    В результате получается плохо читаемый код, который трудно поддерживать.
    
    ![[Untitled 95.png|Untitled 95.png]]
    
- [Что такое](https://youtu.be/V-m0sQ-hW58?t=417) [`async/await`](https://youtu.be/V-m0sQ-hW58?t=417)[?](https://youtu.be/V-m0sQ-hW58?t=417)
    
    async/await - это новый способ написания асинхронного или не блокирующего кода в JS.
    
    Он построен на основе - промисов - и это делает написание асинхронного кода более читаемым и чистым, чем - промисы и callback-функции.
    
    async/await - заставляет код, который работает асинхронно выглядеть как синхронный код - это именно то, ради чего его используют.
    
    Ключевое слово async перед объявлением функции - заставляет функцию неявно возвращать promise.
    
    Ключевое слово await - можно использовать только внутри асинхронной функции.
    
    Использование await - в любой другой функции, которая не является асинхронной - вызовет ошибку.
    
    await - ожидает возврата выражения из правой части (предположительно promise) перед выполнением следующий строки кода - таким образом асинхронный код выполняется последовательно.
    
    Особенно это полезно - если один запрос зависит от результатов другого.
    
    Используется async/await - чаще с конструкцией try/catch .
    
    ![[Untitled 1 36.png|Untitled 1 36.png]]
    
- [Разница между](https://youtu.be/XtQPrt8G0n8?t=782) [`Promise.all()`](https://youtu.be/XtQPrt8G0n8?t=782)[,](https://youtu.be/XtQPrt8G0n8?t=782) [`Promise.any()`](https://youtu.be/XtQPrt8G0n8?t=782) [и](https://youtu.be/XtQPrt8G0n8?t=782) [`Promise.race()`](https://youtu.be/XtQPrt8G0n8?t=782)[?](https://youtu.be/XtQPrt8G0n8?t=782)
    
    Для начала следует отметить - что все 3 метода предназначены для работы с промисами. И в качестве аргумента - они принимают массив промисов.
    
    `Promise.all()` - это промис, принимающий массив других промисов в качестве аргумента и возвращающий результаты выполнения промисов или ошибку при отклонении одного из них. Основное отличие, что все promise-ы должны - resolve-нуться - тогда будет получен результат.
    
    `Promise.race()` - возвращает результат первого выполненного или отклоненного промиса из переданных ему в виде массива промисов. То есть результат возвращается из первого resolve-нутого или reject-нутого промиса.
    
    `Promise.any()` - это комбинация 2-х ранее описанных вариантов. Вернет результат первого resolve-нутого промиса, то есть отработает как `Promise.race()` . Но reject - вернется только в том случае - если упадут все переданные промисы.
    
    ![[Untitled 2 26.png|Untitled 2 26.png]]
    
- [Расскажите про статический метод](https://youtu.be/trriSYNrHw4?t=896) [`.allSettled()`](https://youtu.be/trriSYNrHw4?t=896)[?](https://youtu.be/trriSYNrHw4?t=896)
    
    Этот метод - это один из статических методов - объекта Promise.
    
    Его используют, когда нужно запустить несколько промисов параллельно и дождаться их выполнения.
    
    Promise.allSettled() - очень похож на promise.all(), но работает немного по другому.
    
    В отличии от promise.all() - promise.allSettled() ждет выполнения всех промисов, при этом не важно - завершились ли они успешно или с ошибкой.
    
    Следует помнить, что в случае с promise.all() - resolve возвращается только, если все параллельные промисы - завершились успешно, reject - если хоть один из промисов - упал.