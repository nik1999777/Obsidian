  

- [Что такое ECMAScript? В чём отличие от JavaScript?](https://youtu.be/IooJ3P2VUYs?t=336)
    
    Существует такой стандарт, который называется ECMA-262. Он разработан организацией ecma international.
    
    ECMAScript - это спецификация стандарта ECMA-262. Он содержит правила, сведения и рекомендации, которые должны соблюдаться скриптовым языком, чтобы он считался совместимым с ECMAScript.
    
    А JavaScript - это непосредственно одна из версий скриптового язык, которая соответсвует спецификацией ECMAScript. Другими словами - это просто одна из реализаций.
    
    Но а самая революционная версия стандарта - это версия ES6, где появились:
    
    - let и const
    - стрелочные функции
    - классы
    - promises
    - функции-генераторы
- [Разница между](https://youtu.be/1eIRTdgzHtw?t=361) [`let`](https://youtu.be/1eIRTdgzHtw?t=361)[,](https://youtu.be/1eIRTdgzHtw?t=361) [`const`](https://youtu.be/1eIRTdgzHtw?t=361) [и](https://youtu.be/1eIRTdgzHtw?t=361) [`var`](https://youtu.be/1eIRTdgzHtw?t=361)[?](https://youtu.be/1eIRTdgzHtw?t=361)
    - Переменные объявленные через var - всплывают, а это значит, что если мы обратимся к переменной еще до момента ее инициализации, то получим undefined.
        
        В случае же let и const - мы увидим ошибки.
        
    - у них - разные области видимости. У let и const - область видимости ограничена блоком, а не функцией.
        
        Другими словами, если они объявлены внутри скобок, то доступны только там и на всех вложенных уровнях.
        
        Переменная объявленная через var - такую область видимости игнорирует и может-быть доступна за ее пределами.
        
    - разница между let и const заключается в том, что переменные объявленная через const - становятся константой и по идее их невозможно переопределить. При попытке это сделать - мы получим ошибку. При этом мы можем менять значение свойства объекта объявленного через const, но не переопределить полностью объект.
- [Можно ли изменить значение определённое через](https://youtu.be/IooJ3P2VUYs?t=407) [`const`](https://youtu.be/IooJ3P2VUYs?t=407)[?](https://youtu.be/IooJ3P2VUYs?t=407)
    
    Да, можно.
    
    С появлением ES6 - определять различные значения стало возможным благодаря let и const.
    
    let - по сути унаследовала функциональность var. То есть переменная определенная через let в процессе выполнения скрипта может быть переопределена и это не вызовет ошибку.
    
    Что же касается const - то при попытке переопределить значение происходит ошибка. Но это не значит, что const нельзя изменить. В const присваивается значение и это значение действительно нельзя перезаписать. Однако если речь идет об объекте - то его свойства и методы могут быть изменены. А вот переназначения объекта константе - по прежнему вызывает ошибку. Это происходит потому что в саму const записывается не значение, а ссылка на объект.
    
- [Что такое временная мёртвая зона (temporal dead zone)?](https://youtu.be/IooJ3P2VUYs?t=478)
    
    Отличительной особенность между let, const и var - это то что var может всплывать. Тем самым при вызове его до объявления - будет undefined.
    
    А при вызове объявлений let и const - будет ошибка.
    
    Если немного углубиться, то механизм работы описывает так называемую - временную мертвую зону.
    
    Все дело в том, что let и const на самом деле всплывают точно также как и var. Но для того, чтобы легче отлавливать ошибки, которые в ES5 были вызваны - всплытием (hoisting).
    
    В ES6 для переменных создали временную мертвую зону. А это значит, что переменные будут созданы, когда интерпретатор зайдет в область видимости.
    
    То есть будут недоступны до тех пор, пока выполнение кода не дойдет до места их фактического объявления и только в этот момент произойдет выход из временной мертвой зоной и с переменными можно будет работать.
    
- [Разница между Rest и Spread операторами?](https://youtu.be/w-vUj0gHGgg?t=183)
    
    Несмотря на то, что синтаксис операторов одинаков - это три точки ...
    
    Задачи, которые они выполняют - противоположны.
    
    Spread оператор используется для разделения коллекция на отдельные элементы.
    
    - с помощью Spread очень удобно в массив или объект добавлять новые значения из других массивов или объектов, причем эти значения не обязательно перечислять полностью.
    - также он очень часто используется при копировании объектов или массивов
    
    Rest оператор - предназначен для соединения отдельных значений в массив.
    
    - Rest позволяет группировать в массив определенные данные (например собрать остаточные аргументы, передаваемые в функцию)
        
        ![[Untitled 96.png|Untitled 96.png]]
        
- [Что такое деструктуризация?](https://youtu.be/w-vUj0gHGgg?t=241)
    
    Деструкутризация (или деструкутрирующее присваивание) - это выражение доступное с версией стандарта ES6, которая предоставляет удобный способ извлекать значения из объектов или массивов и помещать их в отдельные переменные.
    
    Ее задачей является минимализировать код и сделать его более понятным.
    
    ![[Untitled 1 37.png|Untitled 1 37.png]]
    
- [Для чего используется цикл](https://youtu.be/G4iYlbilozM?t=223) [`for…of`](https://youtu.be/G4iYlbilozM?t=223)[?](https://youtu.be/G4iYlbilozM?t=223)
    
    В стандарте ES6 появился новый цикл for of.
    
    В ES5 был похожий цикл for in.
    
    Разница между ними в том, что for in оперирует с индексами перебираемых сущностей. А for of - работает именно со значениями.
    
    Плюс for of умеет работать с коллекциями по типу map и set.
    
- [Что такое шаблонные литералы (Template Literals)?](https://youtu.be/G4iYlbilozM?t=254)
    
    Шаблонные литералы - это новый способ создания строк в JS.
    
    Они создаются с помощью обратных кавычек и допускают использования строковой интерполяции.
    
    Это очень удобный синтаксис - допускающий использования выражения JS внутри строки.
    
- [Что такое](https://youtu.be/G4iYlbilozM?t=288) [`Set`](https://youtu.be/G4iYlbilozM?t=288)[,](https://youtu.be/G4iYlbilozM?t=288) [`Map`](https://youtu.be/G4iYlbilozM?t=288)[,](https://youtu.be/G4iYlbilozM?t=288) [`WeakMap`](https://youtu.be/G4iYlbilozM?t=288) [и](https://youtu.be/G4iYlbilozM?t=288) [`WeakSet`](https://youtu.be/G4iYlbilozM?t=288)[?](https://youtu.be/G4iYlbilozM?t=288)
    
    В ES6 появились новые типы коллекций.
    
    Это Set, Map, WeakMap и WeakSet.
    
    - Map - это коллекция для хранения записей вида ключ: значение. И в отличии от объектов, в которых ключами могут быть только строки - в Map ключом может быть произвольное значение (например число или булевое значение)
    - Set - это коллекция для хранения множества значений, причем каждое значение может встречаться лишь один раз
    - WeakMap и WeakSet - аналогичны, от оригинальных они отличаются тем, что не препятствуют сборщику мусора удалять свои элементы.
- [Разница между обычными функциями и стрелочными?](https://youtu.be/nvktMVFM0_M?t=347)
    
    - первое отличие относится к ключевому слову this.
    
    В обычных функция - это значение динамическое и зависит от контекста исполнения. В стрелочных функциях значение this - всегда эквивалентно значению this внешней функции.
    
    То есть стрелочная функция не создает собственный контекст исполнения, а использует внешний.
    
    - стрелочную функцию нельзя использовать как функцию конструктор - это вызовет ошибку
    - при использовании обычной функции есть доступ к псевдомассиву - arguments, у стрелочной такого псевдомассива - нет
    - для возврата значений из обычной функции - используется ключевое слово return, в стрелочных функциях - его можно не использовать
    - стрелочную функцию, также как и обычную можно использовать внутри класса - тогда функция называется методом. И если такой метод попытаться использовать как callback (например внутри таймера) - то обычная функция потеряет контекст, тогда как в стрелочной он всегда будет равен объекту класса.
- [Разница между методом](https://youtu.be/nvktMVFM0_M?t=429) [`Object.freeze()`](https://youtu.be/nvktMVFM0_M?t=429) [и](https://youtu.be/nvktMVFM0_M?t=429) [`const`](https://youtu.be/nvktMVFM0_M?t=429)[?](https://youtu.be/nvktMVFM0_M?t=429)
    
    На самом деле ключевое слово const и метод Object.freeze() - это совершенно разные вещи.
    
    const - создает иммутабельную привязку, то есть к переменной, объявленной с помощью const - нельзя привязать что-то новое.
    
    К const - нельзя присвоить новое значение, при попытке это сделать - будет выброшено исключение TypeError.
    
    А метод [`Object.freeze()`](https://youtu.be/nvktMVFM0_M?t=429) - работает с объектными значениями, который принимает в качестве аргумента - он делает объект иммутабельным, что защищает от изменения значения свойств этого объекта.
    
    При попытке это сделать в строгом режиме - будет выбрашено исключение referenceError, в обычном режиме - операция просто не сработает.
    
    ![[Untitled 2 27.png|Untitled 2 27.png]]
    
- [Что такое итераторы?](https://youtu.be/trriSYNrHw4?t=836)
    
    Итераторы применяются для организации последовательного доступа к элементам наборов данных, массивом, объектам Set и Map, строкам и т д.
    
    Благодаря итераторам - можно перебрать набор данных с помощью цикла for of.
    
    Дополнительно в стандарт ES6 - было добавлено еще одно понятие - это итерируемые объекты.
    
    Итерируемые объекты - это объекты, содержимое которых можно перебрать в цикле.
    
    Если сравнивать обычный объект и итерируемый - то последний обладает определенными отличиями, а в частности - у него есть специальный метод, который возвращает объект и у этого объекта есть специальный метод next().
    
    Сам метод также возвращает объект, у которого есть 2 свойства: done и value.
    
    Перебор будет идти до тех пор - пока возвращаемый методом объект - не вернет свойство done со значением true.
    
    ![[Untitled 3 16.png|Untitled 3 16.png]]
    
- [Что такое генераторы? Когда стоит использовать генераторы?](https://youtu.be/nvktMVFM0_M?t=476)
    
    Генераторы - это новый вид функций в JS.
    
    Их особенностью является то, что выполняясь они могут приостановить свое исполнение и возвращать промежуточное значение. А затем обратно продолжить выполняться.
    
    Для того чтобы обычную функцию превратить в генератор нужно добавить звездочку.
    
    Внутри функции используется ключевое слово yield. Такая функция при ее первом вызове не выполняет код, возвращает особый объект генератор, который позволяет управлять ее выполнением.
    
    Для получения очередного значения выдаваемого генератором - нужно вызвать его метод next().
    
- [Что такое ES6 модули?](https://youtu.be/V-m0sQ-hW58?t=494)
    
    Концепция модулей - как способ организации JS кода - существовала давно.
    
    Когда приложение сложное и кода много - самым лучшим путем его организации будет - разбиение на отдельные небольшие файлы, выполняющие какую-то функциональность - либо группирующие какие-либо данные по определенному признаку.
    
    В каждом файле описывается какая-то небольшая структурная часть, а в дальнейшем - это все собирается воедино.
    
    Модули - позволяют разделить базу кода на несколько файлов для большего удобства обслуживания.
    
    До появления ES6 модулей были 2 популярные модульные системы, которые использовались для поддержки кода JS:
    
    - CommonJS
    - AMD
    
    ![[Untitled 4 11.png|Untitled 4 11.png]]
    
- [Что такое символ (Symbol) в ES6?](https://youtu.be/V-m0sQ-hW58?t=571)
    
    Symbol - это отдельный тип данных, который появился в стандарте ECMAScript 2015.
    
    Если говорить в целом - то Symbol - это уникальные и неизменные значения, которые позволяют добавлять уникальное свойство объектов (идентификаторы), при этом не резервируя какие-нибудь строковые названия для этих свойств (идентификаторов).
    
    Создаются они с помощью специальной функции - Symbol() - без использования ключевого слова new.
    
    В обычной разработке Symbol - не используется, однако их можно использовать при написании какой-то библиотеки для создания уникального пространства имен, которое 100% будет гарантировать уникальность и не приведет к конфликту имен - при интеграции этой библиотеки в приложение.
    
    ![[Untitled 5 8.png|Untitled 5 8.png]]
    
- [Для чего используется метод](https://youtu.be/VYQl2GhbCUs?t=666) [`.includes()`](https://youtu.be/VYQl2GhbCUs?t=666)[?](https://youtu.be/VYQl2GhbCUs?t=666)
    
    Этот метод определен у массивов и строк:
    
    - Для массивов он проверяет - есть ли искомый элемент в массиве?
    - Для строк проверяется - есть ли исходная подстрока в строке.
    
    Возвращает true - если исходный элемент нашелся и false - если нет.
    
    Метод принимает 2 аргумента:
    
    - первый - это значение, которое нужно проверить
    - второй - является необязательным и определяет позицию в массиве, с которой требуется начинать поиск элемента, по-умолчанию это значение равно 0.
    
    ![[Untitled 6 7.png|Untitled 6 7.png]]