  

- [Что такое CSS? И для чего он используется?](https://youtu.be/ycYp7CYOnO0?t=251)
    
    CSS - Cascading Style Sheets «каскадные таблицы стилей».
    
    Предназначен CSS для добавления различных стилей на HTML страницу.
    
    И если чистый HTML представляет из себя просто основной каркас веб страницы. То задача добавления различных визуальных эффектов лежит именно на CSS.
    
- [Что такое CSS-правило?](https://youtu.be/CjdCxxqObaM?t=228)
    
    Другими словами нас попросят описать базовый CSS синтаксис.
    
    Состоит он из двух частей:
    
    - selector
    - блок объявления - это структура содержащая фигурные скобки, внутри которых описывается свойство и его значение
- [Варианты добавление CSS стилей на страницу?](https://youtu.be/ycYp7CYOnO0?t=277)
    
    Существует 4 основных способа:
    
    - использование inline styles (когда css свойство с помощью атрибута style добавляется на конкретный элемент)
    - использование глобальных стилей (когда именно в тэг <head> добавляется тэг <style>, внутри которого описаны стили)
    - использование внешнего файла (когда все стили добавляются в отдельный файл с расширением css и сам файл подключается с помощью тэга <link> в HTML документ)
    - импорт непосредственно файлов стилей
- [Типы позиционирования в CSS?](https://youtu.be/ycYp7CYOnO0?t=321)
    
    Существует 5 типов позиционирования:
    
    - static - это тип позиционирования, который присваивается всем элементам по умолчанию
    - relative (относительное позиционирование) - это тип позиционирования при котором элемент можно перемещать относительно его начального положения в документе, сам элемент находится в основном потоке
    - absolute (абсолютное позиционирование) - это тип позиционирования при котором элемент можно перемещать и он формирует новый поток. Задание позиции элемента происходит относительно первого родителя, у которого позиционирование отлично от static. И если же такого родителя нет, то относительно окна браузера
    - fixed (фиксированное позиционирование) - также формирует новый поток, позиция элемента отсчитывается только относительно окна браузера, игнорируя любое позиционирование родителя
    - sticky - комбинирует в своей логике 2 типа позиционирования:
        
        - в видимой области экрана элемент ведет себя, как fixed
        - при дальнейшей прокрутке, скролится вместе с родителем - что напоминает поведение relative или absolute
        
        Само позиционирование происходит относительно родительского блока.
        
- [Блочная модель CSS?](https://youtu.be/ycYp7CYOnO0?t=410)
    
    Блочная модель позволяет рассчитать какое итоговое пространство будет занимать элемент на странице.
    
    В нее входит:
    
    - сам контент
    - padding (внутренний отступ)
    - border (граница элемента)
    - margin (внешний отступ)
    
    ![[Untitled 92.png|Untitled 92.png]]
    
- [Что такое селектор? И какие селекторы существуют?](https://youtu.be/G7hLwudGWL4?t=282)
    
    Селектор - это часть CSS правила, которая сообщает браузеру какому элементу будет применен стиль.
    
    Селекторы делятся на 2 большие группы:
    
    - простые - это тип, в котором указывается один вариант селектора
        - .class {}
        - \#id {}
        - p {} - тэг
        - * {} - универсальный селектор
        - a[href=”test”] - селектор атрибута
    - составные - это селекторы представляющие из себя определенные комбинации из простых
        - h1, h2, span {} - групповые селекторы
        - div p {} - селектор потомка
        - li > a {} - селектор только дочернего элемента
        - a:hover {} - селектор псевдокласса
        - li:nth-last-child(2n) {} - селектор псевдоэлемента
- [Что такое специфичность селектора? Как считать вес селектора?](https://youtu.be/G7hLwudGWL4?t=358)
    
    Специфичность - это способ с помощью которого браузеры определяют какие значения CSS свойств будут применены к элементу.
    
    Дело в том, что на одном элементе может быть определено сразу несколько стилей. А вот какие именно стили будут отображены в браузере зависит от специфичности, которая базируется на определении веса селектора.
    
    Существует 4 основных веса селектора:
    
    - inline selector - 1000
    - id - 100
    - class/attribute/pseudo-class - 10
    - element/pseudo-element - 1
- [Разница между Reset.css и Normalize.css?](https://youtu.be/G7hLwudGWL4?t=445)
    
    Практически все HTML элементы обладают дефолтными стилями.
    
    Нюанс в том, что каждый браузер применяет различные стили и для того, чтобы верстка в каждом было одинакова - используют Reset.css и Normalize.css.
    
    Это CSS файлы, которые подключаются в начале документа.
    
    Reset.css - сбрасывает все дефолтные стили в ноль.
    
    Normalize.css - стабилизирует для различных браузеров.
    
    Наиболее актуальный вариант сейчас - это Normalize.css
    
- [Разница между](https://youtu.be/1eIRTdgzHtw?t=116) [`margin`](https://youtu.be/1eIRTdgzHtw?t=116) [и](https://youtu.be/1eIRTdgzHtw?t=116) [`padding`](https://youtu.be/1eIRTdgzHtw?t=116)[?](https://youtu.be/1eIRTdgzHtw?t=116)
    
    margin - это внешний отступ (то есть пространство от границы блока до другого элемента)
    
    padding - это внутренний отступ (пространство от границы блока до контента)
    
- [Разница между](https://youtu.be/1eIRTdgzHtw?t=139) [`display: none`](https://youtu.be/1eIRTdgzHtw?t=139) [и](https://youtu.be/1eIRTdgzHtw?t=139) [`visibility: hidden`](https://youtu.be/1eIRTdgzHtw?t=139)[?](https://youtu.be/1eIRTdgzHtw?t=139)
    
    Оба свойства предназначены для того, чтобы скрывать элемент на странице.
    
    Но механизмы, которые они используют отличаются.
    
    - display: none - полностью убирает элемент с HTML страницы, элемент удаляется из основного потока документа. Единственное место, где он остается доступен - это DOM дерево. Также контент, который находится внутри него - становится недоступен для поисковых роботов.
    - visibility: hidden - из основного потока он не вырывается и остается доступен для поисковых роботов.
- [Разница между блочным и строчным (инлайновым) элементами?](https://youtu.be/1eIRTdgzHtw?t=188)
    
    Основная разница заключается в том, что блочный элемент по умолчанию всегда занимает всю доступную ширину экрана, а строчный элемент подстраивается под размер контента.
    
    Поэтому блочные всегда идут друг под другом, а строчных в одном ряду может быть несколько.
    
    Блочным элементам можно задавать размеры. Для строчных - это не работает.
    
    Блочные элементы воспринимают внешние и внутренние отступы, то есть margin и padding. Для строчных элементов margin сверху и снизу - не работает.
    
- [Разница между классом и идентификатором в CSS?](https://youtu.be/CjdCxxqObaM?t=264)
    
    Идентфикатор:
    
    - id используется 1 раз
    - id у элемента только один
    - у id большой вес для CSS (100)
    
    Class:
    
    - можно задавать много раз
    - у одного элемента может быть несколько классов, возможно комбинации
    
    Для добавления стилей - лучше использовать class, а для добавления логики через JS оптимальнее применять id.
    
- [Что такое CSS спрайт? И для чего он используется?](https://youtu.be/CjdCxxqObaM?t=330)
    
    CSS-спрайт – способ объединить много изображений в одно, чтобы:
    
    1. Сократить количество обращений к серверу.
    2. Загрузить несколько изображений сразу, включая те, которые понадобятся в будущем.
    3. Если у изображений сходная палитра, то объединённое изображение будет меньше по размеру, чем совокупность исходных картинок.
- [Что такое вендорные префиксы? И для чего они используются?](https://youtu.be/rlWgI7AvV18?t=234)
    
    Вендорный префикс - это приставка к CSS свойству, которое обеспечивает поддержку данного свойства в браузерах, в которых оно не внедрено на постоянной основе. (То есть свойство введено в спецификацию CSS, но в конкретном браузере оно находится либо в стадии разработки, либо в стадии тестировании)
    
    Причин для их появления несколько:
    
    - это включение в браузер экспериментальных свойств CSS, которые стандартом еще не утверждены
    - а также решение проблем с кроссбраузерностью
    
    Существует сервис Can I use.
    
      
    
- [Что такое псевдоэлементы? И для чего они используются?](https://youtu.be/rlWgI7AvV18?t=355)
    
    Псевдоэлемент - это ключевое слово, которое добавляется на селектор и позволяет стилизирвоать определенную часть выбранного элемента.
    
    В CSS существует 5 типов псевдоэлементов:
    
    - Используется для изменения первой буквы в тексте
    
    ```CSS
    h3::first-letter {color: red;}
    ```
    
    - Используется для изменения первой строки блочного текста
    
    ```CSS
    h3::first-line {font-size: 40px;}
    ```
    
    - Применяется для вставки нужного контента после выбранного элемента
    
    ```CSS
    h2::after {content: ' channel';}
    ```
    
    - Применяется для вставки контента до выбранного элемента
    
    ```CSS
    h2::before {content: 'It`s a ';}
    ```
    
    - Позволяет применить стили к части документа, которая была выделена пользователем
    
    ```CSS
    h3::selection {background: cyan;}
    ```
    
    ![[Untitled 1 33.png|Untitled 1 33.png]]
    
- [Что такое схлопывание границ (margin collapsing)?](https://youtu.be/kx3dR6ztICU?t=30)
    
    Отступы margin-top и margin-bottom иногда объединяются в один, с размером равным наибольшему из них (или размеру одного, если они равны).
    
    Это поведение известно как **схлопывание внешних отступов (margin collapsing).**
    
- [Что такое CSS препроцессор?](https://youtu.be/kx3dR6ztICU?t=159)
    
    CSS препроцессор - это программа, которая позволяет генерировать CSS и собственного уникального синтаксиса. (То есть на выходе мы всегда будем получать сгенерированный CSS код, который отправляется в браузер.
    
    Их используют потому что их синтаксис проще читать, использовать и расширять.
    
    Самые известные:
    
    - Sass
    - Less
    - Stylus
    - PostCSS
- [Что такое](https://youtu.be/GZUy2i6QN7o?t=102) [`z-index`](https://youtu.be/GZUy2i6QN7o?t=102)[? Как формируется контекст наложения?](https://youtu.be/GZUy2i6QN7o?t=102)
    
    Любой элемент в HTML документе может быть - либо на переднем, либо на заднем плане.
    
    - Если свойство z-index и позиционирование не заданы явно - то порядок наложения равен порядку следования элементов в HTML.
    - Если позиционирование элементов и их детей задано явно - то такие элементы будут прикрывать собой элементы - без явно заданного свойства позиционирования.
    - Если задать z-index то:
        - во-первых - z-index учитывается только на явно позиционированных элементах. Если попытаться установить z-index на не позиционируемый элемент - то ничего не произойдет.
        - во-вторых - значения z-index могут создавать контекст наложения.
            
            Контекст наложения имеет свой корневой элемент в HTML структуре.
            
            В момент формирования нового контекста на элементе - все дочерние элементы также попадают в этот контекст и занимают свое место в порядке наложения.
            
            Если элемент располагается в самом низу одного контекста наложения - то никаким образом не получится отобразить его над другим элементом в соседнем контексте наложения - располагающимся выше по иерархии (даже с установленным z-index равным 1000).
            
            Новый контекст наложения может-быть сформирован в следующих случаях:
            
            - элемент - это корневой элемент документа
            - если элемент спозиционирован - не статически и его значение z-index не равно auto
            - и если элемент имеет прозрачность не менее 1
    
      
    
- [Порядок наложения элементов в CSS (Stacking Order)?](https://youtu.be/GZUy2i6QN7o?t=204)
    
    Элементы в HTML имеют не плоскую, а объемную структуру - поэтому они способны перекрывать друг друга.
    
    Такое поведение регулируется с помощью свойства z-index.
    
    Однако и при его отсутсвие - существует свой порядок наложения и идет он следующим образом - начиная с самого низкого и заканчивая самым верхним:
    
    - background и border элемента
    - спозиционированные элементы и их дети (z-index < 0)
    - элементы блочного уровня в нормальном потоке - то есть те у которых position равен static
    - float (плавающие) элементы
    - inline элементы
    - элементы с z-index < 0 (или это значит z-index = auto)
    - и последними идут элементы со свойством opacity < 1
    
      
    
- [Как с помощью CSS определить, поддерживается ли свойство в браузере?](https://youtu.be/70VnuTXi4Wk?t=32)
    
    C помощью специальной директивы @supports:
    
    ![[Untitled 2 23.png|Untitled 2 23.png]]
    
      
    
- [Как поддерживать страницы в браузерах с ограниченными функциями?](https://youtu.be/70VnuTXi4Wk?t=75)
    
    То есть если современное css свойство не поддерживается в каком-то из старых браузерах - как можно написать аналог?
    
    ![[Untitled 3 13.png|Untitled 3 13.png]]
    
- [Как исправлять специфичные проблемы со стилями для разных браузеров?](https://youtu.be/70VnuTXi4Wk?t=122)
    
    Поскольку существуют разные браузеры - для некоторых свойств в них закладываются разные значения.
    
    В результат одна и та же страница может выглядеть по-разному, поэтому применяются различные подходы, чтобы унифицировать начальные стили:
    
    ![[Untitled 4 9.png|Untitled 4 9.png]]
    
- [Глобальные ключевые слова в CSS?](https://youtu.be/VYQl2GhbCUs?t=224)
    
    Для всех свойств в CSS, помимо стандартных значений - можно задать значение в виде ключевых слов.
    
    В CSS есть 4 глобальных ключевых слова:
    
    - initial
    
    У каждого из свойств CSS есть значение по-умолчанию.
    
    Оно применяется еще до того - как что-либо написано в файле стилей.
    
    initial - сбрасывает все указанные значения свойства для конкретного блока до этих самых значений по-умолчанию.
    
    - inherit
    
    CSS свойства делятся на наследуемые и не наследуемые.
    
    Значения наследуемых свойств применяются не только к элементу для которого прописаны, но и для всех вложенных дочерних элементов.
    
    Это очень удобно, чтобы не писать много одинаковых свойств для разных селекторов, перечисляя всех потомков.
    
    - unset
    
    Это ключевое слово ведет себя по-разному с наследуемыми и не наследуемыми свойствами.
    
    С наследуемыми свойствами - ключевое слово unset ведет себя как inherit.
    
    С не наследуемыми - как initial.
    
    - revert
    
    Данное ключевое слово сбрасывает значения свойства до указанного в стилях браузера.
    
- [Что такое CSS-атрибут (](https://youtu.be/VYQl2GhbCUs?t=301)[`attr`](https://youtu.be/VYQl2GhbCUs?t=301)[)?](https://youtu.be/VYQl2GhbCUs?t=301)
    
    Функция attr - это CSS функция, которая умеет получать значение любого атрибута элемента, а потом использовать это значение прямо в таблице стилей.
    
    ![[Untitled 5 6.png|Untitled 5 6.png]]
    
- [Что такое перечисление селекторов?](https://youtu.be/VYQl2GhbCUs?t=336)
    
    При помощи перечисления нескольких селекторов через запятую - можно избежать дублирования кода, если у нескольких элементов есть определенные повторяющиеся стили.
    
      
    
    ![[Untitled 6 5.png|Untitled 6 5.png]]
    
- [Для чего используется ключевое слово](https://youtu.be/trriSYNrHw4?t=549) [`currentColor`](https://youtu.be/trriSYNrHw4?t=549) [в CSS?](https://youtu.be/trriSYNrHw4?t=549)
    
    Ключевое свойство currentColor - можно использовать в качестве значения для CSS свойства, принимающего цвет.
    
    То есть оно будет работать для свойств color, background-color, box-shadow и т д.
    
    ![[Untitled 7 5.png|Untitled 7 5.png]]
    
- [Какие псевдоклассы были добавлены в CSS3?](https://youtu.be/trriSYNrHw4?t=592)
    - :nth-child(n) - выбирает n-ый дочерний элемент внутри родительского элемента. Метка этого дочернего элемента n - может принимать определенное значения или функции.
    - :nth-last-child(n) - выполняет ту же функцию, что и первый - но выполняет выборку элементов с конца.
    - :last-child(n) - выбирает последний дочерний элемент
    - :only-child - выбирает элемент, если он является единственным дочерним элементом - родительского элемента.
    - :nth-of-type(n) - выбирает элемент n-го типа внутри родительского элемента, n в свою очередь может принимать определенные значения или функции.
    - :first-of-type - выбирает первый элемент заданного типа внутри родительского элемента.
    - :last-of-type - выбирает последний элемент заданного типа внутри родительского элемента.
- [Какие фильтры есть в CSS?](https://youtu.be/trriSYNrHw4?t=662)
    
    Cуществует CSS свойство - filter.
    
    Ему в виде значений присваиваются специальные функции.
    
    ![[Untitled 8 5.png|Untitled 8 5.png]]