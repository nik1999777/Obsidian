- Подходы к программированию:
    
    1. **Императивное программирование**: подход, основанный на прямом управлении состоянием программы с помощью операторов и выражений, что позволяет описывать шаги для решения задачи последовательно.
    2. **Декларативное программирование**: подход, при котором разработчики описывают желаемый результат, а не алгоритмы для его достижения. Примерами декларативных языков являются SQL (для работы с базами данных) и HTML (для разметки веб-страниц).
    3. **Объектно-ориентированное программирование (ООП)**: подход, основанный на концепции "объектов", которые объединяют связанные данные и функции. ООП позволяет разработчикам создавать масштабируемые и модульные программы с использованием принципов наследования, инкапсуляции и полиморфизма.
    4. **Функциональное программирование**: подход, основанный на использовании математических функций и их композиций, что облегчает работу с параллельными вычислениями и предотвращает ошибки, связанные с изменяемым состоянием. Примерами функциональных языков являются Haskell, Lisp и Scala.
    5. **Логическое программирование**: подход, основанный на формализации знаний и выводах, используя предикатную логику. Примером логического языка программирования является Prolog.
    6. **Аспектно-ориентированное программирование (АОП)**: подход, который позволяет разработчикам отделить кросс-функциональные или повторяющиеся задачи от основного функционала программы и повторно использовать их в разных местах кода.
    7. **Реактивное программирование**: подход, основанный на асинхронном обработке событий и потоков данных, что облегчает создание интерактивных и отзывчивых приложений.
    8. **Конкурентное программирование**: подход, включающий параллельное и независимое выполнение задач для оптимизации производительности и ресурсов.
    
    ---
    
    1. Императивное программирование:
        - C
        - C++
        - Java
        - Python
        - Ruby
        - JavaScript
    2. Декларативное программирование:
        - SQL (структурированный язык запросов)
        - HTML (язык гипертекстовой разметки)
        - CSS (каскадные таблицы стилей)
        - XSLT (язык преобразования XML)
    3. Объектно-ориентированное программирование (ООП):
        - Java
        - C#
        - C++
        - Python
        - Ruby
        - Swift
        - Kotlin
        - PHP
        - JavaScript
    4. Функциональное программирование:
        - Haskell
        - Lisp
        - Clojure
        - Scala
        - Erlang
        - F#
        - Elixir
        - Elm
    5. Логическое программирование:
        - Prolog
        - Mercury
    6. Аспектно-ориентированное программирование (АОП):
        - AspectJ (расширение Java)
    7. Реактивное программирование:
        - JavaScript с библиотеками, такими как RxJS
        - Java с использованием Project Reactor
        - Scala с использованием Akka
        - Swift и Combine
    8. Конкурентное программирование:
        
        - Go
        - Rust
        - Java (с использованием многопоточности)
        - C++ (с использованием многопоточности)
        
        Обратите внимание, что некоторые языки программирования могут поддерживать несколько подходов. Например, Python и JavaScript являются мультипарадигмальными языками, которые поддерживают императивное, объектно-ориентированное и функциональное программирование.
        

  

Принципы объектно-ориентированное программирование:

- **Инкапсуляция**
    
    Это механизм в ООП, который позволяет скрыть данные и методы работы с ними внутри класса и ограничить их доступность для других частей программы.
    
    ```TypeScript
    class Rectangle {
      private _width;
      private readonly _height;
      constructor(w: number, h: number) {
        this._width = w;
        this._height = h;
      }
      public get width() {
        return this._width;
      }
      set width(value) {
        if (value <= 0) {
          this._width = 1;
        } else {
          this._width = value;
        }
      }
      calcArea() {
        return this._width * this._height;
      }
      calcPerimeter() {
        return (this._width * this._height) / 2;
      }
    }
    
    const rect = new Rectangle(5, 10);
    rect.width = -2;
    console.log(rect);
    ```
    
    ```JavaScript
    Rectangle { _width: 1, _height: 10 }
    ```
    
    ```TypeScript
    const generateRandomId = () => {
      return Math.random() * 10;
    };
    
    class User {
      private _username;
      private _password;
      private readonly _id;
    
      constructor(username: string, password: string) {
        this._username = username;
        this._password = password;
        this._id = generateRandomId();
      }
    
      get username() {
        return this._password;
      }
      get password() {
        return this._password;
      }
      get id() {
        return this._id;
      }
    
      set username(value) {
        this._username = value;
      }
      set password(value) {
        this._password = value;
      }
    }
    
    const user = new User("Nikita", "Elin");
    user.username = "Vasya";
    console.log(user);
    ```
    
    ```JavaScript
    User { _username: 'Vasya', _password: 'Elin', _id: 9.652652536330333 }
    ```
    
    ```TypeScript
    class Database {
      private readonly _url;
      private readonly _port;
      private readonly _username;
      private readonly _password;
      private _tables;
    
      constructor(url, port, username, password) {
        this._url = url;
        this._port = port;
        this._username = username;
        this._password = password;
        this._tables = [];
      }
    
      public createNewTable(table) {
        this._tables.push(table);
      }
      public clearTables() {
        this._tables = [];
      }
    
      get url() {
        return this._url;
      }
      get port() {
        return this._port;
      }
      get username() {
        return this._username;
      }
      get password() {
        return this._password;
      }
      get tables() {
        return this._tables;
      }
    }
    
    const db = new Database(1, 2, 3, 4);
    db.createNewTable({ name: "roles" });
    db.createNewTable({ name: "users" });
    db.clearTables();
    ```
    
- **Наследование**
    
    Это создание нового класса на основе уже существующего, при этом дочерний класс получает свойства и методы родительского класса и может добавлять свои. Это помогает уменьшить дублирование кода и повторное использование.
    
    ```TypeScript
    class Person {
      private _firstName;
      private _lastName;
      private _age;
    
      constructor(firstName: string, lastName: string, age: number) {
        this._firstName = firstName;
        this._lastName = lastName;
        this._age = age;
      }
    
      public get fullName() {
        return `Фамилия - ${this._lastName}, имя - ${this._firstName}`;
      }
      get firstName() {
        return this._firstName;
      }
      set firstName(value) {
        this._firstName = value;
      }
      get lastName() {
        return this._lastName;
      }
      set lastName(value) {
        this._lastName = value;
      }
      get age() {
        return this._age;
      }
      set age(value) {
        if (value < 0) {
          this._age = 1;
        } else {
          this._age = value;
        }
      }
    }
    
    class Employee extends Person {
      private inn;
      private number;
      private snils;
    
      constructor(
        firstName: string,
        lastName: string,
        age: number,
        inn: number,
        number: number,
        snils: number
      ) {
        super(firstName, lastName, age);
        this.inn = inn;
        this.number = number;
        this.snils = snils;
      }
    }
    
    const employee = new Employee("Nikita", "Elin", 18, 1, 2, 3);
    console.log(employee);
    
    class Developer extends Employee {
      private level;
      constructor(
        firstName: string,
        lastName: string,
        age: number,
        inn: number,
        number: number,
        snils: number,
        level: number
      ) {
        super(firstName, lastName, age, inn, number, snils);
        this.level = level;
      }
    }
    
    const developer = new Developer("Nikita", "Elin", 18, 2, 3, 4, 5);
    console.log(developer);
    console.log(developer.fullName);
    ```
    
    ```JavaScript
    Employee {
      _firstName: 'Nikita',
      _lastName: 'Elin',
      _age: 18,
      inn: 1,
      number: 2,
      snils: 3
    }
    Developer {
      _firstName: 'Nikita',
      _lastName: 'Elin',
      _age: 18,
      inn: 2,
      number: 3,
      snils: 4,
      level: 5
    }
    Фамилия - Elin, имя - Nikita
    ```
    
- **Полиморфизм**
    
    Это принцип, который позволяет объектам разных классов иметь одинаковый интерфейс (набор методов), но с разной реализацией. Это означает, что объекты могут быть использованы в коде вместо друг друга, если они реализуют общий интерфейс. Полиморфизм упрощает написание гибкого и расширяемого кода и повышает его читаемость и понятность.
    
    ---
    
    Отличие между параметрическим и ad-hoc (мнимым) полиморфизмом заключается в том, что параметрический полиморфизм возможен благодаря обобщениям (generics), а ad-hoc полиморфизм - благодаря перегрузке функций или операторов. В параметрическом полиморфизме, функция или класс работают с разными типами данных, но выполняют одни и те же действия. В ad-hoc полиморфизме, функция или оператор могут иметь различное поведение в зависимости от типа данных, с которыми он используется.
    
    Выделяют 2 основных типа:
    
    - Параметрический (истинный)
    
    ```TypeScript
    class Person {
      protected _firstName;
      private _lastName;
      private _age;
    
      constructor(firstName: string, lastName: string, age: number) {
        this._firstName = firstName;
        this._lastName = lastName;
        this._age = age;
      }
    
      greeting() {
        console.log(`Привет я человек и меня зовут ${this._firstName}`);
      }
      get fullName() {
        return `Фамилия - ${this._lastName}, имя - ${this._firstName}`;
      }
      get firstName() {
        return this._firstName;
      }
      set firstName(value) {
        this._firstName = value;
      }
      get lastName() {
        return this._lastName;
      }
      set lastName(value) {
        this._lastName = value;
      }
      get age() {
        return this._age;
      }
      set age(value) {
        if (value < 0) {
          this._age = 1;
        } else {
          this._age = value;
        }
      }
    }
    
    class Employee extends Person {
      private inn;
      private number;
      private snils;
    
      constructor(
        firstName: string,
        lastName: string,
        age: number,
        inn: number,
        number: number,
        snils: number
      ) {
        super(firstName, lastName, age);
        this.inn = inn;
        this.number = number;
        this.snils = snils;
      }
    
      greeting() {
        console.log(`Привет я работник и меня зовут ${this._firstName}`);
      }
    }
    
    class Developer extends Employee {
      private level;
      constructor(
        firstName: string,
        lastName: string,
        age: number,
        inn: number,
        number: number,
        snils: number,
        level: number
      ) {
        super(firstName, lastName, age, inn, number, snils);
        this.level = level;
      }
    
      greeting() {
        console.log(`Привет я разработчик и меня зовут ${this._firstName}`);
      }
    }
    
    const person = new Person("Person", "Elin", 18);
    const employee = new Employee("Employee", "Elin", 18, 2, 3, 4);
    const developer = new Developer("Developer", "Elin", 18, 2, 3, 4, 5);
    
    person.greeting();
    employee.greeting();
    developer.greeting();
    ```
    
    Таким образом, мы можем использовать объекты классов **`Person`**и `**Employee**`, **`Developer`** коде взаимозаменяемо, так как оба класса имеют метод `**greeting()**`, но его реализация различна. Это и есть пример полиморфизма в JavaScript.
    
    - ad-hoc (мнимый)
    
    ![[Untitled 9.png|Untitled 9.png]]
    
      
    
- **Агрегация** **и** **Композиция**
    
    Помимо **наследования** существует и другие способы взаимодействия между классами: **Агрегация** и **Композиция**.  
      
    **Агрегация** и **Композиция** — это два различных способа организации связей между классами в объектно-ориентированном программировании. Оба способа позволяют одному классу использовать функциональность другого класса, но есть некоторые отличия в том, как они это делают.
    
    ---
    
    **Агрегация** — это отношение, когда один класс имеет ссылку на другой класс, но оба класса могут существовать независимо друг от друга. Например, класс **`Car`** может иметь ссылку на класс **`Engine`**, но двигатель может существовать независимо от автомобиля.
    
    ```JavaScript
    class Engine {
      constructor(horsepower) {
        this.horsepower = horsepower;
      }
    }
    
    class Car {
      constructor(make, model, engine) {
        this.make = make;
        this.model = model;
        this.engine = engine;
      }
    }
    
    const engine = new Engine(200);
    const car = new Car("Toyota", "Corolla", engine);
    console.log(engine);
    console.log(car);
    ```
    
    ```JavaScript
    Engine { horsepower: 200 }
    Car {
      make: 'Toyota',
      model: 'Corolla',
      engine: Engine { horsepower: 200 }
    }
    ```
    
    **Композиция** — это более сильная связь между классами, когда один класс включает в себя другой класс и не может существовать без него. Например, класс **`Computer`** может включать в себя классы **`Processor`**, `**Memory**` и `**HardDrive**`. Если один из этих классов отсутствует, компьютер не может работать.
    
    ```JavaScript
    class Processor {
      constructor(speed) {
        this.speed = speed;
      }
    }
    
    class Memory {
      constructor(size) {
        this.size = size;
      }
    }
    
    class HardDrive {
      constructor(capacity) {
        this.capacity = capacity;
      }
    }
    
    class Computer {
      constructor(processor_speed, memory_size, hard_drive_capacity) {
        this.processor = new Processor(processor_speed);
        this.memory = new Memory(memory_size);
        this.hard_drive = new HardDrive(hard_drive_capacity);
      }
    }
    
    const computer = new Computer(2.4, 8, 500);
    console.log(computer);
    ```
    
    ```JavaScript
    Computer {
      processor: Processor { speed: 2.4 },
      memory: Memory { size: 8 },
      hard_drive: HardDrive { capacity: 500 }
    }
    ```
    
- **Абстрактные классы и интерфейсы**
    
    **Абстрактный класс** и **интерфейс** - это два важных концепта объектно-ориентированного программирования, которые используются для определения общих свойств и методов для группы объектов.
    
    **Абстрактный класс** - это класс, который не может быть создан в экземпляре и содержит хотя бы один абстрактный метод. Абстрактный метод - это метод, который объявлен в классе, но не имеет тела. Абстрактный класс может содержать обычные методы, поля, конструкторы и другие члены класса. Абстрактные классы используются для создания общих функций, которые должны быть реализованы в наследниках.
    
    ```TypeScript
    abstract class Animal {
      constructor(public name: string) {}
    
      abstract makeSound(): void;
    }
    
    class Cat extends Animal {
      makeSound() {
        console.log(`${this.name} says meow`);
      }
    }
    
    const cat = new Cat('Fluffy');
    cat.makeSound(); // Output: Fluffy says meow
    ```
    
    **Интерфейс** - это набор абстрактных методов, которые не имеют тела и не содержат реализацию. Они определяют, что должен делать класс, но не как он должен это делать. Класс, который реализует интерфейс, должен реализовать все методы интерфейса. Интерфейсы могут использоваться для определения конкретного поведения, которое должно быть реализовано классами-потомками.
    
    ```TypeScript
    class User {
      username: "string";
      age: "number";
    }
    class Car {}
    
    interface Repository<T> {
      create: (object: T) => T;
      get: (object: T) => T;
      delete: (object: T) => T;
      update: (object: T) => T;
    }
    
    class UserRepo implements Repository<User> {
      create(obj: User): User {
        return undefined;
      }
      delete(obj: User): User {
        return undefined;
      }
      get(): User {
        return undefined;
      }
      update(obj: User): User {
        return undefined;
      }
    }
    
    class CarRepo implements Repository<Car> {
      create(obj: User): User {
        return undefined;
      }
      delete(obj: User): User {
        return undefined;
      }
      get(): User {
        return undefined;
      }
      update(obj: User): User {
        return undefined;
      }
    }
    ```
    
    Основным отличием между абстрактным классом и интерфейсом является то, что абстрактный класс может содержать как абстрактные, так и обычные методы, а интерфейс может содержать только абстрактные методы. Кроме того, класс может наследовать только один абстрактный класс, но может реализовывать несколько интерфейсов.
    

  

Пример **паттернов проектирования**:

- **Dependency Injection (DI)**
    
    Он является одним из ключевых паттернов проектирования, который помогает управлять зависимостями между объектами в программе. Этот паттерн призван упростить разработку, облегчить тестирование и повысить гибкость программного обеспечения. В основе DI лежит концепция инверсии управления (IoC), которая предполагает, что объекты не создают свои зависимости, а получают их из внешних источников.
    
    Преимущества DI:
    
    1. Повышение модульности кода, что облегчает разработку и поддержку.
    2. Упрощение тестирования, так как можно заменять реальные зависимости на поддельные (mocks).
    3. Увеличение гибкости и расширяемости, так как объекты могут получать разные реализации своих зависимостей.
    
    Вот пример использования Dependency Injection на TypeScript:
    
    ```TypeScript
    // Интерфейс для сервиса отправки сообщений
    interface IMessageService {
      sendMessage(message: string, recipient: string): void;
    }
    
    // Реализация сервиса отправки сообщений через Email
    class EmailService implements IMessageService {
      sendMessage(message: string, recipient: string): void {
        console.log(`Email sent to ${recipient}: ${message}`);
      }
    }
    
    // Реализация сервиса отправки сообщений через SMS
    class SMSService implements IMessageService {
      sendMessage(message: string, recipient: string): void {
        console.log(`SMS sent to ${recipient}: ${message}`);
      }
    }
    
    // Класс пользователя, который использует сервис отправки сообщений
    class User {
      private messageService: IMessageService;
    
      constructor(messageService: IMessageService) {
        this.messageService = messageService;
      }
    
      notify(message: string): void {
        this.messageService.sendMessage(message, "recipient@example.com");
      }
    }
    
    // Создание объектов с зависимостями
    const emailService: IMessageService = new EmailService();
    const smsService: IMessageService = new SMSService();
    
    // Создание пользователей с различными способами отправки сообщений
    const user1: User = new User(emailService);
    const user2: User = new User(smsService);
    
    // Отправка сообщений пользователями
    user1.notify("Hello, Email!");
    user2.notify("Hello, SMS!");
    ```
    
    ```TypeScript
    Email sent to recipient@example.com: Hello, Email!
    SMS sent to recipient@example.com: Hello, SMS!
    ```
    
    В данном примере класс `**User**`зависит от интерфейса `**IMessageService**`. Используя DI, мы передаем конкретную реализацию сервиса отправки сообщений (например, `**EmailService**`или `**SMSService**`) через конструктор класса `**User**`. Таким образом, мы инвертируем управление и делаем код более гибким и модульным.
    
    В паттерне проектирования Dependency Injection (DI) используются несколько ключевых принципов объектно-ориентированного программирования (ООП). Они включают:
    
    1. **Инкапсуляция**: Инкапсуляция обеспечивает сокрытие деталей реализации и предоставление четкого интерфейса для взаимодействия с объектами. В примере с DI, класс `**User**` использует сервис `**IMessageService**` через его интерфейс, не зная о деталях реализации. Таким образом, мы достигаем инкапсуляции.
    2. **Абстрагирование**: Абстрагирование - это процесс выделения общих свойств и методов для создания общего интерфейса. В контексте DI, интерфейс `**IMessageService**` представляет общий контракт, который должны реализовать различные сервисы отправки сообщений. Это позволяет использовать разные реализации интерфейса в зависимости от конкретной ситуации.
    3. **Полиморфизм**: Полиморфизм позволяет использовать один интерфейс для представления различных типов объектов. В DI, объекты разных классов (например, `**EmailService**` и `**SMSService**`) реализуют один и тот же интерфейс `**IMessageService**`. Это позволяет нам передавать объекты разных типов в качестве зависимостей для класса `**User**`, и он сможет работать с ними, используя единый интерфейс.
- **Singleton**
    
    Паттерн проектирования Singleton предназначен для обеспечения того, что класс имеет только один экземпляр, и предоставления глобальной точки доступа к этому экземпляру. Использование Singleton обычно используется, когда необходимо контролировать доступ к общим ресурсам или когда вам нужен только один экземпляр класса для координации действий во всей системе.
    
    Реализация Singleton на TypeScript может выглядеть следующим образом:
    
    ```TypeScript
    class Singleton {
      private static instance: Singleton;
    
      private constructor() {
        // Здесь могут быть инициализированы приватные свойства и методы
      }
    
      public static getInstance(): Singleton {
        if (!Singleton.instance) {
          Singleton.instance = new Singleton();
        }
        return Singleton.instance;
      }
    
      public someMethod(): void {
        console.log("Вызван метод someMethod класса Singleton");
      }
    }
    
    // Использование Singleton
    const instance1 = Singleton.getInstance();
    const instance2 = Singleton.getInstance();
    
    instance1.someMethod(); // Вывод: "Вызван метод someMethod класса Singleton"
    
    console.log(instance1 === instance2); // Вывод: true, так как оба экземпляра ссылаются на один и тот же объект
    ```
    
    В примере выше, класс `**Singleton**` имеет приватный конструктор, чтобы предотвратить создание экземпляров напрямую. Метод `**getInstance**` предоставляет глобальную точку доступа к единственному экземпляру класса, создавая его при первом вызове и возвращая существующий экземпляр при последующих вызовах.
    
    Метод `**someMethod**` является примером метода, который можно вызывать на экземпляре Singleton.
    
    При использовании этого паттерна важно быть осторожным с потоками выполнения и многопоточностью, так как создание единственного экземпляра может привести к проблемам с синхронизацией. В случае TypeScript и JavaScript многопоточность, как правило, не является проблемой, так как они используют однопоточную модель выполнения с асинхронными событиями.
    
    Паттерн проектирования Singleton основан на принципах объектно-ориентированного программирования (ООП). Вот некоторые из принципов ООП, которые используются в этом паттерне:
    
    1. Инкапсуляция: Singleton инкапсулирует свой единственный экземпляр внутри класса, предотвращая создание дополнительных экземпляров. Это достигается за счет объявления приватного конструктора и статического метода `**getInstance**`, который обеспечивает доступ к единственному экземпляру.
    2. Полиморфизм: В общем случае, Singleton может использоваться для расширения или замены поведения в производных классах, поддерживая полиморфизм. Однако, при использовании Singleton важно помнить, что наследование и переопределение методов могут привести к сложностям и неожиданным проблемам, так как во всей системе существует только один экземпляр класса.
    3. Абстракция: В зависимости от контекста, Singleton может обеспечивать абстракцию некоторого общего поведения или сервиса, предоставляя простой интерфейс для доступа к ресурсам или функциональности. Это может упростить взаимодействие с другими частями системы и способствовать модульности.
    
    Следует отметить, что в паттерне Singleton не используется принцип наследования, так как его цель - обеспечить единственный экземпляр класса. Однако, в некоторых случаях, Singleton может быть реализован с использованием наследования, когда базовый класс определяет общие свойства и методы, а производные классы могут расширять их и реализовывать паттерн Singleton.