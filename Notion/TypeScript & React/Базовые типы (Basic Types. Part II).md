  

Тип - **Array**

Существует 2 способа определения массива:

- в первом мы говорим о том, что тип данных - это числа и эти числа будут находится в массиве
- во втором с помощью ключевого слова array мы задаем тип данных - после чего с помощью number описываем эти данные (второй способ называется **Generic type**)

```TypeScript
// Array Type
let list: number[] = [1, 2, 3];

let list: Array<number> = [1, 2, 3];	// Generic type
```

А что если массив содержит различные типы данных?

Тогда на помощь приходит новый тип данных - **Tuple**.

Тут также существует 2 варианта записи:

- в первом внутри массива - мы сначала определяем будущие типы, а затем присваиваем в переменную соответсвующий массив
- во втором - мы делаем то же самое, только в одну строку. Разница в том, что если массив будет содержать набор из 10 разных элементов, которые нужно описать - то намного удобнее использовать именно первый случай.

```TypeScript
// Tuple Type
// Multiple lines
let x: [string, number];
x = ["hello", 10];

// One line
let y: [string, number] = ["goodbuy", 42];

// Error case:
x = [10, "hello"]; // Type 'string' is not assignable to type 'number'
```

Когда данные формируются динамически или предположим мы получаем их из сторонних библиотек или их физически трудно описать - то можно использовать тип Any.

В коде мы видим 2 примера:

- в первом - мы описываем динамически сформированный массив и используем для этого ключевое слово any
- во втором мы определяем переменную notSure - задаем ей тип **any**. И если внимательно разобрать пример - то при определении типа с помощью **any** - тип данных можно спокойно менять и никаких ошибок это не вызовет

Однако такая проверка типов - ненадежна. Так что данный тип вполне применим, но если есть возможность описать типы нормально - то лучше воспользоваться именно ею.

Тип **Any** является противоположностью типу **Void** - в одном случае у нас может быть любой тип данных, а в другом - полное отсутсвие типа.

```TypeScript
// Any Type
// Any type for array
let y: [any, any] = ["goodbuy", 42];
let z: Array<any> = [10, "hello"];

// Any type for string
let notSure: any = false;

// Issue case (no error)
notSure = true;		// boolean
notSure = 42;		// number
notSure = "hello";	// string
```

Тип - **Enum**

Фактически - это более удобный способ, который можно использовать для задания понятных имен - набору численных значений.

Пример:

**enum Directions** содержит набор основных направлений: Up, Down, Left, Right.

Этот набор не генерируется автоматически - а мы точно знаем все входящие в него элементы. Каждому элементу соответсвует свой индекс.

Таким образом, обратившись к каждому - мы получим следующий результат, который видим в коде.

Enum - это своеобразная смесь массива и объекта. По значение мы можем обращаться и получать соответсвующий индекс.

  

Перечисление начинается с 0.

Но никто не мешает нам путем переопределения - задать индекс для любого элемента, либо для каждого.

Если обратить внимание на Right - его значение 7. Так как при создании перечисления индекс следующего элемента, значение которого не задано - зависит от предыдущего.

```TypeScript
// Enum Type
enum Directions {
    Up,
    Down,
    Left,
    Right
}

Directions.Up;      // 0
Directions.Down;    // 1
Directions.Left;    // 2
Directions.Right;   // 3
```

```TypeScript
// Custom index for enum elements
enum Directions {
    Up = 2,
    Down = 4,
    Left = 6,
    Right
}

Directions.Up;      // 2
Directions.Down;    // 4
Directions.Left;    // 6
Directions.Right;   // 7
```

Тип - **Never**

Данный тип может использоваться в 2 случаях:

- когда функция возвращает ошибку и не заканчивает свое выполнение
- когда функция постоянно выполняется

Данный тип очень тесно связан с функцией.

Тип **Never** говорит о том, что от этих функций - результата мы не получим.

```TypeScript
// Never Type
// Function return Error
const msg = "hello";
const error = (msg: string): never => {
    throw new Error(msg);
};

// Function infinite loop
const infiniteLoop = (): never => {
    while (true) {
    }
};
```

Тип - **Object**

Этот тип предназначен для определения объекта или не примитива.

Пример:

Мы видим некую абстрактную функцию create, которая в качестве аргумента принимает o.

Тип o - это либо **object**, либо **null**.

Таким образом, если мы попробуем вызвать функцию create со строкой или числом - то получим ошибку.

  

В этом же примере мы можем видеть синтаксис нескольких типов. То есть если переменная может иметь несколько типов (например число или строку) - то эти типы просто отделяются вертикальной чертой **|**

Такой тип - называется **тип объединения**.

```TypeScript
// Object Type
const create = (o: object | null): void => { };

create(1);		// Argument of type '1' is not assignable to parameter of type 'object | null'
create('42');	// Argument of type '"42"' is not assignable to parameter of type 'object | null'
create({ obj: 1 });

// Multiple types for one value
let id: number | string;

id = 10;	// number is valid
id = '42';	// string is valid
id = true;	// Type 'true' is not assignable to type 'string | number'
```

И последний - это **Type**.

С помощью данного механизма можно создавать пользовательские типы.

Пример:

С помощью ключевого слова **type** - мы определяем так называемый псевдоним для кастомного типа.

И теперь этот новый тип Name - мы можем использовать при определении типов переменных.

```TypeScript
// Type
type Name = string;	// Custom type creation

let id: Name;	// Apply custom type

id = "42";	// No error, because type of "42" is a string
id = 10;	// Type '10' is not assignable to type 'string'
```