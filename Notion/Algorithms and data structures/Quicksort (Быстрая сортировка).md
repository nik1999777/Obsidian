```JavaScript
const arr = [0,3,2,5,6,8,23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,6]
let count = 0

function quickSort(array) {
  if (array.length <= 1) {
    return array
  }
  let pivotIndex = Math.floor(array.length / 2);
  let pivot = array[pivotIndex]
  let less = []
  let greater = []
  for (let i = 0; i < array.length; i++) {
    count += 1
    if(i === pivotIndex)
      continue
    if (array[i] < pivot) {
      less.push(array[i])
    } else {
      greater.push(array[i])
    }
  }
  return [...quickSort(less), pivot, ...quickSort(greater)]
}

console.log(quickSort(arr))
console.log('count', count)
```

```JavaScript
/usr/local/bin/node /Users/nikitaelin/Desktop/test/script.js
[
  -5, -1, 0, 1, 1,  2,  2,
   2,  3, 4, 4, 5,  6,  6,
   6,  7, 8, 9, 9, 23, 23
]
count 92

Process finished with exit code 0
```

**Быстрая сортировка** — это алгоритм **«разделяй и властвуй»**. Быстрая сортировка сначала делит большой массив на два меньших подмассива: младшие элементы и старшие элементы. Затем **Quicksort** может рекурсивно сортировать подмассивы.

Давайте посмотрим, как работает Quicksort:

1. Выберите элемент массива. Этот элемент обычно называют стержнем. Чаще всего этот элемент является первым или последним элементом массива.
2. Затем переставьте элементы массива так, чтобы все элементы слева от оси были меньше, чем точка поворота, а все элементы справа были больше, чем точка поворота. Шаг называется разбиением. Если элемент равен оси поворота - не имеет значения, с какой стороны он идет.
3. Повторите этот процесс отдельно для левой и правой стороны поворота, пока массив не будет отсортирован.

Как мы могли видеть, основой этого алгоритма является этап разделения. Этот шаг одинаково независим от того, используем ли мы рекурсивный или итерационный подход.

Имея это в виду, давайте сначала напишем код: (pivot - стержень, partition - разделение)

```JavaScript
function partition(arr, start, end) {
  const pivotValue = arr[end];
  let pivotIndex = start;

  for (let i = start; i < end; i++) {
    if (arr[i] < pivotValue) {
      [arr[i], arr[pivotIndex]] = [arr[pivotIndex], arr[i]];
      pivotIndex++;
    }
  }

  [arr[pivotIndex], arr[end]] = [arr[end], arr[pivotIndex]];
  return pivotIndex;
}
```

Здесь мы берем последний элемент в качестве стержня. Мы используем переменную `**pivotIndex**`, чтобы отслеживать «среднее» положение, когда все элементы слева меньше, а все элементы справа больше, чем `**pivotValue**`.

На последнем этапе мы меняем местами сводную точку, которая в нашем случае является последним элементом, на `**pivotIndex**`. Итак, в конце концов, наш опорный элемент окажется в «середине». Со всеми элементами, меньшими, чем точка поворота, слева от нее, и всеми элементами, которые больше или равны оси поворота справа от нее.

### **Рекурсивная реализация**

Теперь, когда у нас есть функция `**partition()**`, мы должны рекурсивно решить эту проблему и применить логику разделения, чтобы выполнить оставшиеся шаги.

В этой функции мы начинаем с разбиения массива. После этого мы разделяем левый и правый подмассивы. Мы повторяем этот процесс до тех пор, пока метод не получит массив, который не пуст или имеет более одного элемента.

Это связано с тем, что пустые массивы и массивы только с одним элементом считаются отсортированными.

```JavaScript
function quickSort(arr, start, end) {
  if (start >= end) {
    return;
  }

  let index = partition(arr, start, end);

  quickSort(arr, start, index - 1);
  quickSort(arr, index + 1, end);

  return arr;
}

const array = [7, -2, 4, 1, 6, 5, 0, -4, 2];
console.log(quickSort(array, 0, array.length - 1));
```

```JavaScript
[
  -4, -2, 0, 1, 2,
   4,  5, 6, 7
]

Process finished with exit code 0
```

### Итеративная реализация

Как мы упоминали ранее, рекурсивный подход к быстрой сортировке гораздо более интуитивно понятен. Однако итеративная реализация Quicksort - относительно частый вопрос для инженеров-программистов.

Как и в случае с большинством рекурсивных преобразований в итеративные, первое, что должно прийти в голову - это использование стека для имитации рекурсивных вызовов. Это сделано для того, чтобы мы могли повторно использовать часть знакомой нам рекурсивной логики и использовать ее в итеративной настройке.

Нам нужно как-то отслеживать, какие несортированные подмассивы у нас остались. Один из способов сделать это - просто сохранить «пары» элементов в стеке, представляющие `**start**` и `**end**` данного несортированного подмассива.

JavaScript не имеет явную структуру стека данных, но массивы поддерживают функции `**push()**` и `**pop()**`. Однако они не поддерживают функцию `**peek()**`, поэтому нам придется вручную проверять вершину стека, используя `**stack[stack.length - 1]**`.

Мы будем использовать ту же функцию `**partition**`, что и для рекурсивного подхода. Давайте посмотрим, как написать Quicksort:

```JavaScript
function quickSort(arr) {
  stack = [];

  stack.push(0);
  stack.push(arr.length - 1);

  while (stack[stack.length - 1] >= 0) {
    end = stack.pop();
    start = stack.pop();

    pivotIndex = partition(arr, start, end);

    if (pivotIndex - 1 > start) {
      stack.push(start);
      stack.push(pivotIndex - 1);
    }

    if (pivotIndex + 1 < end) {
      stack.push(pivotIndex + 1);
      stack.push(end);
    }
  }

  return arr;
}

const array = [7, -2, 4, 1, 6, 5, 0, -4, 2];
console.log(quickSort(array, 0, array.length - 1));
```

```JavaScript
[
  -4, -2, 0, 1, 2,
   4,  5, 6, 7
]

Process finished with exit code 0
```

### Эффективность быстрой сортировки

Теперь, когда мы знаем, как реализовать алгоритм быстрой сортировки, давайте обсудим временную и пространственную сложность. Наихудшая временная сложность быстрой сортировки составляет O(n2). Средняя временная сложность случая составляет O(nlogn). Наихудшего случая обычно избегают, используя рандомизированную версию Quicksort.

Слабым местом алгоритма Quicksort является выбор точки поворота. Выбор плохого поворота (тот, который больше / меньше большинства элементов) каждый раз дает нам наихудшую временную сложность. При многократном выборе стержня, который имеет примерно равное количество элементов, которые меньше / больше, чем стержень, мы получим временную сложность O(nlogn).

Быстрая сортировка - один из тех алгоритмов, для которых действительно важно среднее время выполнения. Опытным путем было замечено, что Quicksort имеет тенденцию иметь время выполнения O(nlogn) независимо от стратегии выбора точки поворота.

Кроме того, когда дело доходит до сложности пространства, Quicksort не занимает лишнего места (за исключением места, зарезервированного для рекурсивных вызовов). Эти виды алгоритмов технически называются оперативными алгоритмами. Нам не нужно дополнительное пространство, потому что мы выполняем операцию с тем же массивом.