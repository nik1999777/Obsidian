В компьютерных науках **бинарный** **поиск**, также известный как **полуинтервальный поиск**, **логарифмический поиск** или **двоичный поиск**, представляет собой алгоритм поиска, который находит положение целевого значения в отсортированном массиве. 

**Двоичный поиск** сравнивает целевое значение со средним элементом массива; если они не равны, половина, в которой цель не может лежать, исключается, а поиск продолжается на оставшейся половине до тех пор, пока он не будет успешным. Если поиск заканчивается тем, что оставшаяся половина пуста, цель отсутствует в массиве.

1. Для того чтобы найти центральный элемент `let middle` - нам нужно знать позицию первого и последнего элемента:
    - `let start = 0` - позиция первого элемента равна 0
    - `let end = array.length` - позиция последнего вычисляется по длине массива
2. Также нам понадобятся 2 вспомогательные переменные:
    - `let found` - некий флаг, который будет отображать нашли ли мы элемент в массиве или нет
    - `let position` - позиция самого элемента, который мы будем возвращать из функции. Если элемент не был найден - мы вернем минус один.
3. Далее мы создаем цикл `while`, в котором мы будем крутиться до тех пор:
    - `(found === false && start <= end)` - пока мы либо не нашли элемент `found === false`, либо стартовая и конечная позиции не поравнялись `start <= end`.
4. И теперь уже внутри цикла - высчитываем позицию центрального элемента:
    - `middle = Math.floor((start + end) / 2)` - стартовую позицию складываем с конечной позицией и делим на 2. Для ситуации если у нас получится не целое число - используем `Math.floor()`.
5. Следующем этапом в условии`(array[middle] === item)` проверяем - если элемент находящийся в массиве по индексу, который мы высчитали равен тому элементу, который мы ищем, то тогда:
    - флаг `found` устанавливаем в `true` - `found = true`
    - и присваиваем позицию - `position = middle`
    - и после этой итерации, если элемент найден - цикл остановиться `return position`
6. Если же на этой итерации - мы не нашли элемент, то тогда необходимо проверить `(item < array[middle])` :
    - если искомый элемент меньше чем элемент, который находится в самой середине - то тогда нас интересует только левая часть массива `end = middle - 1`
    - а если искомый элемент больше чем центральный - то тогда нас интересует только правая часть массива `start = middle + 1`
7. И последнее, что остается сделать в этой функции - это вернуть позицию элемента `return position`:
    - если он был найдет - он присвоиться в условии
    - если не найдет - то вернеться `-1`

Если посчитаем кол-во итераций с помощью `count` и выведем в `console.log(count)` и увидим, что `8` - программа нашла за `2` итерации.

Сложность данного алгоритма - `O(n*log(n))`

```JavaScript
const array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10];
let count = 0;

function binarySearch(array, item) {
  let start = 0;
  let end = array.length;
  let middle;
  let found = false;
  let position = -1;
  while (found === false && start <= end) {
    count += 1; // - for Big O
    middle = Math.floor((start + end) / 2);
    if (array[middle] === item) {
      found = true;
      position = middle;
      return position;
    }
    if (item < array[middle]) {
      end = middle - 1;
    } else {
      start = middle + 1;
    }
  }
  return position;
}

binarySearch(array, 8);
console.log(count);
```

```JavaScript
/usr/local/bin/node /Users/nikitaelin/Desktop/test/script.js
8
2

Process finished with exit code 0
```